; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\thatboyencrypt.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@DELBPIJA@?$LM?S?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@ ; `string'
PUBLIC	??_C@_0BE@DKIOJLDL@?I?z?$LD?I?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@ ; `string'
PUBLIC	??_C@_0M@OBMPDHDB@?$LA?s?$LG?$KI?I?h?$LB?$LI?4?4?4@ ; `string'
PUBLIC	??_C@_0BC@BOOHFHDH@?$LE?$KG?$MA?m?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_0BE@JDHBDFPA@?U?$PN?T?Z?$LE?$KG?$MA?m?N?D?$LM?$PO?D?Z?H?$NN?4?4?4@ ; `string'
PUBLIC	??_C@_0BI@EODDGCKG@?R?Q?P?$LE?H?k?J?p?C?$PL?S?r?$LK?M?N?D?$LM?$PO?M?$LH?4?4?4@ ; `string'
PUBLIC	??_C@_0BO@MHNEFFKB@?U?$PN?T?Z?$LE?$KG?$MA?m?J?$PN?$LO?$NN?$LP?i?$KD?$KM?G?k?D?M?P?D?$LF?H?$LE?$PN?4?4?4@ ; `string'
PUBLIC	??_C@_0BD@EEDJJGAN@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LM?S?C?$NM?M?j?$LD?I?$KB?$KD@ ; `string'
PUBLIC	??_C@_0O@HDFBCNEM@?$LN?b?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@ ; `string'
PUBLIC	??_C@_0BE@JFONAGKE@?Q?i?V?$KE?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@ ; `string'
PUBLIC	??_C@_0M@CJLCHMHN@?Q?i?V?$KE?I?h?$LB?$LI?4?4?4@	; `string'
PUBLIC	??_C@_0BC@HCLOMCPL@?$LN?b?N?v?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@ ; `string'
PUBLIC	??_C@_0BD@CIGKAML@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LN?b?C?$NM?M?j?$LD?I?$KB?$KD@ ; `string'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
EXTRN	__imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@U_Mbstatet@@@2@XZ:PROC
EXTRN	__imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z:PROC
EXTRN	__imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@V?$fpos@U_Mbstatet@@@2@@Z:PROC
EXTRN	__imp_?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_JXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp___splitpath_s:PROC
EXTRN	__imp___memccpy:PROC
EXTRN	__imp__rand:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@CIGKAML@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LN?b?C?$NM?M?j?$LD?I?$KB?$KD@
CONST	SEGMENT
??_C@_0BD@CIGKAML@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LN?b?C?$NM?M?j?$LD?I?$KB?$KD@ DB 0ceH
	DB	0c4H, 0bcH, 0feH, 0caH, 0fdH, 0beH, 0ddH, 0bdH, 0e2H, 0c3H, 0dcH
	DB	0cdH, 0eaH, 0b3H, 0c9H, 0a1H, 0a3H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HCLOMCPL@?$LN?b?N?v?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@
CONST	SEGMENT
??_C@_0BC@HCLOMCPL@?$LN?b?N?v?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@ DB 0bdH
	DB	0e2H, 0ceH, 0f6H, 0d4H, 0adH, 0caH, 0bcH, 0ceH, 0c4H, 0bcH, 0feH
	DB	0c3H, 0fbH, '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJLCHMHN@?Q?i?V?$KE?I?h?$LB?$LI?4?4?4@
CONST	SEGMENT
??_C@_0M@CJLCHMHN@?Q?i?V?$KE?I?h?$LB?$LI?4?4?4@ DB 0d1H, 0e9H, 0d6H, 0a4H
	DB	0c9H, 0e8H, 0b1H, 0b8H, '...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFONAGKE@?Q?i?V?$KE?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@
CONST	SEGMENT
??_C@_0BE@JFONAGKE@?Q?i?V?$KE?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@ DB 0d1H
	DB	0e9H, 0d6H, 0a4H, 0c3H, 0dcH, 0c2H, 0ebH, 0d5H, 0aaH, 0d2H, 0aaH
	DB	0d0H, 0c5H, 0cfH, 0a2H, '...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HDFBCNEM@?$LN?b?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@
CONST	SEGMENT
??_C@_0O@HDFBCNEM@?$LN?b?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@ DB 0bdH, 0e2H, 0c3H
	DB	0dcH, 0d7H, 0bcH, 0b1H, 0b8H, 0d6H, 0d0H, '...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEDJJGAN@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LM?S?C?$NM?M?j?$LD?I?$KB?$KD@
CONST	SEGMENT
??_C@_0BD@EEDJJGAN@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LM?S?C?$NM?M?j?$LD?I?$KB?$KD@ DB 0ceH
	DB	0c4H, 0bcH, 0feH, 0caH, 0fdH, 0beH, 0ddH, 0bcH, 0d3H, 0c3H, 0dcH
	DB	0cdH, 0eaH, 0b3H, 0c9H, 0a1H, 0a3H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MHNEFFKB@?U?$PN?T?Z?$LE?$KG?$MA?m?J?$PN?$LO?$NN?$LP?i?$KD?$KM?G?k?D?M?P?D?$LF?H?$LE?$PN?4?4?4@
CONST	SEGMENT
??_C@_0BO@MHNEFFKB@?U?$PN?T?Z?$LE?$KG?$MA?m?J?$PN?$LO?$NN?$LP?i?$KD?$KM?G?k?D?M?P?D?$LF?H?$LE?$PN?4?4?4@ DB 0d5H
	DB	0fdH, 0d4H, 0daH, 0b4H, 0a6H, 0c0H, 0edH, 0caH, 0fdH, 0beH, 0ddH
	DB	0bfH, 0e9H, 0a3H, 0acH, 0c7H, 0ebH, 0c4H, 0cdH, 0d0H, 0c4H, 0b5H
	DB	0c8H, 0b4H, 0fdH, '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EODDGCKG@?R?Q?P?$LE?H?k?J?p?C?$PL?S?r?$LK?M?N?D?$LM?$PO?M?$LH?4?4?4@
CONST	SEGMENT
??_C@_0BI@EODDGCKG@?R?Q?P?$LE?H?k?J?p?C?$PL?S?r?$LK?M?N?D?$LM?$PO?M?$LH?4?4?4@ DB 0d2H
	DB	0d1H, 0d0H, 0b4H, 0c8H, 0ebH, 0caH, 0f0H, 0c3H, 0fbH, 0d3H, 0f2H
	DB	0baH, 0cdH, 0ceH, 0c4H, 0bcH, 0feH, 0cdH, 0b7H, '...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDHBDFPA@?U?$PN?T?Z?$LE?$KG?$MA?m?N?D?$LM?$PO?D?Z?H?$NN?4?4?4@
CONST	SEGMENT
??_C@_0BE@JDHBDFPA@?U?$PN?T?Z?$LE?$KG?$MA?m?N?D?$LM?$PO?D?Z?H?$NN?4?4?4@ DB 0d5H
	DB	0fdH, 0d4H, 0daH, 0b4H, 0a6H, 0c0H, 0edH, 0ceH, 0c4H, 0bcH, 0feH
	DB	0c4H, 0daH, 0c8H, 0ddH, '...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BOOHFHDH@?$LE?$KG?$MA?m?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@
CONST	SEGMENT
??_C@_0BC@BOOHFHDH@?$LE?$KG?$MA?m?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@ DB 0b4H
	DB	0a6H, 0c0H, 0edH, 0d4H, 0adH, 0caH, 0bcH, 0ceH, 0c4H, 0bcH, 0feH
	DB	0c3H, 0fbH, '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBMPDHDB@?$LA?s?$LG?$KI?I?h?$LB?$LI?4?4?4@
CONST	SEGMENT
??_C@_0M@OBMPDHDB@?$LA?s?$LG?$KI?I?h?$LB?$LI?4?4?4@ DB 0b0H, 0f3H, 0b6H, 0a8H
	DB	0c9H, 0e8H, 0b1H, 0b8H, '...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DKIOJLDL@?I?z?$LD?I?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@
CONST	SEGMENT
??_C@_0BE@DKIOJLDL@?I?z?$LD?I?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@ DB 0c9H
	DB	0faH, 0b3H, 0c9H, 0c3H, 0dcH, 0c2H, 0ebH, 0d5H, 0aaH, 0d2H, 0aaH
	DB	0d0H, 0c5H, 0cfH, 0a2H, '...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DELBPIJA@?$LM?S?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@
CONST	SEGMENT
??_C@_0O@DELBPIJA@?$LM?S?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@ DB 0bcH, 0d3H, 0c3H
	DB	0dcH, 0d7H, 0bcH, 0b1H, 0b8H, 0d6H, 0d0H, '...', 00H ; `string'
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?makeDWORD@thatboy@@YAIEEEE@Z			; thatboy::makeDWORD
PUBLIC	?makeWORD@thatboy@@YAGEE@Z			; thatboy::makeWORD
PUBLIC	?makeDWORD@thatboy@@YAIGG@Z			; thatboy::makeDWORD
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::_Facet_base *,std::_Facet_base *>
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$distance@PAE@std@@YAHPAE0@Z			; std::distance<unsigned char *>
PUBLIC	??$_Refancy@PAE$0A@@std@@YAPAEPAE@Z		; std::_Refancy<unsigned char *,0>
PUBLIC	??$_Copy_memmove@PADPAE@std@@YAPAEPAD0PAE@Z	; std::_Copy_memmove<char *,unsigned char *>
PUBLIC	??$distance@PAD@std@@YAHPAD0@Z			; std::distance<char *>
PUBLIC	??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>
PUBLIC	?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric
PUBLIC	??$_Unfancy@$$CBD@std@@YAPBDPBD@Z		; std::_Unfancy<char const >
PUBLIC	??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z ; std::forward<std::allocator<unsigned char> const &>
PUBLIC	??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	??$_Assign_range@PAD@?$vector@EV?$allocator@E@std@@@std@@AAEXPAD0Uforward_iterator_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_range<char *>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
PUBLIC	??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@std@@YAPAEABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>
PUBLIC	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,void>
PUBLIC	??$_Get_unwrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@std@@YAPADABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>
PUBLIC	??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@X@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,void>
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	?_Local@?$_Func_class@_NHH@std@@ABE_NXZ		; std::_Func_class<bool,int,int>::_Local
PUBLIC	?_Set@?$_Func_class@_NHH@std@@AAEXPAV?$_Func_base@_NHH@2@@Z ; std::_Func_class<bool,int,int>::_Set
PUBLIC	?_Local@?$_Func_class@_NH@std@@ABE_NXZ		; std::_Func_class<bool,int>::_Local
PUBLIC	?_Set@?$_Func_class@_NH@std@@AAEXPAV?$_Func_base@_NH@2@@Z ; std::_Func_class<bool,int>::_Set
PUBLIC	?_Local@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABE_NXZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Local
PUBLIC	?_Set@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AAEXPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Set
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z	; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_Func_class@_NHH@std@@QAE@XZ		; std::_Func_class<bool,int,int>::_Func_class<bool,int,int>
PUBLIC	?_Empty@?$_Func_class@_NHH@std@@IBE_NXZ		; std::_Func_class<bool,int,int>::_Empty
PUBLIC	?_Tidy@?$_Func_class@_NHH@std@@IAEXXZ		; std::_Func_class<bool,int,int>::_Tidy
PUBLIC	?_Getimpl@?$_Func_class@_NHH@std@@ABEPAV?$_Func_base@_NHH@2@XZ ; std::_Func_class<bool,int,int>::_Getimpl
PUBLIC	??0?$_Func_class@_NH@std@@QAE@XZ		; std::_Func_class<bool,int>::_Func_class<bool,int>
PUBLIC	?_Empty@?$_Func_class@_NH@std@@IBE_NXZ		; std::_Func_class<bool,int>::_Empty
PUBLIC	?_Tidy@?$_Func_class@_NH@std@@IAEXXZ		; std::_Func_class<bool,int>::_Tidy
PUBLIC	?_Getimpl@?$_Func_class@_NH@std@@ABEPAV?$_Func_base@_NH@2@XZ ; std::_Func_class<bool,int>::_Getimpl
PUBLIC	??0?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Empty@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IBE_NXZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Empty
PUBLIC	?_Tidy@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXXZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tidy
PUBLIC	?_Getimpl@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Getimpl
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??R?$_Func_class@_NHH@std@@QBE_NHH@Z		; std::_Func_class<bool,int,int>::operator()
PUBLIC	??1?$_Func_class@_NHH@std@@QAE@XZ		; std::_Func_class<bool,int,int>::~_Func_class<bool,int,int>
PUBLIC	??0?$function@$$A6A_NHH@Z@std@@QAE@XZ		; std::function<bool __cdecl(int,int)>::function<bool __cdecl(int,int)>
PUBLIC	??B?$function@$$A6A_NHH@Z@std@@QBE_NXZ		; std::function<bool __cdecl(int,int)>::operator bool
PUBLIC	??R?$_Func_class@_NH@std@@QBE_NH@Z		; std::_Func_class<bool,int>::operator()
PUBLIC	??1?$_Func_class@_NH@std@@QAE@XZ		; std::_Func_class<bool,int>::~_Func_class<bool,int>
PUBLIC	??0?$function@$$A6A_NH@Z@std@@QAE@XZ		; std::function<bool __cdecl(int)>::function<bool __cdecl(int)>
PUBLIC	??B?$function@$$A6A_NH@Z@std@@QBE_NXZ		; std::function<bool __cdecl(int)>::operator bool
PUBLIC	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	??1?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>
PUBLIC	??B?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QBE_NXZ ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::operator bool
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ifstream<char,std::char_traits<char> >::is_open
PUBLIC	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ofstream<char,std::char_traits<char> >::is_open
PUBLIC	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
PUBLIC	?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ; thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename
PUBLIC	?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z ; thatboy::EncryptFileDoModal::Verify
PUBLIC	?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z ; thatboy::EncryptFileDoModal::Decrypt
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??0SignatureDomain@thatboy@@QAE@XZ		; thatboy::SignatureDomain::SignatureDomain
PUBLIC	?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z ; thatboy::EncryptFileDoModal::Encrypt
PUBLIC	??1?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::~function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>
PUBLIC	??1?$function@$$A6A_NH@Z@std@@QAE@XZ		; std::function<bool __cdecl(int)>::~function<bool __cdecl(int)>
PUBLIC	??1?$function@$$A6A_NHH@Z@std@@QAE@XZ		; std::function<bool __cdecl(int,int)>::~function<bool __cdecl(int,int)>
PUBLIC	?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
PUBLIC	?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
PUBLIC	?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A DB 028H DUP (?) ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A DB 028H DUP (?) ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A DB 028H DUP (?) ; thatboy::EncryptFileDoModal::callBackStatusUpdate
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$28
	DD	05H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$29
	DD	04H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$53
	DD	04H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$13
	DD	08H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$16
	DD	0aH
	DD	FLAT:__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$18
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$13
	DD	06H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z$0
?callBackSetProcessBarRange$initializer$@EncryptFileDoModal@thatboy@@3P6AXXZA DD FLAT:??__EcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange$initializer$
?callBackSetProcessBarPos$initializer$@EncryptFileDoModal@thatboy@@3P6AXXZA DD FLAT:??__EcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos$initializer$
?callBackStatusUpdate$initializer$@EncryptFileDoModal@thatboy@@3P6AXXZA DD FLAT:??__EcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::callBackStatusUpdate$initializer$
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??__EcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ
text$di	SEGMENT
??__EcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackSetProcessBarRange'', COMDAT

; 5    : std::function<bool(int, int)> thatboy::EncryptFileDoModal::callBackSetProcessBarRange;

	push	OFFSET ??__FcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarRange''
	call	_atexit
	pop	ecx
	ret	0
??__EcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackSetProcessBarRange''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??__FcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ
text$yd	SEGMENT
??__FcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarRange'', COMDAT

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN9@dynamic

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	cmp	ecx, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
$LN9@dynamic:
	ret	0
??__FcallBackSetProcessBarRange@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarRange''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$function@$$A6A_NHH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??1?$function@$$A6A_NHH@Z@std@@QAE@XZ PROC		; std::function<bool __cdecl(int,int)>::~function<bool __cdecl(int,int)>, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN6@function

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN6@function:
	pop	esi
	ret	0
??1?$function@$$A6A_NHH@Z@std@@QAE@XZ ENDP		; std::function<bool __cdecl(int,int)>::~function<bool __cdecl(int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??__EcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ
text$di	SEGMENT
??__EcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackSetProcessBarPos'', COMDAT

; 6    : std::function<bool(int)> thatboy::EncryptFileDoModal::callBackSetProcessBarPos;

	push	OFFSET ??__FcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarPos''
	call	_atexit
	pop	ecx
	ret	0
??__EcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackSetProcessBarPos''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??__FcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ
text$yd	SEGMENT
??__FcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarPos'', COMDAT

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN9@dynamic

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	cmp	ecx, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
$LN9@dynamic:
	ret	0
??__FcallBackSetProcessBarPos@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackSetProcessBarPos''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$function@$$A6A_NH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??1?$function@$$A6A_NH@Z@std@@QAE@XZ PROC		; std::function<bool __cdecl(int)>::~function<bool __cdecl(int)>, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN6@function

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN6@function:
	pop	esi
	ret	0
??1?$function@$$A6A_NH@Z@std@@QAE@XZ ENDP		; std::function<bool __cdecl(int)>::~function<bool __cdecl(int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??__EcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ
text$di	SEGMENT
??__EcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackStatusUpdate'', COMDAT

; 7    : std::function<bool(std::string)> thatboy::EncryptFileDoModal::callBackStatusUpdate;

	push	OFFSET ??__FcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackStatusUpdate''
	call	_atexit
	pop	ecx
	ret	0
??__EcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic initializer for 'callBackStatusUpdate''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??__FcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ
text$yd	SEGMENT
??__FcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ PROC ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackStatusUpdate'', COMDAT

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN9@dynamic

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	cmp	ecx, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
$LN9@dynamic:
	ret	0
??__FcallBackStatusUpdate@EncryptFileDoModal@thatboy@@YAXXZ ENDP ; thatboy::EncryptFileDoModal::`dynamic atexit destructor for 'callBackStatusUpdate''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ
_TEXT	SEGMENT
??1?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::~function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN6@function

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN6@function:
	pop	esi
	ret	0
??1?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::~function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z
_TEXT	SEGMENT
_ifs$ = -2404						; size = 184
_ofs$ = -2220						; size = 176
_tendChunk$ = -2044					; size = 16
$T22 = -2028						; size = 24
_fileContentBuff$ = -2016				; size = 12
_tdatChunk$ = -2004					; size = 28
tv9562 = -1976						; size = 4
tv9374 = -1976						; size = 4
_<_Args_0>$ = -1976					; size = 4
_pwdCRC$1$ = -1972					; size = 4
tv9535 = -1972						; size = 4
_chunkDataSize$GSCopy$1$ = -1968			; size = 4
$T165 = -1961						; size = 1
__Ptr$1$ = -1960					; size = 4
__Count$1$ = -1960					; size = 4
tv9376 = -1960						; size = 4
_crcType$1$ = -1956					; size = 4
__Result$2$ = -1956					; size = 4
__Count$1$ = -1956					; size = 4
_<_Args_0>$ = -1956					; size = 4
_<_Args_0>$ = -1956					; size = 4
_i$1$ = -1952						; size = 4
tv9372 = -1952						; size = 4
_<_Args_1>$ = -1952					; size = 4
_<_Args_0>$ = -1952					; size = 4
_crc$166 = -1948					; size = 1048
_crc$167 = -1948					; size = 1048
_ifs$168 = -1084					; size = 184
_signature$ = -900					; size = 320
_thdrChunk$ = -580					; size = 20
$T77 = -560						; size = 24
$T21 = -560						; size = 24
_chunkBuff$169 = -560					; size = 24
$T50 = -560						; size = 24
_fileNameNoExt$ = -536					; size = 260
_ext$ = -276						; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 8						; size = 24
_encryptFileName$ = 32					; size = 24
_password$ = 56						; size = 24
_deviceSerial$ = 80					; size = 24
_flushChunkWrite$ = 104					; size = 1
?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z PROC ; thatboy::EncryptFileDoModal::Encrypt, COMDAT
; _chunkDataSize$ = ecx
; _crcType$ = edx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2392				; 00000958H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _crcType$1$[ebp], edx
	mov	edi, ecx
	mov	DWORD PTR _chunkDataSize$GSCopy$1$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 25   : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN18@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0O@DELBPIJA@?$LM?S?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 25   : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	SHORT $LN70@Encrypt
$LN18@Encrypt:

; 26   : 	callBackSetProcessBarPos(0);

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx
	je	SHORT $LN20@Encrypt
	mov	DWORD PTR _<_Args_0>$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 26   : 	callBackSetProcessBarPos(0);

	test	al, al
	jne	SHORT $LN20@Encrypt
$LN70@Encrypt:
	mov	edi, 1
	jmp	$LN2763@Encrypt
$LN20@Encrypt:
	xor	eax, eax
	mov	DWORD PTR _signature$[ebp+16], 0
	push	260					; 00000104H
	push	eax
	mov	WORD PTR _signature$[ebp+57], ax
	xorps	xmm0, xmm0
	mov	BYTE PTR _signature$[ebp+59], al
	lea	eax, DWORD PTR _signature$[ebp+60]
	push	eax
	movups	XMMWORD PTR _signature$[ebp+24], xmm0
	movups	XMMWORD PTR _signature$[ebp+40], xmm0
	call	_memset
	add	esp, 12					; 0000000cH
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 8    : {

	mov	DWORD PTR _thdrChunk$[ebp], OFFSET ??_7THDR_Chunk@thatboy@@6B@

; 9    : 	Chunk::dataLength = sizeof(crcEncodeType) + sizeof(reserve);

	mov	DWORD PTR _thdrChunk$[ebp+4], 4

; 10   : 	Chunk::typeCode = hdrChunkType;

	mov	DWORD PTR _thdrChunk$[ebp+8], 1380206676 ; 52444854H

; 11   : 	Chunk::crcCode = 0;

	mov	DWORD PTR _thdrChunk$[ebp+12], 0

; 12   : 	crcEncodeType = static_cast<BYTE>(CRC32::CRC32_TYPE::eMPEG2);

	mov	DWORD PTR _thdrChunk$[ebp+16], 10	; 0000000aH

; 59   : {

	mov	DWORD PTR _tendChunk$[ebp], OFFSET ??_7TEND_Chunk@thatboy@@6B@

; 60   : 	Chunk::dataLength = 0;

	mov	DWORD PTR _tendChunk$[ebp+4], 0

; 61   : 	Chunk::typeCode = endChunkType;

	mov	DWORD PTR _tendChunk$[ebp+8], 1145980244 ; 444e4554H

; 62   : 	Chunk::crcCode = 0;

	mov	DWORD PTR _tendChunk$[ebp+12], 0

; 85   : {

	mov	DWORD PTR _tdatChunk$[ebp], OFFSET ??_7TDAT_Chunk@thatboy@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tdatChunk$[ebp+16], 0
	mov	DWORD PTR _tdatChunk$[ebp+20], 0
	mov	DWORD PTR _tdatChunk$[ebp+24], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 86   : 	Chunk::dataLength = 0;

	mov	DWORD PTR _tdatChunk$[ebp+4], 0

; 87   : 	Chunk::typeCode = dataChunkType;

	mov	DWORD PTR _tdatChunk$[ebp+8], 1413563476 ; 54414454H

; 88   : 	Chunk::crcCode = 0;

	mov	DWORD PTR _tdatChunk$[ebp+12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 35   : 	size_t fileSize = [](std::string file) {

	lea	eax, DWORD PTR _file$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	eax
	lea	ecx, DWORD PTR $T21[ebp]
	mov	DWORD PTR _pwdCRC$1$[ebp], 0
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 36   : 		ifstream ifs(file, ios::binary);

	push	ecx
	push	64					; 00000040H
	push	ecx
	lea	eax, DWORD PTR $T21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	lea	ecx, DWORD PTR _ifs$168[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >

; 37   : 		size_t fileSize;
; 38   : 		ifs.seekg(0, ios::end);

	push	2
	push	0
	push	0
	lea	ecx, DWORD PTR _ifs$168[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z

; 39   : 		fileSize = static_cast<size_t>(ifs.tellg());

	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$168[ebp]
	call	DWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@U_Mbstatet@@@2@XZ

; 40   : 		ifs.seekg(0);

	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR _ifs$168[ebp]
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 70   :         return _Myoff + _Fpos;

	mov	esi, DWORD PTR [eax+8]
	add	esi, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 40   : 		ifs.seekg(0);

	mov	eax, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 40   : 		ifs.seekg(0);

	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@V?$fpos@U_Mbstatet@@@2@@Z

; 41   : 		ifs.close();

	lea	ecx, DWORD PTR _ifs$168[ebp]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR _ifs$168[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$168[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$168[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$168[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$168[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$168[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$168[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 42   : 		return fileSize;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T21[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN383@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T21[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN393@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN393@Encrypt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN393@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN383@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 45   : 	signature.attributeMark = static_cast<BYTE>(password.empty() ? SignatureDomain::ENCRYPT_ATTRIBUTE::NORMAL : SignatureDomain::ENCRYPT_ATTRIBUTE::PASSWORD)

	mov	ecx, DWORD PTR _deviceSerial$[ebp+16]
	neg	ecx

; 46   : 		| static_cast<BYTE>(deviceSerial.empty() ? SignatureDomain::ENCRYPT_ATTRIBUTE::NORMAL : SignatureDomain::ENCRYPT_ATTRIBUTE::DEVICEBIND);
; 47   : 	signature.magicNumber = makeDWORD('T', 'E', 'F', 255);
; 48   : 	signature.oriFileSize = fileSize;

	mov	DWORD PTR _signature$[ebp+12], esi
	mov	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	sbb	cl, cl

; 49   : 	signature.version = makeDWORD(0, 0, 0, 1);

	mov	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	and	cl, 2
	cmp	DWORD PTR _password$[ebp+16], 0
	setne	al

; 50   : 	signature.chunkCount = (fileSize - 1) / chunkDataSize + 1;

	xor	edx, edx
	or	cl, al
	lea	eax, DWORD PTR [esi-1]
	div	edi

; 51   : 	signature.RXORCode = makeDWORD(rand() % 256, rand() % 256, rand() % 256, rand() % 256);

	mov	esi, DWORD PTR __imp__rand
	inc	eax
	mov	BYTE PTR _signature$[ebp+56], cl
	mov	DWORD PTR _signature$[ebp+8], eax
	call	esi
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN2856@Encrypt
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN2856@Encrypt:
	mov	DWORD PTR tv9372[ebp], eax
	call	esi
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN2857@Encrypt
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN2857@Encrypt:
	mov	DWORD PTR tv9374[ebp], eax
	call	esi
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN2858@Encrypt
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN2858@Encrypt:
	mov	DWORD PTR tv9376[ebp], eax
	call	esi
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN2859@Encrypt
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN2859@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	mov	ecx, DWORD PTR tv9372[ebp]
	movzx	edx, cl
	mov	ecx, DWORD PTR tv9374[ebp]
	shl	edx, 8
	movzx	ecx, cl

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	or	edx, ecx

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	eax, al
	mov	ecx, DWORD PTR tv9376[ebp]

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	shl	edx, 8

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	ecx, cl

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	or	edx, ecx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 58   : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	shl	edx, 8
	or	edx, eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 51   : 	signature.RXORCode = makeDWORD(rand() % 256, rand() % 256, rand() % 256, rand() % 256);

	mov	DWORD PTR _signature$[ebp+20], edx

; 58   : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	test	ecx, ecx
	je	SHORT $LN22@Encrypt

; 55   : 		return x * 100 / signature.chunkCount;

	imul	eax, DWORD PTR _signature$[ebp+8], 100
	xor	edx, edx

; 58   : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	DWORD PTR _<_Args_0>$[ebp], 0

; 55   : 		return x * 100 / signature.chunkCount;

	div	DWORD PTR _signature$[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_1>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 58   : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	DWORD PTR _<_Args_1>$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	push	edx
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 58   : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	test	al, al
	je	$LN75@Encrypt
$LN22@Encrypt:

; 59   : 
; 60   : 	// MD5 CRC
; 61   : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::PASSWORD) {

	mov	al, BYTE PTR _signature$[ebp+56]
	test	al, 1
	je	$LN23@Encrypt

; 62   : 		callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN25@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BE@DKIOJLDL@?I?z?$LD?I?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 62   : 		callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN75@Encrypt
$LN25@Encrypt:

; 63   : 		_memccpy(signature.passwordMD5, md5(password).c_str(), '\0', 32);

	push	32					; 00000020H
	push	0
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _password$[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T50[ebp]
	call	?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; thatboy::md5
	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN727@Encrypt

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [eax]
$LN727@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 63   : 		_memccpy(signature.passwordMD5, md5(password).c_str(), '\0', 32);

	push	eax
	lea	eax, DWORD PTR _signature$[ebp+24]
	push	eax
	call	DWORD PTR __imp___memccpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T50[ebp+20]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 63   : 		_memccpy(signature.passwordMD5, md5(password).c_str(), '\0', 32);

	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN743@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T50[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN753@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN753@Encrypt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN753@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN743@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 64   : 		CRC32 crc(CRC32::CRC32_TYPE::eMPEG2);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _crc$167[ebp]
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _password$[ebp+20], 16	; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _password$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	edx, DWORD PTR _crc$167[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _password$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
	cmp	DWORD PTR _password$[ebp+16], esi
	jbe	SHORT $LN767@Encrypt
	mov	ecx, DWORD PTR _crc$167[ebp+1040]
	mov	edi, eax
	lea	ecx, DWORD PTR [ecx-8]
	npad	4
$LL768@Encrypt:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edx, 8
	shr	eax, cl
	xor	al, BYTE PTR [esi+edi]
	inc	esi
	movzx	eax, al
	xor	edx, DWORD PTR _crc$167[ebp+eax*4+16]
	cmp	esi, DWORD PTR _password$[ebp+16]
	jb	SHORT $LL768@Encrypt
	mov	edi, DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
$LN767@Encrypt:

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	eax, DWORD PTR _crc$167[ebp+8]
	xor	eax, edx
	mov	DWORD PTR _pwdCRC$1$[ebp], eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 65   : 		pwdCRC= crc.crcCompute((BYTE_CPTR)password.c_str(), password.size());

	mov	al, BYTE PTR _signature$[ebp+56]
$LN23@Encrypt:

; 66   : 	}
; 67   : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::DEVICEBIND)

	test	al, 2
	je	$LN2849@Encrypt

; 69   : 		callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN28@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0M@OBMPDHDB@?$LA?s?$LG?$KI?I?h?$LB?$LI?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 69   : 		callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN75@Encrypt
$LN28@Encrypt:

; 70   : 		CRC32 crc(CRC32::CRC32_TYPE::eMPEG2);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _crc$166[ebp]
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _deviceSerial$[ebp+20], 16	; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	edx, DWORD PTR _crc$166[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
	cmp	DWORD PTR _deviceSerial$[ebp+16], esi
	jbe	SHORT $LN927@Encrypt
	mov	ecx, DWORD PTR _crc$166[ebp+1040]
	mov	edi, eax
	lea	ecx, DWORD PTR [ecx-8]
$LL928@Encrypt:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edx, 8
	shr	eax, cl
	xor	al, BYTE PTR [esi+edi]
	inc	esi
	movzx	eax, al
	xor	edx, DWORD PTR _crc$166[ebp+eax*4+16]
	cmp	esi, DWORD PTR _deviceSerial$[ebp+16]
	jb	SHORT $LL928@Encrypt
	mov	edi, DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
$LN927@Encrypt:

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	eax, DWORD PTR _crc$166[ebp+8]
	xor	eax, edx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 71   : 		signature.deviceIDCrc = crc.crcCompute((BYTE_CPTR)deviceSerial.c_str(), deviceSerial.size());

	mov	DWORD PTR _signature$[ebp+16], eax
$LN2849@Encrypt:

; 75   : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN30@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BC@BOOHFHDH@?$LE?$KG?$MA?m?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 75   : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN75@Encrypt
$LN30@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _file$[ebp+20], 16		; 00000010H
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 78   : 	_splitpath_s(file.c_str(), nullptr, 0, nullptr, 0, fileNameNoExt, MAX_PATH, ext, MAX_PATH);

	lea	ecx, DWORD PTR _ext$[ebp]
	push	260					; 00000104H
	push	ecx
	push	260					; 00000104H
	lea	ecx, DWORD PTR _fileNameNoExt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _file$[ebp]

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _file$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 78   : 	_splitpath_s(file.c_str(), nullptr, 0, nullptr, 0, fileNameNoExt, MAX_PATH, ext, MAX_PATH);

	push	0
	push	eax
	call	DWORD PTR __imp___splitpath_s

; 79   : 	sprintf_s((LPSTR)signature.oriFileName, MAX_PATH, "%s%s", fileNameNoExt, ext);

	lea	eax, DWORD PTR _ext$[ebp]
	push	eax
	lea	eax, DWORD PTR _fileNameNoExt$[ebp]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	eax, DWORD PTR _signature$[ebp+60]
	push	260					; 00000104H
	push	eax
	call	_sprintf_s

; 80   : 	for (size_t i = strlen((LPSTR)signature.oriFileName)+1; i < sizeof(signature.oriFileName); i++)

	lea	esi, DWORD PTR _signature$[ebp+60]
	add	esp, 56					; 00000038H
	lea	ecx, DWORD PTR [esi+1]
$LL2848@Encrypt:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL2848@Encrypt
	sub	esi, ecx
	inc	esi
	cmp	esi, 260				; 00000104H
	jae	SHORT $LN3@Encrypt
	npad	6
$LL4@Encrypt:

; 81   : 		signature.oriFileName[i] = rand() % 256;

	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN2860@Encrypt
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN2860@Encrypt:
	mov	BYTE PTR _signature$[ebp+esi+60], al
	inc	esi
	cmp	esi, 260				; 00000104H
	jb	SHORT $LL4@Encrypt
$LN3@Encrypt:

; 82   : 	for (size_t i = 0; i < sizeof(signature.oriFileName) / 4; i++)

	xor	ecx, ecx
	npad	10
$LL2831@Encrypt:

; 83   : 		((DWORD_PTR)signature.oriFileName)[i] ^= signature.magicNumber ^ XORCode ^ signature.RXORCode;

	mov	eax, DWORD PTR _signature$[ebp+ecx*4+60]
	xor	eax, DWORD PTR _signature$[ebp+20]
	xor	eax, DWORD PTR _signature$[ebp]
	xor	eax, 11184810				; 00aaaaaaH
	mov	DWORD PTR _signature$[ebp+ecx*4+60], eax
	inc	ecx
	cmp	ecx, 65					; 00000041H
	jb	SHORT $LL2831@Encrypt

; 86   : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	$LN32@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BE@JDHBDFPA@?U?$PN?T?Z?$LE?$KG?$MA?m?N?D?$LM?$PO?D?Z?H?$NN?4?4?4@
	lea	ecx, DWORD PTR $T77[ebp]

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T77[ebp+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T77[ebp+20], 15		; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T77[ebp], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 964  :     _Ret operator()(_Types... _Args) const {

	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 965  :         if (_Empty()) {

	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx
	jne	SHORT $LN1098@Encrypt

; 966  :             _Xbad_function_call();

	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
$LN1098@Encrypt:

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T77[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T77[ebp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR $T165[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN1115@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T77[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN1125@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN1125@Encrypt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1125@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	mov	al, BYTE PTR $T165[ebp]
	add	esp, 8
$LN1115@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 86   : 	callBackStatusUpdate("...");

	test	al, al
	jne	SHORT $LN32@Encrypt
$LN75@Encrypt:
	mov	edi, 1
	jmp	$LN2753@Encrypt
$LN32@Encrypt:

; 87   : 	// 
; 88   : 	ifstream ifs(file, ios::binary, _SH_DENYWR);

	push	ecx
	push	32					; 00000020H
	push	ecx
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >

; 89   : 	ofstream ofs(encryptFileName, ios::binary, _SH_DENYRW);

	sub	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	eax, DWORD PTR _encryptFileName$[ebp]
	lea	ecx, DWORD PTR _ofs$[ebp]
	push	eax
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ifs$[ebp+92], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 91   : 	if (!ifs.is_open() || !ofs.is_open())

	je	$LN34@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ofs$[ebp+80], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 91   : 	if (!ifs.is_open() || !ofs.is_open())

	je	$LN34@Encrypt

; 92   : 		return EncryptErrorCode::ENCRYPT_FILEOPENERROR;
; 93   : 
; 94   : 	/**********************  **************************/
; 95   : 	ofs.write((LPCSTR)&signature, sizeof(signature));

	push	0
	push	320					; 00000140H
	lea	eax, DWORD PTR _signature$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ofs$[ebp]
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 96   : 	/**********************  **************************/
; 97   : 	thdrChunk.doFigure(static_cast<BYTE>(crcType));

	push	DWORD PTR _crcType$1$[ebp]
	lea	ecx, DWORD PTR _thdrChunk$[ebp]
	call	?doFigure@THDR_Chunk@thatboy@@UAEXE@Z	; thatboy::THDR_Chunk::doFigure

; 98   : 	thdrChunk.write(ofs);

	lea	eax, DWORD PTR _ofs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _thdrChunk$[ebp]
	call	?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::THDR_Chunk::write

; 99   : 	ofs.flush();

	lea	ecx, DWORD PTR _ofs$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 100  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN36@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BI@EODDGCKG@?R?Q?P?$LE?H?k?J?p?C?$PL?S?r?$LK?M?N?D?$LM?$PO?M?$LH?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 100  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	jne	SHORT $LN36@Encrypt
	mov	edi, 1
	jmp	$LN2726@Encrypt
$LN36@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _fileContentBuff$[ebp], 0
	mov	DWORD PTR _fileContentBuff$[ebp+4], 0
	mov	DWORD PTR _fileContentBuff$[ebp+8], 0

; 1663 :         if (_Newcapacity > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN2820@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN1581@Encrypt

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	$LN2821@Encrypt

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN2804@Encrypt

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$1$[ebp], esi

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN1580@Encrypt
$LN1581@Encrypt:

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	DWORD PTR __Ptr$1$[ebp], eax
	mov	esi, eax
$LN1580@Encrypt:

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	edi, esi
	mov	DWORD PTR _fileContentBuff$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	0
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR _fileContentBuff$[ebp+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 461  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

	mov	DWORD PTR _fileContentBuff$[ebp+4], edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 102  : 	std::vector<BYTE> fileContentBuff(chunkDataSize);

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 103  : 	DWORD curXORCode = XORCode ^ signature.RXORCode ^ pwdCRC;

	mov	eax, DWORD PTR _signature$[ebp+20]
	xor	eax, DWORD PTR _pwdCRC$1$[ebp]

; 106  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	mov	DWORD PTR tv9562[ebp], eax
	je	SHORT $LN2850@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BO@MHNEFFKB@?U?$PN?T?Z?$LE?$KG?$MA?m?J?$PN?$LO?$NN?$LP?i?$KD?$KM?G?k?D?M?P?D?$LF?H?$LE?$PN?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 106  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	jne	SHORT $LN2850@Encrypt
	mov	edi, 1
	jmp	$LN83@Encrypt
$LN2850@Encrypt:

; 107  : 	for (size_t i = 0; i < signature.chunkCount; i++)

	cmp	DWORD PTR _signature$[ebp+8], 0
	mov	DWORD PTR _i$1$[ebp], 0
	jbe	$LN2853@Encrypt
	mov	DWORD PTR tv9535[ebp], 100		; 00000064H
	npad	1
$LL10@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR _chunkBuff$169[ebp+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR _chunkBuff$169[ebp+20], 15	; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR _chunkBuff$169[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1217 :         if (_Newsize < _Oldsize) { // trim

	mov	edx, DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
	mov	ecx, edi
	sub	ecx, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 110  : 		string chunkBuff;

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	edx, ecx
	jae	SHORT $LN1820@Encrypt

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	edi, DWORD PTR [edx+esi]

; 1222 :             return;

	jmp	SHORT $LN2862@Encrypt
$LN1820@Encrypt:

; 1223 :         }
; 1224 : 
; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN1821@Encrypt

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR _fileContentBuff$[ebp+8]
	sub	eax, esi

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	edx, eax
	jbe	SHORT $LN1822@Encrypt

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	edx
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1229 :                 return;

	mov	edi, DWORD PTR _fileContentBuff$[ebp+4]
	mov	esi, DWORD PTR _fileContentBuff$[ebp]
	mov	edx, DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
	jmp	SHORT $LN1821@Encrypt
$LN1822@Encrypt:

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	esi, edx
	sub	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	mov	edx, DWORD PTR _chunkDataSize$GSCopy$1$[ebp]
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	add	edi, esi
	mov	esi, DWORD PTR __Ptr$1$[ebp]
$LN2862@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 113  : 		ifs.read((LPSTR)fileContentBuff.data(), chunkDataSize);

	mov	DWORD PTR _fileContentBuff$[ebp+4], edi
$LN1821@Encrypt:
	push	0
	push	edx
	push	esi
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 114  : 		fileContentSize = static_cast<size_t>(ifs.gcount());

	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_JXZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 114  : 		fileContentSize = static_cast<size_t>(ifs.gcount());

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sub	edx, esi

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	ecx, edx
	jae	SHORT $LN1833@Encrypt

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [esi+ecx]

; 1219 :             _Orphan_range(_Newlast, _Mylast);
; 1220 :             _Destroy(_Newlast, _Mylast);
; 1221 :             _Mylast = _Newlast;

	mov	DWORD PTR _fileContentBuff$[ebp+4], eax

; 1222 :             return;

	jmp	SHORT $LN1834@Encrypt
$LN1833@Encrypt:

; 1223 :         }
; 1224 : 
; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN1834@Encrypt

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR _fileContentBuff$[ebp+8]
	sub	eax, esi

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN1835@Encrypt

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	ecx
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1229 :                 return;

	jmp	SHORT $LN1834@Encrypt
$LN1835@Encrypt:

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	ecx
	push	0
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	DWORD PTR __Count$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	add	edi, DWORD PTR __Count$1$[ebp]
	mov	DWORD PTR _fileContentBuff$[ebp+4], edi
$LN1834@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 117  : 		if (!Base64::encode(fileContentBuff, chunkBuff))

	lea	edx, DWORD PTR _chunkBuff$169[ebp]
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	call	?encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; thatboy::Base64::encode
	test	al, al
	je	$LN2819@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _chunkBuff$169[ebp+20], 16	; 00000010H

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR _chunkBuff$169[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1108 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	ecx, DWORD PTR _tdatChunk$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _chunkBuff$169[ebp]

; 2144 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR _chunkBuff$169[ebp]

; 3401 :         return iterator(

	add	edx, DWORD PTR _chunkBuff$169[ebp+16]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _chunkBuff$169[ebp+20], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1108 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	esi, DWORD PTR _tdatChunk$[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2144 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _chunkBuff$169[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1108 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sub	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2144 :         if (_Large_string_engaged()) {

	mov	DWORD PTR __Result$2$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	mov	DWORD PTR __Count$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1109 :             if (_Newsize > _Oldcapacity) {

	cmp	edx, ecx
	jbe	$LN2112@Encrypt

; 1286 :         if (_Newsize > max_size()) {

	cmp	edx, 2147483647				; 7fffffffH
	ja	$LN2820@Encrypt

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edi, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edi, 1
	sub	eax, edi
	cmp	ecx, eax
	jbe	SHORT $LN2064@Encrypt

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	edi, edx
	jmp	SHORT $LN2065@Encrypt
$LN2064@Encrypt:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	edi, ecx

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	edi, edx
	cmovb	edi, edx
$LN2065@Encrypt:

; 1292 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN2061@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2083@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H
	sub	esi, edx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN2346@Encrypt

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN2083@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1296 :             _Myfirst = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+16], 0

; 1297 :             _Mylast  = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+20], 0

; 1298 :             _Myend   = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+24], 0
$LN2061@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN2092@Encrypt

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	$LN2821@Encrypt

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN2346@Encrypt

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN2091@Encrypt
$LN2092@Encrypt:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN2093@Encrypt

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN2091@Encrypt
$LN2093@Encrypt:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN2091@Encrypt:
	mov	edx, DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _tdatChunk$[ebp+24], eax
	mov	eax, DWORD PTR __Result$2$[ebp]

; 1629 :             return _Newsize; // geometric growth would be insufficient
; 1630 :         }
; 1631 : 
; 1632 :         return _Geometric; // geometric growth is sufficient
; 1633 :     }
; 1634 : 
; 1635 :     // _Buy is an ABI zombie name
; 1636 :     void _Buy_raw(const size_type _Newcapacity) {
; 1637 :         // allocate array with _Newcapacity elements
; 1638 :         auto& _My_data    = _Mypair._Myval2;
; 1639 :         pointer& _Myfirst = _My_data._Myfirst;
; 1640 :         pointer& _Mylast  = _My_data._Mylast;
; 1641 :         pointer& _Myend   = _My_data._Myend;
; 1642 : 
; 1643 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1644 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1645 : 
; 1646 :         const auto _Newvec = _Getal().allocate(_Newcapacity);
; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR _tdatChunk$[ebp+16], esi

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR _tdatChunk$[ebp+20], esi
$LN2112@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	eax
	push	esi
	call	_memmove

; 3313 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	mov	edi, DWORD PTR __Count$1$[ebp]
	add	esp, 12					; 0000000cH
	add	edi, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 123  : 		for (size_t i = 0; i < tdatChunk.compressData.size() / 4; i++)

	xor	ecx, ecx
	mov	esi, DWORD PTR _tdatChunk$[ebp+16]
	mov	eax, edi
	sub	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1113 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

	mov	DWORD PTR _tdatChunk$[ebp+20], edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 123  : 		for (size_t i = 0; i < tdatChunk.compressData.size() / 4; i++)

	test	eax, -4					; fffffffcH
	jbe	SHORT $LN12@Encrypt
	mov	edx, DWORD PTR tv9562[ebp]
$LL13@Encrypt:

; 124  : 			((DWORD_PTR)tdatChunk.compressData.data())[i] ^= curXORCode;

	mov	eax, DWORD PTR [esi+ecx*4]
	xor	eax, edx
	xor	eax, 11184810				; 00aaaaaaH
	mov	DWORD PTR [esi+ecx*4], eax
	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR _tdatChunk$[ebp+20]
	mov	eax, edi
	mov	esi, DWORD PTR _tdatChunk$[ebp+16]
	sub	eax, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 123  : 		for (size_t i = 0; i < tdatChunk.compressData.size() / 4; i++)

	shr	eax, 2
	cmp	ecx, eax
	jb	SHORT $LL13@Encrypt
$LN12@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edi, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 125  : 		for (size_t i = (tdatChunk.compressData.size() / 4) * 4; i < tdatChunk.compressData.size(); i++)

	mov	edx, edi
	and	edx, -4					; fffffffcH
	cmp	edx, edi
	jae	SHORT $LN15@Encrypt
	npad	11
$LL16@Encrypt:

; 126  : 			tdatChunk.compressData[i] ^= curXORCode && (0XFF << (i % 4 - 1) * 8);

	cmp	DWORD PTR tv9562[ebp], 11184810		; 00aaaaaaH
	je	SHORT $LN48@Encrypt
	mov	eax, edx
	and	eax, 3
	lea	ecx, DWORD PTR [eax*8-8]
	mov	eax, 255				; 000000ffH
	shl	eax, cl
	test	eax, eax
	je	SHORT $LN48@Encrypt
	mov	cl, 1
	jmp	SHORT $LN49@Encrypt
$LN48@Encrypt:
	xor	cl, cl
$LN49@Encrypt:
	xor	BYTE PTR [esi+edx], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1505 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [esi+edx]

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _tdatChunk$[ebp+20]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 125  : 		for (size_t i = (tdatChunk.compressData.size() / 4) * 4; i < tdatChunk.compressData.size(); i++)

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR _tdatChunk$[ebp+16]
	sub	eax, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 125  : 		for (size_t i = (tdatChunk.compressData.size() / 4) * 4; i < tdatChunk.compressData.size(); i++)

	cmp	edx, eax
	jb	SHORT $LL16@Encrypt
$LN15@Encrypt:

; 127  : 
; 128  : 		tdatChunk.doFigure(thdrChunk.crcEncodeType);

	push	DWORD PTR _thdrChunk$[ebp+16]
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	call	?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z	; thatboy::TDAT_Chunk::doFigure

; 129  : 		tdatChunk.write(ofs);

	lea	eax, DWORD PTR _ofs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	call	?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::TDAT_Chunk::write

; 130  : 		if (flushChunkWrite)

	cmp	BYTE PTR _flushChunkWrite$[ebp], 0
	je	SHORT $LN40@Encrypt

; 131  : 			ofs.flush();

	lea	ecx, DWORD PTR _ofs$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN40@Encrypt:

; 133  : 		callBackSetProcessBarPos(chunkCountToProcessPos(i + 1));

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	mov	esi, DWORD PTR tv9535[ebp]
	test	ecx, ecx
	je	SHORT $LN42@Encrypt

; 55   : 		return x * 100 / signature.chunkCount;

	xor	edx, edx
	mov	eax, esi
	div	DWORD PTR _signature$[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_0>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 133  : 		callBackSetProcessBarPos(chunkCountToProcessPos(i + 1));

	mov	DWORD PTR _<_Args_0>$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 133  : 		callBackSetProcessBarPos(chunkCountToProcessPos(i + 1));

	test	al, al
	je	SHORT $LN2823@Encrypt
$LN42@Encrypt:

; 134  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _chunkBuff$169[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN2339@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _chunkBuff$169[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN2349@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN2346@Encrypt
$LN2349@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2339@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 107  : 	for (size_t i = 0; i < signature.chunkCount; i++)

	mov	eax, DWORD PTR _i$1$[ebp]
	add	esi, 100				; 00000064H
	mov	edi, DWORD PTR _signature$[ebp+8]
	inc	eax
	mov	DWORD PTR tv9535[ebp], esi
	mov	esi, DWORD PTR _fileContentBuff$[ebp]
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, edi
	jae	SHORT $LN2851@Encrypt
	mov	edi, DWORD PTR _fileContentBuff$[ebp+4]
	mov	DWORD PTR __Ptr$1$[ebp], esi
	jmp	$LL10@Encrypt
$LN2823@Encrypt:

; 133  : 		callBackSetProcessBarPos(chunkCountToProcessPos(i + 1));

	mov	edi, 1
	jmp	SHORT $LN80@Encrypt
$LN2819@Encrypt:
	mov	edi, 10					; 0000000aH
$LN80@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _chunkBuff$169[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN2152@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _chunkBuff$169[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN2162@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN2162@Encrypt
$LN2346@Encrypt:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2162@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2152@Encrypt:
	mov	esi, DWORD PTR _fileContentBuff$[ebp]
	jmp	$LN83@Encrypt
$LN2853@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 107  : 	for (size_t i = 0; i < signature.chunkCount; i++)

	mov	edi, DWORD PTR _signature$[ebp+8]
$LN2851@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 135  : 	callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	je	SHORT $LN2852@Encrypt

; 55   : 		return x * 100 / signature.chunkCount;

	imul	eax, edi, 100
	xor	edx, edx
	div	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_0>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 135  : 	callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	mov	DWORD PTR _<_Args_0>$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 135  : 	callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	test	al, al
	jne	SHORT $LN2852@Encrypt
	mov	edi, 1
	jmp	$LN83@Encrypt
$LN2852@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 982  :         return !_Getimpl();

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 136  : 	callBackStatusUpdate("");

	je	SHORT $LN46@Encrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BD@EEDJJGAN@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LM?S?C?$NM?M?j?$LD?I?$KB?$KD@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 136  : 	callBackStatusUpdate("");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	jne	SHORT $LN46@Encrypt
	mov	edi, 1
	jmp	$LN83@Encrypt
$LN46@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR _ifs$[ebp+92], 0
	je	SHORT $LN2701@Encrypt

; 377  :             _Ans = this;

	lea	edi, DWORD PTR _ifs$[ebp+16]

; 378  :             if (!_Endwrite()) {

	mov	ecx, edi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR _ifs$[ebp+92]
	xor	ecx, ecx
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2702@Encrypt
$LN2701@Encrypt:

; 702  :         _Closef    = _Which == _Openfl;

	xor	edi, edi
$LN2702@Encrypt:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	lea	ecx, DWORD PTR _ifs$[ebp+16]
	mov	BYTE PTR _ifs$[ebp+88], 0
	mov	BYTE PTR _ifs$[ebp+77], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR _ifs$[ebp+80], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR _ifs$[ebp+92], 0
	mov	DWORD PTR _ifs$[ebp+84], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR _ifs$[ebp+72], 0

; 980  :         if (!_Filebuffer.close()) {

	test	edi, edi
	jne	SHORT $LN2698@Encrypt

; 981  :             _Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR _ifs$[ebp]
	lea	ecx, DWORD PTR _ifs$[ebp]
	push	edi
	push	2
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2698@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 139  : 	tendChunk.doFigure(thdrChunk.crcEncodeType);

	push	DWORD PTR _thdrChunk$[ebp+16]
	lea	ecx, DWORD PTR _tendChunk$[ebp]
	call	?doFigure@TEND_Chunk@thatboy@@UAEXE@Z	; thatboy::TEND_Chunk::doFigure

; 140  : 	tendChunk.write(ofs);

	lea	eax, DWORD PTR _ofs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tendChunk$[ebp]
	call	?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::Chunk::write
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR _ofs$[ebp+80], 0
	je	SHORT $LN2715@Encrypt

; 377  :             _Ans = this;

	lea	edi, DWORD PTR _ofs$[ebp+4]

; 378  :             if (!_Endwrite()) {

	mov	ecx, edi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR _ofs$[ebp+80]
	xor	ecx, ecx
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2716@Encrypt
$LN2715@Encrypt:

; 702  :         _Closef    = _Which == _Openfl;

	xor	edi, edi
$LN2716@Encrypt:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	lea	ecx, DWORD PTR _ofs$[ebp+4]
	mov	BYTE PTR _ofs$[ebp+76], 0
	mov	BYTE PTR _ofs$[ebp+65], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR _ofs$[ebp+68], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR _ofs$[ebp+80], 0
	mov	DWORD PTR _ofs$[ebp+72], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR _ofs$[ebp+60], 0

; 1173 :         if (!_Filebuffer.close()) {

	test	edi, edi
	jne	SHORT $LN2712@Encrypt

; 1174 :             _Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR _ofs$[ebp]
	lea	ecx, DWORD PTR _ofs$[ebp]
	push	edi
	push	2
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2712@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 143  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	xor	edi, edi
$LN83@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN2726@Encrypt

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR _fileContentBuff$[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2742@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H
	sub	eax, esi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN2804@Encrypt
$LN2742@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1703 :             _Myend   = pointer();

	jmp	SHORT $LN2726@Encrypt
$LN34@Encrypt:
	mov	edi, 2
$LN2726@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

	mov	eax, DWORD PTR _ofs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ofs$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ofs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR _ofs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ofs$[ebp+4]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ofs$[ebp+8]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ofs$[ebp+104]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR _ifs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN2753@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR _tdatChunk$[ebp+16]
	test	ecx, ecx
	je	SHORT $LN2763@Encrypt

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	edx, DWORD PTR _tdatChunk$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN2779@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN2804@Encrypt
$LN2779@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+16], 0

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+20], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR _tdatChunk$[ebp+24], 0
$LN2763@Encrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _file$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN2797@Encrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _file$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN2807@Encrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN2807@Encrypt
$LN2804@Encrypt:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2807@Encrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2797@Encrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 143  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	lea	ecx, DWORD PTR _encryptFileName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR _file$[ebp+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR _file$[ebp+20], 15		; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR _file$[ebp], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 143  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _password$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, edi

; 144  : 
; 145  : 
; 146  : #undef callBackSetProcessBarRange
; 147  : #undef callBackSetProcessBarPos
; 148  : #undef callBackStatusUpdate
; 149  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2820@Encrypt:
	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN2821@Encrypt:
	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2861@Encrypt:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$0:
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$1:
	lea	ecx, DWORD PTR _password$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$2:
	lea	ecx, DWORD PTR _encryptFileName$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$3:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$5:
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	jmp	??1TDAT_Chunk@thatboy@@QAE@XZ
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$28:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$29:
	lea	ecx, DWORD PTR _ifs$168[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$53:
	lea	ecx, DWORD PTR $T77[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$13:
	lea	ecx, DWORD PTR _ifs$[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$14:
	lea	ecx, DWORD PTR _ofs$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$16:
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z$18:
	lea	ecx, DWORD PTR _chunkBuff$169[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2404]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z ENDP ; thatboy::EncryptFileDoModal::Encrypt
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 24
_ifs$ = -200						; size = 184
__$EHRec$ = -12						; size = 12
_file$ = 8						; size = 24
??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; <lambda_bd5209fe60ea693a3654fa8c8c591453>::operator(), COMDAT
; _this$dead$ = ecx

; 35   : 	size_t fileSize = [](std::string file) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 36   : 		ifstream ifs(file, ios::binary);

	push	ecx
	push	64					; 00000040H
	push	ecx
	lea	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >

; 37   : 		size_t fileSize;
; 38   : 		ifs.seekg(0, ios::end);

	push	2
	push	0
	push	0
	lea	ecx, DWORD PTR _ifs$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z

; 39   : 		fileSize = static_cast<size_t>(ifs.tellg());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@U_Mbstatet@@@2@XZ

; 40   : 		ifs.seekg(0);

	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR _ifs$[ebp]
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 70   :         return _Myoff + _Fpos;

	mov	esi, DWORD PTR [eax+8]
	add	esi, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 40   : 		ifs.seekg(0);

	mov	eax, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 40   : 		ifs.seekg(0);

	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@V?$fpos@U_Mbstatet@@@2@@Z

; 41   : 		ifs.close();

	lea	ecx, DWORD PTR _ifs$[ebp]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR _ifs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _file$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN26@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _file$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN36@operator

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN36@operator
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN36@operator:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN26@operator:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 42   : 		return fileSize;

	mov	eax, esi

; 43   : 	}(file);

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN43@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR _ifs$[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_bd5209fe60ea693a3654fa8c8c591453>@@QBEIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; <lambda_bd5209fe60ea693a3654fa8c8c591453>::operator()
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??R<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QBEHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??R<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QBEHH@Z PROC ; <lambda_6f3344afa8ea55a74eace450e9c4527a>::operator(), COMDAT
; _this$ = ecx

; 54   : 	{

	push	ebp
	mov	ebp, esp

; 55   : 		return x * 100 / signature.chunkCount;

	imul	eax, DWORD PTR _x$[ebp], 100
	xor	edx, edx
	mov	ecx, DWORD PTR [ecx]
	div	DWORD PTR [ecx+8]

; 56   : 	};

	pop	ebp
	ret	4
??R<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QBEHH@Z ENDP ; <lambda_6f3344afa8ea55a74eace450e9c4527a>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??0<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QAE@AAUSignatureDomain@thatboy@@@Z
_TEXT	SEGMENT
_<signature>$ = 8					; size = 4
??0<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QAE@AAUSignatureDomain@thatboy@@@Z PROC ; <lambda_6f3344afa8ea55a74eace450e9c4527a>::<lambda_6f3344afa8ea55a74eace450e9c4527a>, COMDAT
; _this$ = ecx

; 56   : 	};

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<signature>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_6f3344afa8ea55a74eace450e9c4527a>@@QAE@AAUSignatureDomain@thatboy@@@Z ENDP ; <lambda_6f3344afa8ea55a74eace450e9c4527a>::<lambda_6f3344afa8ea55a74eace450e9c4527a>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SignatureDomain@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0SignatureDomain@thatboy@@QAE@XZ PROC			; thatboy::SignatureDomain::SignatureDomain, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	push	263					; 00000107H
	push	0
	mov	DWORD PTR [esi], -12171948		; ff464554H
	lea	eax, DWORD PTR [esi+57]
	mov	DWORD PTR [esi+4], 16777216		; 01000000H
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	movups	XMMWORD PTR [esi+24], xmm0
	push	eax
	movups	XMMWORD PTR [esi+40], xmm0
	mov	BYTE PTR [esi+56], 0
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	0
??0SignatureDomain@thatboy@@QAE@XZ ENDP			; thatboy::SignatureDomain::SignatureDomain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [ecx+112]
	lea	ecx, DWORD PTR [esi-96]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-112]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-112]
	mov	DWORD PTR [edx+esi-116], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-88]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [ecx+104]
	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-104]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z
_TEXT	SEGMENT
_ofs$ = -1856						; size = 176
_ifs$ = -1680						; size = 184
_tdatChunk$ = -1496					; size = 28
_<_Args_1>$ = -1468					; size = 4
_NChunk$162 = -1464					; size = 20
_fileContentBuff$ = -1456				; size = 12
_pwdCRC$1$ = -1444					; size = 4
_<_Args_0>$ = -1444					; size = 4
_flushChunkWrite$1$ = -1437				; size = 1
_<_Args_0>$ = -1436					; size = 4
$T163 = -1429						; size = 1
_crc$164 = -1428					; size = 1048
_crc$165 = -1428					; size = 1048
_signature$ = -380					; size = 320
_codeData$166 = -60					; size = 24
$T62 = -60						; size = 24
_thdrChunk$ = -36					; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_encryptFileName$ = 8					; size = 24
_file$ = 32						; size = 24
_password$ = 56						; size = 24
_deviceSerial$ = 80					; size = 24
?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z PROC ; thatboy::EncryptFileDoModal::Decrypt, COMDAT
; _flushChunkWrite$ = cl

; 158  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1844				; 00000734H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	BYTE PTR _flushChunkWrite$1$[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 165  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN14@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0O@HDFBCNEM@?$LN?b?C?$NM?W?$LM?$LB?$LI?V?P?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 165  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	SHORT $LN76@Decrypt
$LN14@Decrypt:

; 166  : 	callBackSetProcessBarPos(0);

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx
	je	SHORT $LN16@Decrypt
	mov	DWORD PTR _<_Args_0>$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 166  : 	callBackSetProcessBarPos(0);

	test	al, al
	jne	SHORT $LN16@Decrypt
$LN76@Decrypt:
	mov	esi, 1
	jmp	$LN77@Decrypt
$LN16@Decrypt:
	push	263					; 00000107H
	xorps	xmm0, xmm0
	mov	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	lea	eax, DWORD PTR _signature$[ebp+57]
	mov	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	push	0
	push	eax
	mov	DWORD PTR _signature$[ebp+8], 0
	mov	DWORD PTR _signature$[ebp+12], 0
	mov	DWORD PTR _signature$[ebp+16], 0
	mov	DWORD PTR _signature$[ebp+20], 0
	movups	XMMWORD PTR _signature$[ebp+24], xmm0
	mov	BYTE PTR _signature$[ebp+56], 0
	movups	XMMWORD PTR _signature$[ebp+40], xmm0
	call	_memset
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 8    : {

	mov	DWORD PTR _thdrChunk$[ebp], OFFSET ??_7THDR_Chunk@thatboy@@6B@

; 9    : 	Chunk::dataLength = sizeof(crcEncodeType) + sizeof(reserve);

	mov	DWORD PTR _thdrChunk$[ebp+4], 4

; 10   : 	Chunk::typeCode = hdrChunkType;

	mov	DWORD PTR _thdrChunk$[ebp+8], 1380206676 ; 52444854H

; 11   : 	Chunk::crcCode = 0;

	mov	DWORD PTR _thdrChunk$[ebp+12], 0

; 12   : 	crcEncodeType = static_cast<BYTE>(CRC32::CRC32_TYPE::eMPEG2);

	mov	DWORD PTR _thdrChunk$[ebp+16], 10	; 0000000aH

; 85   : {

	mov	DWORD PTR _tdatChunk$[ebp], OFFSET ??_7TDAT_Chunk@thatboy@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tdatChunk$[ebp+16], 0
	mov	DWORD PTR _tdatChunk$[ebp+20], 0
	mov	DWORD PTR _tdatChunk$[ebp+24], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 86   : 	Chunk::dataLength = 0;

	mov	DWORD PTR _tdatChunk$[ebp+4], 0

; 87   : 	Chunk::typeCode = dataChunkType;

	mov	DWORD PTR _tdatChunk$[ebp+8], 1413563476 ; 54414454H

; 88   : 	Chunk::crcCode = 0;

	mov	DWORD PTR _tdatChunk$[ebp+12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 175  : 	ifstream ifs(encryptFileName, ios::binary, _SH_DENYWR);

	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR _encryptFileName$[ebp]
	xor	edi, edi
	mov	DWORD PTR _pwdCRC$1$[ebp], edi
	push	32					; 00000020H
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ifs$[ebp+92], edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 176  : 	if (!ifs.is_open())

	jne	SHORT $LN17@Decrypt
	lea	esi, DWORD PTR [edi+2]
	jmp	$LN90@Decrypt
$LN17@Decrypt:

; 177  : 		return EncryptErrorCode::ENCRYPT_FILEOPENERROR;
; 178  : 
; 179  : 	ifs.read((LPSTR)&signature, sizeof(signature));

	push	0
	push	320					; 00000140H
	lea	eax, DWORD PTR _signature$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 180  : 
; 181  : 	// 
; 182  : 	if (signature.magicNumber != makeDWORD('T', 'E', 'F', 255))

	cmp	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	je	SHORT $LN18@Decrypt

; 183  : 		return EncryptErrorCode::ENCRYPT_FILETYPEERROR;

	mov	esi, 3
	jmp	$LN90@Decrypt
$LN18@Decrypt:

; 184  : 	if (signature.version != makeDWORD(0, 0, 0, 1))

	cmp	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	je	SHORT $LN19@Decrypt

; 185  : 		return EncryptErrorCode::ENCRYPT_VERSIONNOTMATCH;

	mov	esi, 4
	jmp	$LN90@Decrypt
$LN19@Decrypt:

; 191  : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx
	je	SHORT $LN2982@Decrypt

; 189  : 		return x * 100 / signature.chunkCount;

	imul	eax, DWORD PTR _signature$[ebp+8], 100
	xor	edx, edx

; 191  : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	DWORD PTR _<_Args_0>$[ebp], 0

; 189  : 		return x * 100 / signature.chunkCount;

	div	DWORD PTR _signature$[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	lea	edx, DWORD PTR _<_Args_1>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 191  : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	mov	DWORD PTR _<_Args_1>$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	push	edx
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 191  : 	callBackSetProcessBarRange(0, chunkCountToProcessPos(signature.chunkCount));

	test	al, al
	je	$LN2996@Decrypt
$LN2982@Decrypt:

; 192  : 
; 193  : 	// MD5 CRC
; 194  : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::PASSWORD)

	mov	al, BYTE PTR _signature$[ebp+56]
	test	al, 1
	je	$LN22@Decrypt

; 196  : 		callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN24@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BE@JFONAGKE@?Q?i?V?$KE?C?$NM?B?k?U?$KK?R?$KK?P?E?O?$KC?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 196  : 		callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN2996@Decrypt
$LN24@Decrypt:

; 197  : 		if (password.empty())

	cmp	DWORD PTR _password$[ebp+16], 0
	jne	SHORT $LN25@Decrypt

; 198  : 			return EncryptErrorCode::ENCRYPT_NEEDPASSWORD;

	mov	esi, 7
	jmp	$LN90@Decrypt
$LN25@Decrypt:

; 199  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _password$[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T62[ebp]
	call	?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; thatboy::md5
	mov	ecx, eax
	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN1240@Decrypt

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN1240@Decrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 199  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	lea	edx, DWORD PTR _signature$[ebp+24]
	mov	esi, 28					; 0000001cH
	npad	1
$LL2979@Decrypt:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN2978@Decrypt
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL2979@Decrypt
	xor	esi, esi
	jmp	SHORT $LN2981@Decrypt
$LN2978@Decrypt:
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN2980@Decrypt
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN2980@Decrypt
	mov	al, BYTE PTR [ecx+2]
	cmp	al, BYTE PTR [edx+2]
	jne	SHORT $LN2980@Decrypt
	mov	al, BYTE PTR [ecx+3]
	cmp	al, BYTE PTR [edx+3]
	jne	SHORT $LN2980@Decrypt
	xor	esi, esi
	jmp	SHORT $LN2981@Decrypt
$LN2980@Decrypt:
	sbb	esi, esi
	or	esi, 1
$LN2981@Decrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T62[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN1256@Decrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T62[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN1266@Decrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN1266@Decrypt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1266@Decrypt:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN1256@Decrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 199  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	test	esi, esi
	je	SHORT $LN26@Decrypt

; 200  : 			return EncryptErrorCode::ENCRYPT_PASSWORDNOTMATCH;

	mov	esi, 5
	jmp	$LN90@Decrypt
$LN26@Decrypt:

; 201  : 
; 202  : 		CRC32 crc(CRC32::CRC32_TYPE::eMPEG2);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _crc$165[ebp]
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _password$[ebp+20], 16	; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR _password$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	edi, DWORD PTR _crc$165[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR _password$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	edx, edx
	cmp	DWORD PTR _password$[ebp+16], edx
	jbe	SHORT $LN1416@Decrypt
	mov	ecx, DWORD PTR _crc$165[ebp+1040]
	lea	ecx, DWORD PTR [ecx-8]
	npad	4
$LL1417@Decrypt:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edi

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edi, 8
	shr	eax, cl
	xor	al, BYTE PTR [edx+esi]
	inc	edx
	movzx	eax, al
	xor	edi, DWORD PTR _crc$165[ebp+eax*4+16]
	cmp	edx, DWORD PTR _password$[ebp+16]
	jb	SHORT $LL1417@Decrypt
$LN1416@Decrypt:

; 79   :     return (remainder ^ m_final_xor_value);

	xor	edi, DWORD PTR _crc$165[ebp+8]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 203  : 		pwdCRC = crc.crcCompute((BYTE_CPTR)password.c_str(), password.size());

	mov	al, BYTE PTR _signature$[ebp+56]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 79   :     return (remainder ^ m_final_xor_value);

	mov	DWORD PTR _pwdCRC$1$[ebp], edi
$LN22@Decrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 205  : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::DEVICEBIND)

	test	al, 2
	je	$LN2984@Decrypt

; 207  : 		callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN2983@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0M@CJLCHMHN@?Q?i?V?$KE?I?h?$LB?$LI?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 207  : 		callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN2996@Decrypt
$LN2983@Decrypt:

; 208  : 		if (deviceSerial.empty())

	cmp	DWORD PTR _deviceSerial$[ebp+16], 0
	jne	SHORT $LN30@Decrypt

; 209  : 			return EncryptErrorCode::ENCRYPT_NEEDDEVICE;

	mov	esi, 8
	jmp	$LN90@Decrypt
$LN30@Decrypt:

; 210  : 		CRC32 crc(CRC32::CRC32_TYPE::eMPEG2);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _crc$164[ebp]
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _deviceSerial$[ebp+20], 16	; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	edx, DWORD PTR _crc$164[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
	cmp	DWORD PTR _deviceSerial$[ebp+16], esi
	jbe	SHORT $LN1714@Decrypt
	mov	ecx, DWORD PTR _crc$164[ebp+1040]
	mov	edi, eax
	lea	ecx, DWORD PTR [ecx-8]
	npad	6
$LL1715@Decrypt:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edx, 8
	shr	eax, cl
	xor	al, BYTE PTR [esi+edi]
	inc	esi
	movzx	eax, al
	xor	edx, DWORD PTR _crc$164[ebp+eax*4+16]
	cmp	esi, DWORD PTR _deviceSerial$[ebp+16]
	jb	SHORT $LL1715@Decrypt
	mov	edi, DWORD PTR _pwdCRC$1$[ebp]
$LN1714@Decrypt:

; 79   :     return (remainder ^ m_final_xor_value);

	mov	eax, DWORD PTR _crc$164[ebp+8]
	xor	eax, edx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 211  : 		if (signature.deviceIDCrc != crc.crcCompute((BYTE_CPTR)deviceSerial.c_str(), deviceSerial.size()))

	cmp	DWORD PTR _signature$[ebp+16], eax
	je	SHORT $LN2984@Decrypt

; 212  : 			return EncryptErrorCode::ENCRYPT_DEVICENOTMATCH;

	mov	esi, 6
	jmp	$LN90@Decrypt
$LN2984@Decrypt:

; 216  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN2985@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BC@HCLOMCPL@?$LN?b?N?v?T?$KN?J?$LM?N?D?$LM?$PO?C?$PL?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 216  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	SHORT $LN2996@Decrypt
$LN2985@Decrypt:

; 217  : 	for (size_t i = 0; i < sizeof(signature.oriFileName) / 4; i++)

	xor	ecx, ecx
	npad	2
$LL2962@Decrypt:

; 218  : 		((DWORD_PTR)signature.oriFileName)[i] ^= signature.magicNumber ^ XORCode ^ signature.RXORCode;

	mov	eax, DWORD PTR _signature$[ebp+ecx*4+60]
	xor	eax, DWORD PTR _signature$[ebp+20]
	xor	eax, DWORD PTR _signature$[ebp]
	xor	eax, 11184810				; 00aaaaaaH
	mov	DWORD PTR _signature$[ebp+ecx*4+60], eax
	inc	ecx
	cmp	ecx, 65					; 00000041H
	jb	SHORT $LL2962@Decrypt

; 219  : 	if (file.empty())

	cmp	DWORD PTR _file$[ebp+16], 0
	jne	SHORT $LN34@Decrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2707 :         return assign(_Ptr);

	lea	eax, DWORD PTR _signature$[ebp+60]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN34@Decrypt:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 222  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN36@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BE@JDHBDFPA@?U?$PN?T?Z?$LE?$KG?$MA?m?N?D?$LM?$PO?D?Z?H?$NN?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 222  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	jne	SHORT $LN36@Decrypt
$LN2996@Decrypt:

; 280  : 
; 281  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	mov	esi, 1
	jmp	$LN90@Decrypt
$LN36@Decrypt:

; 223  : 	/**********************  **************************/
; 224  : 	thdrChunk.read(ifs);

	lea	eax, DWORD PTR _ifs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _thdrChunk$[ebp]
	call	?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::THDR_Chunk::read
	mov	eax, DWORD PTR _thdrChunk$[ebp+4]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 35   : 	NChunk.doFigure(crcEncodeType);

	lea	ecx, DWORD PTR _NChunk$162[ebp]
	push	DWORD PTR _thdrChunk$[ebp+16]
	mov	DWORD PTR _NChunk$162[ebp+4], eax
	mov	eax, DWORD PTR _thdrChunk$[ebp+8]
	mov	DWORD PTR _NChunk$162[ebp+8], eax
	mov	eax, DWORD PTR _thdrChunk$[ebp+12]
	mov	DWORD PTR _NChunk$162[ebp+12], eax
	mov	al, BYTE PTR _thdrChunk$[ebp+16]
	mov	BYTE PTR _NChunk$162[ebp+16], al
	mov	ax, WORD PTR _thdrChunk$[ebp+17]
	mov	WORD PTR _NChunk$162[ebp+17], ax
	mov	al, BYTE PTR _thdrChunk$[ebp+19]
	mov	DWORD PTR _NChunk$162[ebp], OFFSET ??_7THDR_Chunk@thatboy@@6B@
	mov	BYTE PTR _NChunk$162[ebp+19], al
	call	?doFigure@THDR_Chunk@thatboy@@UAEXE@Z	; thatboy::THDR_Chunk::doFigure

; 36   : 	return NChunk.crcCode == crcCode;

	mov	eax, DWORD PTR _NChunk$162[ebp+12]
	cmp	eax, DWORD PTR _thdrChunk$[ebp+12]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 225  : 	if (!thdrChunk.checkCrcCode(thdrChunk.crcEncodeType))

	je	SHORT $LN37@Decrypt

; 226  : 		return EncryptErrorCode::ENCRYPT_CRCCHECKFAILURE;

	mov	esi, 9
	jmp	$LN90@Decrypt
$LN37@Decrypt:

; 227  : 	/**********************  **************************/
; 228  : 	// 
; 229  : 	ofstream ofs(file, ios::binary, _SH_DENYRW);

	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _file$[ebp]
	lea	ecx, DWORD PTR _ofs$[ebp]
	push	eax
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ofs$[ebp+80], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 230  : 	if (!ofs.is_open())

	jne	SHORT $LN38@Decrypt
	mov	esi, 2
	jmp	$LN91@Decrypt
$LN38@Decrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _fileContentBuff$[ebp], 0
	mov	DWORD PTR _fileContentBuff$[ebp+4], 0
	mov	DWORD PTR _fileContentBuff$[ebp+8], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 232  : 	vector<BYTE> fileContentBuff;

	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 233  : 	auto getChunkType = [](ifstream& ifs)
; 234  : 	{
; 235  : 		DWORD chunkType;
; 236  : 		ifs.seekg(4, ios::cur);
; 237  : 		ifs.read((LPTSTR)&chunkType, sizeof(chunkType));
; 238  : 		ifs.seekg(-8, ios::cur);
; 239  : 		return chunkType;
; 240  : 	};
; 241  : 	DWORD curXORCode = XORCode ^ signature.RXORCode ^ pwdCRC;

	mov	esi, DWORD PTR _signature$[ebp+20]
	xor	esi, edi

; 243  : 	callBackStatusUpdate("...");

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	je	SHORT $LN40@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_0BO@MHNEFFKB@?U?$PN?T?Z?$LE?$KG?$MA?m?J?$PN?$LO?$NN?$LP?i?$KD?$KM?G?k?D?M?P?D?$LF?H?$LE?$PN?4?4?4@

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 243  : 	callBackStatusUpdate("...");

	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	je	$LN2995@Decrypt
$LN40@Decrypt:

; 245  : 	while (getChunkType(ifs)== TDAT_Chunk::dataChunkType)

	lea	eax, DWORD PTR _ifs$[ebp]
	push	eax
	call	??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z ; <lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>::operator()
	cmp	eax, 1413563476				; 54414454H
	jne	$LN6@Decrypt

; 244  : 	int curChunkPtr = 0;

	xor	edi, edi
	npad	4
$LL5@Decrypt:

; 246  : 	{
; 247  : 		DWORD thisChunkType = getChunkType(ifs);

	lea	eax, DWORD PTR _ifs$[ebp]
	push	eax
	call	??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z ; <lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>::operator()

; 248  : 		if (thisChunkType == TEND_Chunk::endChunkType)

	cmp	eax, 1145980244				; 444e4554H
	je	$LN6@Decrypt

; 249  : 			break;
; 250  : 		else if (thisChunkType == TEND_Chunk::endChunkType)
; 251  : 			return EncryptErrorCode::ENCRYPT_ERRORCHUNK;
; 252  : 		else if (thisChunkType != TDAT_Chunk::dataChunkType)

	cmp	eax, 1413563476				; 54414454H
	jne	$LN2952@Decrypt

; 254  : 
; 255  : 		tdatChunk.read(ifs);

	lea	eax, DWORD PTR _ifs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	call	?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::TDAT_Chunk::read

; 256  : 
; 257  : 		// CRC
; 258  : 		if (!tdatChunk.checkCrcCode(thdrChunk.crcEncodeType))

	push	DWORD PTR _thdrChunk$[ebp+16]
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	call	?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z ; thatboy::TDAT_Chunk::checkCrcCode
	test	al, al
	je	$LN2953@Decrypt

; 260  : 		/***********  ***********/
; 261  : 		string codeData(tdatChunk.compressData.begin(), tdatChunk.compressData.end());

	push	ecx
	push	DWORD PTR _tdatChunk$[ebp+20]
	lea	ecx, DWORD PTR _codeData$166[ebp]
	push	DWORD PTR _tdatChunk$[ebp+16]
	call	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,void>
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 262  : 
; 263  : 		/************  ***********/
; 264  : 		for (size_t i = 0; i < codeData.size() / 4; i++)

	xor	edx, edx
	mov	ecx, DWORD PTR _codeData$166[ebp+16]
	test	ecx, -4					; fffffffcH
	jbe	SHORT $LN8@Decrypt
$LL9@Decrypt:

; 265  : 			((DWORD_PTR)codeData.data())[i] ^= curXORCode;

	lea	ecx, DWORD PTR _codeData$166[ebp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	lea	ecx, DWORD PTR [eax+edx*4]
	inc	edx
	mov	eax, DWORD PTR [ecx]
	xor	eax, esi
	xor	eax, 11184810				; 00aaaaaaH
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _codeData$166[ebp+16]
	mov	eax, ecx
	shr	eax, 2
	cmp	edx, eax
	jb	SHORT $LL9@Decrypt
$LN8@Decrypt:

; 266  : 		for (size_t i = (codeData.size() / 4) * 4; i < codeData.size(); i++)

	mov	edx, ecx
	and	edx, -4					; fffffffcH
	cmp	edx, ecx
	jae	SHORT $LN11@Decrypt
	npad	4
$LL12@Decrypt:

; 267  : 			codeData[i] ^= curXORCode && (0XFF << (i % 4 - 1) * 8);

	cmp	esi, 11184810				; 00aaaaaaH
	je	SHORT $LN56@Decrypt
	mov	eax, edx
	mov	BYTE PTR $T163[ebp], 1
	and	eax, 3
	lea	ecx, DWORD PTR [eax*8-8]
	mov	eax, 255				; 000000ffH
	shl	eax, cl
	test	eax, eax
	jne	SHORT $LN57@Decrypt
$LN56@Decrypt:
	mov	BYTE PTR $T163[ebp], 0
$LN57@Decrypt:
	push	edx
	lea	ecx, DWORD PTR _codeData$166[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	cl, BYTE PTR $T163[ebp]
	inc	edx
	xor	BYTE PTR [eax], cl
	cmp	edx, DWORD PTR _codeData$166[ebp+16]
	jb	SHORT $LL12@Decrypt
$LN11@Decrypt:

; 268  : 
; 269  : 		if (!Base64::decode(codeData, fileContentBuff))

	push	ecx
	lea	edx, DWORD PTR _fileContentBuff$[ebp]
	lea	ecx, DWORD PTR _codeData$166[ebp]
	call	?decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@4@_N@Z ; thatboy::Base64::decode
	add	esp, 4
	test	al, al
	je	$LN2954@Decrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _fileContentBuff$[ebp]
	mov	ecx, DWORD PTR _fileContentBuff$[ebp+4]
	sub	ecx, eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 271  : 		ofs.write((LPCSTR)fileContentBuff.data(), fileContentBuff.size());

	push	0
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _ofs$[ebp]
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 272  : 
; 273  : 		if (flushChunkWrite)

	cmp	BYTE PTR _flushChunkWrite$1$[ebp], 0
	je	SHORT $LN48@Decrypt

; 274  : 			ofs.flush();

	lea	ecx, DWORD PTR _ofs$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN48@Decrypt:

; 275  : 		callBackSetProcessBarPos(chunkCountToProcessPos(++curChunkPtr));

	cmp	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
	je	SHORT $LN50@Decrypt
	add	edi, 100				; 00000064H

; 189  : 		return x * 100 / signature.chunkCount;

	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR _signature$[ebp+8]

; 275  : 		callBackSetProcessBarPos(chunkCountToProcessPos(++curChunkPtr));

	push	eax
	call	??R?$_Func_class@_NH@std@@QBE_NH@Z	; std::_Func_class<bool,int>::operator()
	test	al, al
	je	SHORT $LN2955@Decrypt
$LN50@Decrypt:

; 276  : 	}callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	lea	ecx, DWORD PTR _codeData$166[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR _ifs$[ebp]
	push	eax
	call	??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z ; <lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>::operator()
	cmp	eax, 1413563476				; 54414454H
	je	$LL5@Decrypt
$LN6@Decrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 982  :         return !_Getimpl();

	cmp	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 276  : 	}callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	je	SHORT $LN52@Decrypt

; 189  : 		return x * 100 / signature.chunkCount;

	imul	eax, DWORD PTR _signature$[ebp+8], 100
	xor	edx, edx
	div	DWORD PTR _signature$[ebp+8]

; 276  : 	}callBackSetProcessBarPos(chunkCountToProcessPos(signature.chunkCount));

	push	eax
	call	??R?$_Func_class@_NH@std@@QBE_NH@Z	; std::_Func_class<bool,int>::operator()
	test	al, al
	je	SHORT $LN2995@Decrypt
$LN52@Decrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 982  :         return !_Getimpl();

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 277  : 	callBackStatusUpdate("");

	je	SHORT $LN54@Decrypt
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET ??_C@_0BD@CIGKAML@?N?D?$LM?$PO?J?$PN?$LO?$NN?$LN?b?C?$NM?M?j?$LD?I?$KB?$KD@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	call	??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
	test	al, al
	jne	SHORT $LN54@Decrypt
$LN2995@Decrypt:

; 280  : 
; 281  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	mov	esi, 1
	jmp	SHORT $LN99@Decrypt
$LN2955@Decrypt:

; 275  : 		callBackSetProcessBarPos(chunkCountToProcessPos(++curChunkPtr));

	lea	ecx, DWORD PTR _codeData$166[ebp]
	mov	esi, 1
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN99@Decrypt
$LN2954@Decrypt:
	lea	ecx, DWORD PTR _codeData$166[ebp]
	mov	esi, 10					; 0000000aH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN99@Decrypt
$LN2953@Decrypt:

; 259  : 			return EncryptErrorCode::ENCRYPT_CRCCHECKFAILURE;

	mov	esi, 9
	jmp	SHORT $LN99@Decrypt
$LN2952@Decrypt:

; 253  : 			return EncryptErrorCode::ENCRYPT_UNKNOWCHUNK;

	mov	esi, 12					; 0000000cH
	jmp	SHORT $LN99@Decrypt
$LN54@Decrypt:

; 278  : 	ofs.close();

	lea	ecx, DWORD PTR _ofs$[ebp]
	call	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close

; 279  : 	ifs.close();

	lea	ecx, DWORD PTR _ifs$[ebp]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close

; 280  : 
; 281  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	xor	esi, esi
$LN99@Decrypt:
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN91@Decrypt:
	lea	ecx, DWORD PTR _ofs$[ebp]
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN90@Decrypt:
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	call	??1TDAT_Chunk@thatboy@@QAE@XZ
$LN77@Decrypt:
	lea	ecx, DWORD PTR _encryptFileName$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _password$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, esi

; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2994@Decrypt:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$0:
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$1:
	lea	ecx, DWORD PTR _password$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$2:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$3:
	lea	ecx, DWORD PTR _encryptFileName$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$5:
	lea	ecx, DWORD PTR _tdatChunk$[ebp]
	jmp	??1TDAT_Chunk@thatboy@@QAE@XZ
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$6:
	lea	ecx, DWORD PTR _ifs$[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$13:
	lea	ecx, DWORD PTR _ofs$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$14:
	lea	ecx, DWORD PTR _fileContentBuff$[ebp]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z$16:
	lea	ecx, DWORD PTR _codeData$166[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1856]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z ENDP ; thatboy::EncryptFileDoModal::Decrypt
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??R<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QBEHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??R<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QBEHH@Z PROC ; <lambda_a1764e1b7ded1a761a00741f1f0fb99b>::operator(), COMDAT
; _this$ = ecx

; 188  : 	{

	push	ebp
	mov	ebp, esp

; 189  : 		return x * 100 / signature.chunkCount;

	imul	eax, DWORD PTR _x$[ebp], 100
	xor	edx, edx
	mov	ecx, DWORD PTR [ecx]
	div	DWORD PTR [ecx+8]

; 190  : 	};

	pop	ebp
	ret	4
??R<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QBEHH@Z ENDP ; <lambda_a1764e1b7ded1a761a00741f1f0fb99b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??0<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QAE@AAUSignatureDomain@thatboy@@@Z
_TEXT	SEGMENT
_<signature>$ = 8					; size = 4
??0<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QAE@AAUSignatureDomain@thatboy@@@Z PROC ; <lambda_a1764e1b7ded1a761a00741f1f0fb99b>::<lambda_a1764e1b7ded1a761a00741f1f0fb99b>, COMDAT
; _this$ = ecx

; 190  : 	};

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<signature>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_a1764e1b7ded1a761a00741f1f0fb99b>@@QAE@AAUSignatureDomain@thatboy@@@Z ENDP ; <lambda_a1764e1b7ded1a761a00741f1f0fb99b>::<lambda_a1764e1b7ded1a761a00741f1f0fb99b>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z
_TEXT	SEGMENT
_chunkType$ = -4					; size = 4
_ifs$ = 8						; size = 4
??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z PROC ; <lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>::operator(), COMDAT
; _this$dead$ = ecx

; 234  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 235  : 		DWORD chunkType;
; 236  : 		ifs.seekg(4, ios::cur);

	mov	esi, DWORD PTR _ifs$[ebp]
	mov	ecx, esi
	push	1
	push	0
	push	4
	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z

; 237  : 		ifs.read((LPTSTR)&chunkType, sizeof(chunkType));

	push	0
	push	4
	lea	eax, DWORD PTR _chunkType$[esp+16]
	mov	ecx, esi
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 238  : 		ifs.seekg(-8, ios::cur);

	push	1
	push	-1
	push	-8					; fffffff8H
	mov	ecx, esi
	call	DWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z

; 239  : 		return chunkType;

	mov	eax, DWORD PTR _chunkType$[esp+8]

; 240  : 	};

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??R<lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>@@QBEIAAV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@Z ENDP ; <lambda_2fb648421a4f0c3b46bf2bb8e4ebe686>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z
_TEXT	SEGMENT
_ifs$ = -1600						; size = 184
__Result$2$ = -1416					; size = 4
tv2449 = -1412						; size = 4
_crc$43 = -1408						; size = 1048
_signature$ = -360					; size = 320
$T20 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_encryptFileName$ = 8					; size = 24
_password$ = 32						; size = 24
_deviceSerial$ = 56					; size = 24
?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z PROC ; thatboy::EncryptFileDoModal::Verify, COMDAT

; 285  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1588				; 00000634H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	eax, DWORD PTR _signature$[ebp+57]
	push	263					; 00000107H
	xorps	xmm0, xmm0
	mov	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	push	0
	push	eax
	mov	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	mov	DWORD PTR _signature$[ebp+8], 0
	mov	DWORD PTR _signature$[ebp+12], 0
	mov	DWORD PTR _signature$[ebp+16], 0
	mov	DWORD PTR _signature$[ebp+20], 0
	movups	XMMWORD PTR _signature$[ebp+24], xmm0
	mov	BYTE PTR _signature$[ebp+56], 0
	movups	XMMWORD PTR _signature$[ebp+40], xmm0
	call	_memset

; 286  : 	using namespace std;
; 287  : 
; 288  : 	SignatureDomain signature;
; 289  : 	/**********************  **************************/
; 290  : 	ifstream ifs(encryptFileName, ios::binary);

	add	esp, 8
	lea	eax, DWORD PTR _encryptFileName$[ebp]
	push	64					; 00000040H
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ifs$[ebp+92], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 291  : 	if (!ifs.is_open())

	jne	SHORT $LN2@Verify
	mov	esi, 2
	jmp	$LN24@Verify
$LN2@Verify:

; 292  : 		return EncryptErrorCode::ENCRYPT_FILEOPENERROR;
; 293  : 
; 294  : 	ifs.read((LPSTR)&signature, sizeof(signature));

	push	0
	push	320					; 00000140H
	lea	eax, DWORD PTR _signature$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 295  : 	ifs.close();

	lea	ecx, DWORD PTR _ifs$[ebp]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close

; 296  : 
; 297  : 	// 
; 298  : 	if (signature.magicNumber != makeDWORD('T', 'E', 'F', 255))

	cmp	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	je	SHORT $LN3@Verify

; 299  : 		return EncryptErrorCode::ENCRYPT_FILETYPEERROR;

	mov	esi, 3
	jmp	$LN24@Verify
$LN3@Verify:

; 300  : 	if (signature.version != makeDWORD(0, 0, 0, 1))

	cmp	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	je	SHORT $LN4@Verify

; 301  : 		return EncryptErrorCode::ENCRYPT_VERSIONNOTMATCH;

	mov	esi, 4
	jmp	$LN24@Verify
$LN4@Verify:

; 302  : 
; 303  : 	// MD5 CRC
; 304  : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::PASSWORD)

	mov	al, BYTE PTR _signature$[ebp+56]
	test	al, 1
	je	$LN7@Verify

; 305  : 	{
; 306  : 		if (password.empty())

	cmp	DWORD PTR _password$[ebp+16], 0
	jne	SHORT $LN6@Verify

; 307  : 			return EncryptErrorCode::ENCRYPT_NEEDPASSWORD;

	mov	esi, 7
	jmp	$LN24@Verify
$LN6@Verify:

; 308  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _password$[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T20[ebp]
	call	?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; thatboy::md5
	mov	ecx, eax
	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN393@Verify

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN393@Verify:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 308  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	lea	edx, DWORD PTR _signature$[ebp+24]
	mov	esi, 28					; 0000001cH
$LL773@Verify:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN772@Verify
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL773@Verify
	xor	esi, esi
	jmp	SHORT $LN775@Verify
$LN772@Verify:
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN774@Verify
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN774@Verify
	mov	al, BYTE PTR [ecx+2]
	cmp	al, BYTE PTR [edx+2]
	jne	SHORT $LN774@Verify
	mov	al, BYTE PTR [ecx+3]
	cmp	al, BYTE PTR [edx+3]
	jne	SHORT $LN774@Verify
	xor	esi, esi
	jmp	SHORT $LN775@Verify
$LN774@Verify:
	sbb	esi, esi
	or	esi, 1
$LN775@Verify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T20[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN409@Verify
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN419@Verify

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN419@Verify
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN419@Verify:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN409@Verify:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 308  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	test	esi, esi
	je	SHORT $LN776@Verify

; 309  : 			return EncryptErrorCode::ENCRYPT_PASSWORDNOTMATCH;

	mov	esi, 5
	jmp	$LN24@Verify
$LN776@Verify:

; 308  : 		if (memcmp(md5(password).c_str(), signature.passwordMD5, 32))

	mov	al, BYTE PTR _signature$[ebp+56]
$LN7@Verify:

; 310  : 	}
; 311  : 	if (signature.attributeMark & (BYTE)SignatureDomain::ENCRYPT_ATTRIBUTE::DEVICEBIND)

	test	al, 2
	je	$LN10@Verify
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 3649 :         return size() == 0;

	mov	edi, DWORD PTR _deviceSerial$[ebp+16]
	test	edi, edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 313  : 		if (deviceSerial.empty())

	jne	SHORT $LN9@Verify

; 314  : 			return EncryptErrorCode::ENCRYPT_NEEDDEVICE;

	lea	esi, DWORD PTR [edi+8]
	jmp	SHORT $LN24@Verify
$LN9@Verify:

; 315  : 		CRC32 crc(CRC32::CRC32_TYPE::eMPEG2);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _crc$43[ebp]
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _deviceSerial$[ebp+20], 16	; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	edx, DWORD PTR _crc$43[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR _deviceSerial$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	mov	DWORD PTR __Result$2$[ebp], eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	test	edi, edi
	je	SHORT $LN597@Verify
	mov	ecx, DWORD PTR _crc$43[ebp+1040]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR tv2449[ebp], ecx
$LL598@Verify:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edx, 8
	shr	eax, cl
	movzx	ecx, al
	mov	eax, DWORD PTR __Result$2$[ebp]
	movzx	eax, BYTE PTR [esi+eax]
	inc	esi
	xor	ecx, eax
	xor	edx, DWORD PTR _crc$43[ebp+ecx*4+16]
	mov	ecx, DWORD PTR tv2449[ebp]
	cmp	esi, edi
	jb	SHORT $LL598@Verify
$LN597@Verify:

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	xor	edx, DWORD PTR _crc$43[ebp+8]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 316  : 		if (signature.deviceIDCrc != crc.crcCompute((BYTE_CPTR)deviceSerial.c_str(), deviceSerial.size()))

	cmp	DWORD PTR _signature$[ebp+16], edx
	je	SHORT $LN10@Verify

; 317  : 			return EncryptErrorCode::ENCRYPT_DEVICENOTMATCH;

	mov	esi, 6
	jmp	SHORT $LN24@Verify
$LN10@Verify:

; 319  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	xor	esi, esi
$LN24@Verify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR _ifs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _encryptFileName$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN698@Verify
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _encryptFileName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN708@Verify

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN759@Verify
$LN708@Verify:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN698@Verify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _password$[ebp+20]

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR _encryptFileName$[ebp+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR _encryptFileName$[ebp+20], 15	; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR _encryptFileName$[ebp], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN725@Verify
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _password$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN735@Verify

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN759@Verify
$LN735@Verify:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN725@Verify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _deviceSerial$[ebp+20]

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR _password$[ebp+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR _password$[ebp+20], 15	; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR _password$[ebp], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN752@Verify
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _deviceSerial$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN762@Verify

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN762@Verify
$LN759@Verify:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN762@Verify:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN752@Verify:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 319  : 	return EncryptErrorCode::ENCRYPT_SUCCESS;

	mov	eax, esi

; 320  : 
; 321  : #undef callBackSetProcessBarRange
; 322  : #undef callBackSetProcessBarPos
; 323  : #undef callBackStatusUpdate
; 324  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN778@Verify:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$0:
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$1:
	lea	ecx, DWORD PTR _password$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$2:
	lea	ecx, DWORD PTR _encryptFileName$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z$3:
	lea	ecx, DWORD PTR _ifs$[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1600]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z ENDP ; thatboy::EncryptFileDoModal::Verify
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp
;	COMDAT ?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
_TEXT	SEGMENT
_ifs$ = -536						; size = 184
___$ReturnUdt$GSCopy$ = -348				; size = 4
___$ReturnUdt$ = -348					; size = 4
_signature$ = -344					; size = 320
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_encryptFileName$ = 8					; size = 24
?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z PROC ; thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename, COMDAT
; ___$ReturnUdt$ = ecx

; 327  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR _signature$[ebp+57]
	push	263					; 00000107H
	xorps	xmm0, xmm0
	mov	DWORD PTR _signature$[ebp], -12171948	; ff464554H
	push	0
	push	eax
	mov	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	mov	DWORD PTR _signature$[ebp+8], 0
	mov	DWORD PTR _signature$[ebp+12], 0
	mov	DWORD PTR _signature$[ebp+16], 0
	mov	DWORD PTR _signature$[ebp+20], 0
	movups	XMMWORD PTR _signature$[ebp+24], xmm0
	mov	BYTE PTR _signature$[ebp+56], 0
	movups	XMMWORD PTR _signature$[ebp+40], xmm0
	call	_memset

; 328  : 	using namespace std;
; 329  : 
; 330  : 	SignatureDomain signature;
; 331  : 	/**********************  **************************/
; 332  : 	ifstream ifs(encryptFileName, ios::binary);

	add	esp, 8
	lea	eax, DWORD PTR _encryptFileName$[ebx]
	push	64					; 00000040H
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR _ifs$[ebp+92], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncrypt.cpp

; 333  : 	if (!ifs.is_open())

	jne	$LN5@getEncrypt
$LN224@getEncrypt:

; 344  : 
; 345  : 	return (LPCSTR)signature.oriFileName;

	mov	DWORD PTR [esi+16], 0
	mov	ecx, esi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	BYTE PTR [esi], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	edx, DWORD PTR _encryptFileName$[ebx+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN197@getEncrypt
	mov	ecx, DWORD PTR _encryptFileName$[ebx]
	inc	edx
	mov	eax, ecx
	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN207@getEncrypt
	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx
	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN204@getEncrypt
$LN207@getEncrypt:
	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN197@getEncrypt:
	mov	eax, esi

; 346  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN5@getEncrypt:

; 334  : 		return "";
; 335  : 	ifs.read((LPSTR)&signature, sizeof(signature));

	push	0
	push	320					; 00000140H
	lea	eax, DWORD PTR _signature$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ifs$[ebp]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 336  : 	ifs.close();

	lea	ecx, DWORD PTR _ifs$[ebp]
	call	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close

; 337  : 	if (signature.magicNumber != makeDWORD('T', 'E', 'F', 255))

	mov	edx, DWORD PTR _signature$[ebp]
	cmp	edx, -12171948				; ff464554H
	jne	$LN224@getEncrypt

; 338  : 		return "";
; 339  : 	if (signature.version != makeDWORD(0, 0, 0, 1))

	cmp	DWORD PTR _signature$[ebp+4], 16777216	; 01000000H
	jne	$LN224@getEncrypt

; 340  : 		return "";
; 341  : 	// 
; 342  : 	for (size_t i = 0; i < sizeof(signature.oriFileName) / 4; i++)

	xor	ecx, ecx
	npad	11
$LL214@getEncrypt:

; 343  : 		((DWORD_PTR)signature.oriFileName)[i] ^= signature.magicNumber ^ XORCode ^ signature.RXORCode;

	mov	eax, DWORD PTR _signature$[ebp+ecx*4+60]
	xor	eax, DWORD PTR _signature$[ebp+20]
	xor	eax, edx
	xor	eax, 11184810				; 00aaaaaaH
	mov	DWORD PTR _signature$[ebp+ecx*4+60], eax
	inc	ecx
	cmp	ecx, 65					; 00000041H
	jae	SHORT $LN221@getEncrypt

; 340  : 		return "";
; 341  : 	// 
; 342  : 	for (size_t i = 0; i < sizeof(signature.oriFileName) / 4; i++)

	mov	edx, DWORD PTR _signature$[ebp]
	jmp	SHORT $LL214@getEncrypt
$LN221@getEncrypt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	lea	eax, DWORD PTR _signature$[ebp+60]

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2337 :         assign(_Ptr);

	mov	ecx, esi
	push	eax

; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	mov	eax, DWORD PTR _ifs$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ifs$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _ifs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR _ifs$[ebp+ecx-4], eax
	lea	ecx, DWORD PTR _ifs$[ebp+16]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _ifs$[ebp+24]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _ifs$[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _encryptFileName$[ebx+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	$LN197@getEncrypt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _encryptFileName$[ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	$LN207@getEncrypt

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	$LN207@getEncrypt
$LN204@getEncrypt:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN223@getEncrypt:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z$0:
	mov	ebx, DWORD PTR [ebp-16]
	lea	ecx, DWORD PTR _encryptFileName$[ebx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z$1:
	lea	ecx, DWORD PTR _ifs$[ebp]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-536]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ENDP ; thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 1172 :     void close() {

	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR [ebx+80], 0
	je	SHORT $LN5@close

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

	lea	ecx, DWORD PTR [ebx+4]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR [ebx+80]
	xor	ecx, ecx
	lea	edi, DWORD PTR [ebx+4]
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@close
$LN5@close:

; 702  :         _Closef    = _Which == _Openfl;

	xor	edi, edi
$LN6@close:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	lea	ecx, DWORD PTR [ebx+4]
	mov	BYTE PTR [ebx+76], 0
	mov	BYTE PTR [ebx+65], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [ebx+68], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [ebx+80], 0
	mov	DWORD PTR [ebx+72], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [ebx+60], 0

; 1173 :         if (!_Filebuffer.close()) {

	test	edi, edi
	jne	SHORT $LN2@close

; 1174 :             _Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2@close:

; 1175 :         }
; 1176 :     }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR [ecx+80], 0
	setne	al

; 1148 :         return _Filebuffer.is_open();
; 1149 :     }

	ret	0
?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-104]
	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-104]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Str$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1012 :     explicit basic_ofstream(

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	ebx, DWORD PTR __Str$[ebp]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@basic_ofst

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN7@basic_ofst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 1006 :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

	lea	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR [ecx+edi-4], eax

; 162  :     basic_filebuf() : _Mysb() {

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 1007 :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot)) {

	push	16					; 00000010H
	push	34					; 00000022H
	push	ebx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $LN13@basic_ofst

; 1008 :             _Myios::setstate(ios_base::failbit);

	push	eax
	mov	eax, DWORD PTR [edi]
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN13@basic_ofst:

; 1013 :         const string& _Str, ios_base::openmode _Mode = ios_base::out, int _Prot = ios_base::_Default_open_prot)
; 1014 :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR [ecx+edi-4], eax
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$1:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN16@basic_ofst
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN16@basic_ofst:
	ret	0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 692  :     virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 693  :         // set locale to argument (capture nontrivial codecvt facet)
; 694  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	ecx, DWORD PTR __Loc$[ebp]
	push	edi
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	edi, eax

; 761  :         if (_Newcvt.always_noconv()) {

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN4@imbue
	pop	edi

; 762  :             _Pcvt = nullptr; // nothing to do

	mov	DWORD PTR [esi+56], 0

; 695  :     }

	pop	esi
	pop	ebp
	ret	4
$LN4@imbue:

; 765  :             _Mysb::_Init(); // reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
	pop	edi

; 695  :     }

	pop	esi
	pop	ebp
	ret	4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 684  :     virtual int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

	push	esi
	mov	esi, ecx

; 685  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN3@sync
	mov	eax, DWORD PTR [esi]
	push	-1
	call	DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 685  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

	je	SHORT $LN3@sync
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fflush
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN3@sync

; 687  :         }
; 688  : 
; 689  :         return -1;

	or	eax, -1
	pop	esi

; 690  :     }

	ret	0
$LN3@sync:

; 686  :             return 0;

	xor	eax, eax
	pop	esi

; 690  :     }

	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Nr$1 = -4						; size = 4
__Pb$2 = 8						; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
__Pn$3 = 16						; size = 4
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 665  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

	push	ebp
	mov	ebp, esp
	push	ecx

; 666  :         int _Mode;
; 667  :         if (!_Buffer && _Count == 0) {

	mov	edx, DWORD PTR __Buffer$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Count$[ebp]
	push	edi
	test	edx, edx
	jne	SHORT $LN2@setbuf
	mov	eax, ecx
	or	eax, DWORD PTR __Count$[ebp+4]
	jne	SHORT $LN2@setbuf

; 668  :             _Mode = _IONBF;

	mov	eax, 4

; 669  :         } else {

	jmp	SHORT $LN3@setbuf
$LN2@setbuf:

; 670  :             _Mode = _IOFBF;

	xor	eax, eax
$LN3@setbuf:

; 671  :         }
; 672  : 
; 673  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);
; 674  : 
; 675  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

	mov	edi, DWORD PTR [esi+76]
	test	edi, edi
	je	$LN5@setbuf
	push	ecx
	push	eax
	push	edx
	push	edi
	call	DWORD PTR __imp__setvbuf
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN5@setbuf

; 677  :         }
; 678  : 
; 679  :         // new buffer, reinitialize pointers
; 680  :         _Init(_Myfile, _Openfl);

	mov	edi, DWORD PTR [esi+76]

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 1
	mov	BYTE PTR [esi+61], al
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	test	edi, edi
	je	SHORT $LN8@setbuf

; 712  :             ::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR __Pb$2[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$3[ebp]
	mov	DWORD PTR __Pn$3[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$2[ebp]
	mov	DWORD PTR __Nr$1[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	DWORD PTR [esi+12], eax

; 277  :         _IPfirst = _Pf;

	mov	DWORD PTR [esi+16], eax

; 278  :         _IGnext  = _Gn;

	mov	eax, DWORD PTR __Pn$3[ebp]
	mov	DWORD PTR [esi+28], eax

; 279  :         _IPnext  = _Pn;

	mov	DWORD PTR [esi+32], eax

; 280  :         _IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR [esi+44], eax

; 281  :         _IPcount = _Pc;

	mov	DWORD PTR [esi+48], eax
$LN8@setbuf:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+68], eax

; 681  :         return this;

	mov	eax, esi
	pop	edi

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 682  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@setbuf:
	pop	edi

; 676  :             return nullptr; // failed

	xor	eax, eax

; 682  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 652  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 70   :         return _Myoff + _Fpos;

	mov	edx, DWORD PTR __Pos$[ebp]
	add	edx, DWORD PTR __Pos$[ebp+8]
	mov	eax, DWORD PTR __Pos$[ebp+4]
	adc	eax, DWORD PTR __Pos$[ebp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 652  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

	push	esi
	mov	esi, ecx

; 653  :         // change position to _Pos
; 654  :         off_type _Off = static_cast<off_type>(_Pos);

	mov	DWORD PTR __Off$[esp+12], edx
	push	edi
	mov	DWORD PTR __Off$[esp+20], eax

; 655  : 
; 656  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN3@seekpos
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN3@seekpos
	lea	eax, DWORD PTR __Off$[esp+16]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fsetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@seekpos

; 660  :         _State = _Pos.state();

	mov	eax, DWORD PTR __Pos$[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 660  :         _State = _Pos.state();

	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR __Pos$[ebp+20]
	mov	DWORD PTR [esi+68], eax

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN12@seekpos

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN12@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 662  :         return pos_type(_State, _Off); // return new position

	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	ecx, DWORD PTR __Off$[esp+16]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Off$[esp+20]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 663  :     }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN3@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 663  :     }

	pop	edi
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 663  :     }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 632  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 187  :         return *_IGnext;

	mov	eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 637  :             && !_Pcvt) { // not converting

	lea	ecx, DWORD PTR [esi+60]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR __Way$[ebp], 1
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN21@seekoff

; 638  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

	mov	edi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LN2@seekoff
$LN21@seekoff:

; 637  :             && !_Pcvt) { // not converting

	mov	ebx, DWORD PTR __Off$[ebp+4]
	mov	edi, DWORD PTR __Off$[ebp]
$LN2@seekoff:

; 639  :         }
; 640  : 
; 641  :         if (!_Myfile || !_Endwrite()
; 642  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 643  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

	cmp	DWORD PTR [esi+76], 0
	je	$LN4@seekoff
	mov	ecx, esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	$LN4@seekoff
	mov	eax, edi
	or	eax, ebx
	mov	eax, DWORD PTR __Way$[ebp]
	jne	SHORT $LN6@seekoff
	cmp	eax, 1
	je	SHORT $LN5@seekoff
$LN6@seekoff:
	push	eax
	push	ebx
	push	edi
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp___fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@seekoff
$LN5@seekoff:
	lea	eax, DWORD PTR __Fileposition$[esp+24]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@seekoff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	ecx, DWORD PTR [esi+60]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN13@seekoff

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN13@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 648  :         return pos_type(_State, _Fileposition); // return new position

	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	ecx, DWORD PTR __Fileposition$[esp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Fileposition$[esp+28]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 649  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN4@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 649  :     }

	pop	edi
	pop	esi
	pop	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 649  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Off$1$ = -20						; size = 4
__Size$2$ = -16						; size = 4
tv253 = -12						; size = 4
__Start_count$1$ = -8					; size = 4
__Start_count$2$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 598  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 599  :         // put _Count characters to stream
; 600  :         if
; 601  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 602  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN2@xsputn

; 603  :                     return _Mysb::xsputn(_Ptr, _Count);

	push	DWORD PTR __Count$[ebp+4]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	DWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z

; 624  :             }
; 625  :         else { // non-chars always get element-by-element processing
; 626  :             return _Mysb::xsputn(_Ptr, _Count);
; 627  :         }
; 628  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

	mov	eax, DWORD PTR [ebx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 606  :                 const streamsize _Start_count = _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	mov	edi, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR __Start_count$1$[esp+32], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

	mov	eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 606  :                 const streamsize _Start_count = _Count;

	mov	DWORD PTR __Start_count$2$[esp+32], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

	mov	DWORD PTR tv253[esp+32], eax
	test	eax, eax
	je	SHORT $LN9@xsputn
	mov	eax, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@xsputn
$LN9@xsputn:
	xor	eax, eax
$LN10@xsputn:
	cdq
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 607  :                 streamsize _Size              = _Mysb::_Pnavail();

	mov	DWORD PTR __Off$1$[esp+32], eax
	mov	ecx, edx
	mov	DWORD PTR __Size$2$[esp+32], ecx

; 608  :                 if (0 < _Count && 0 < _Size) { // copy to write buffer

	test	edi, edi
	jl	SHORT $LN5@xsputn
	jg	SHORT $LN17@xsputn
	test	esi, esi
	je	SHORT $LN5@xsputn
$LN17@xsputn:
	test	ecx, ecx
	jl	SHORT $LN21@xsputn
	jg	SHORT $LN18@xsputn
	test	eax, eax
	je	SHORT $LN21@xsputn
$LN18@xsputn:

; 609  :                     if (_Count < _Size) {

	cmp	edi, ecx
	jg	SHORT $LN4@xsputn
	jl	SHORT $LN19@xsputn
	cmp	esi, eax
	jae	SHORT $LN4@xsputn
$LN19@xsputn:

; 610  :                         _Size = _Count;

	mov	eax, esi
	mov	DWORD PTR __Off$1$[esp+32], esi
	mov	DWORD PTR __Size$2$[esp+32], edi
$LN4@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR __Ptr$[ebp]
	push	DWORD PTR tv253[esp+40]
	call	_memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 614  :                     _Ptr += _Size;

	mov	ecx, DWORD PTR __Off$1$[esp+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 614  :                     _Ptr += _Size;

	mov	edx, DWORD PTR __Ptr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 237  :         *_IPcount -= _Off;

	mov	eax, DWORD PTR [ebx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 614  :                     _Ptr += _Size;

	add	edx, ecx

; 615  :                     _Count -= _Size;

	sub	esi, ecx
	sbb	edi, DWORD PTR __Size$2$[esp+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 237  :         *_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 238  :         *_IPnext += _Off;

	mov	eax, DWORD PTR [ebx+32]
	add	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 608  :                 if (0 < _Count && 0 < _Size) { // copy to write buffer

	jmp	SHORT $LN3@xsputn
$LN21@xsputn:
	mov	edx, DWORD PTR __Ptr$[ebp]
$LN3@xsputn:

; 616  :                     _Mysb::pbump(static_cast<int>(_Size));
; 617  :                 }
; 618  : 
; 619  :                 if (0 < _Count && _Myfile) { // open C stream, attempt write

	test	edi, edi
	jl	SHORT $LN5@xsputn
	jg	SHORT $LN20@xsputn
	test	esi, esi
	je	SHORT $LN5@xsputn
$LN20@xsputn:
	mov	eax, DWORD PTR [ebx+76]
	test	eax, eax
	je	SHORT $LN5@xsputn

; 620  :                     _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

	push	eax
	push	esi
	push	1
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	sub	esi, eax
	sbb	edi, 0
$LN5@xsputn:

; 621  :                 }
; 622  : 
; 623  :                 return _Start_count - _Count;

	mov	eax, DWORD PTR __Start_count$1$[esp+32]
	mov	edx, DWORD PTR __Start_count$2$[esp+32]
	sub	eax, esi
	sbb	edx, edi

; 624  :             }
; 625  :         else { // non-chars always get element-by-element processing
; 626  :             return _Mysb::xsputn(_Ptr, _Count);
; 627  :         }
; 628  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
tv409 = -8						; size = 4
$T5 = -4						; size = 4
$T6 = -4						; size = 4
__Ptr$1$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 548  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

	push	ebp
	mov	ebp, esp

; 549  :         // get _Count characters from stream
; 550  :         if
; 551  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 552  :                 if (_Count <= 0) {

	mov	eax, DWORD PTR __Count$[ebp+4]
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
	test	eax, eax
	jg	SHORT $LN4@xsgetn
	jl	SHORT $LN34@xsgetn
	test	esi, esi
	jne	SHORT $LN4@xsgetn
$LN34@xsgetn:
	pop	esi

; 553  :                     return 0;

	xor	eax, eax
	xor	edx, edx

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN4@xsgetn:

; 554  :                 }
; 555  : 
; 556  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN5@xsgetn

; 557  :                     return _Mysb::xsgetn(_Ptr, _Count);

	push	eax
	push	esi
	push	DWORD PTR __Ptr$[ebp]
	call	DWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	pop	esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 233  :         return *_IGnext ? *_IGcount : 0;

	mov	eax, DWORD PTR [ebx+28]
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 561  :                 auto _Count_s           = static_cast<size_t>(_Count);

	mov	edi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 233  :         return *_IGnext ? *_IGcount : 0;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@xsgetn
	mov	eax, DWORD PTR [ebx+44]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@xsgetn
$LN13@xsgetn:
	xor	eax, eax
$LN14@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 564  :                 if (0 < _Available) { // copy from get area

	mov	DWORD PTR $T5[ebp], esi
	test	eax, eax
	je	SHORT $LN35@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	eax, edi
	cmovb	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	push	DWORD PTR __Ptr$[ebp]
	call	_memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 203  :         *_IGcount -= _Off;

	mov	eax, DWORD PTR [ebx+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 567  :                     _Ptr += _Read_size;

	sub	edi, esi
	add	DWORD PTR __Ptr$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 204  :         *_IGnext += _Off;

	mov	DWORD PTR $T5[ebp], edi
	sub	DWORD PTR [eax], esi
	mov	eax, DWORD PTR [ebx+28]
	add	DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 564  :                 if (0 < _Available) { // copy from get area

	mov	esi, DWORD PTR __Count$[ebp]
	jmp	SHORT $LN6@xsgetn
$LN35@xsgetn:
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN6@xsgetn:

; 568  :                     _Count_s -= _Read_size;
; 569  :                     _Mysb::gbump(static_cast<int>(_Read_size));
; 570  :                 }
; 571  : 
; 572  :                 if (_Myfile) { // open C stream, attempt read

	cmp	DWORD PTR [ebx+76], 0
	je	$LN37@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [ebx+60]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN24@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR [ebx+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [eax], edx
$LN24@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 577  :                     while (_Read_size < _Count_s) {

	mov	eax, DWORD PTR $T5[ebp]
	mov	edx, eax
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	cmp	eax, 4095				; 00000fffH
	mov	eax, DWORD PTR __imp__fread
	mov	DWORD PTR $T6[ebp], edx
	jbe	SHORT $LN3@xsgetn
	npad	1
$LL2@xsgetn:

; 578  :                         const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

	push	DWORD PTR [ebx+76]
	push	4095					; 00000fffH
	push	1
	push	ecx
	call	eax

; 579  :                         _Ptr += _Actual_read;

	mov	ecx, DWORD PTR __Ptr$1$[ebp]

; 580  :                         _Count_s -= _Actual_read;

	sub	edi, eax
	add	ecx, eax
	mov	DWORD PTR $T6[ebp], edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	edx, edi

; 581  :                         if (_Actual_read != _Read_size) {

	cmp	eax, 4095				; 00000fffH
	jne	SHORT $LN31@xsgetn

; 577  :                     while (_Read_size < _Count_s) {

	cmp	edi, eax
	mov	eax, DWORD PTR __imp__fread
	ja	SHORT $LL2@xsgetn
$LN3@xsgetn:

; 582  :                             return static_cast<streamsize>(_Start_count - _Count_s);
; 583  :                         }
; 584  :                     }
; 585  : 
; 586  :                     if (0 < _Count_s) {

	cmp	DWORD PTR $T6[ebp], 0
	jbe	SHORT $LN9@xsgetn

; 587  :                         _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

	push	DWORD PTR [ebx+76]
	push	edi
	push	1
	push	ecx
	call	eax
	mov	edx, DWORD PTR $T6[ebp]
	add	esp, 16					; 00000010H
	sub	edx, eax

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

	sub	esi, edx
	mov	edx, DWORD PTR __Count$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	sbb	edx, 0

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN31@xsgetn:

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

	mov	edx, DWORD PTR __Count$[ebp+4]
	sub	esi, edi
	pop	edi
	mov	eax, esi
	sbb	edx, 0
	pop	esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN37@xsgetn:

; 568  :                     _Count_s -= _Read_size;
; 569  :                     _Mysb::gbump(static_cast<int>(_Read_size));
; 570  :                 }
; 571  : 
; 572  :                 if (_Myfile) { // open C stream, attempt read

	mov	edx, DWORD PTR $T5[ebp]
$LN9@xsgetn:

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

	sub	esi, edx
	mov	edx, DWORD PTR __Count$[ebp+4]
	pop	edi
	mov	eax, esi
	sbb	edx, 0
	pop	esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Dest$27 = -52						; size = 4
__Src$28 = -48						; size = 4
__Ch$29 = -41						; size = 1
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 490  :     virtual int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 187  :         return *_IGnext;

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	test	ecx, ecx
	je	SHORT $LN255@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

	mov	edx, DWORD PTR [ebx+44]
	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [esi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	ecx, eax
	jae	SHORT $LN255@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 223  :         --*_IGcount;

	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR [edx], eax

; 224  :         return (*_IGnext)++;

	mov	ecx, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 492  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

	jmp	$LN220@uflow
$LN255@uflow:

; 493  :         }
; 494  : 
; 495  :         if (!_Myfile) {

	cmp	DWORD PTR [ebx+76], 0
	jne	SHORT $LN10@uflow
$LN18@uflow:

; 542  :             }
; 543  :         }
; 544  :     }

	or	eax, -1
	jmp	$LN220@uflow
$LN10@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [ebx+60]
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN35@uflow

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR [ebx+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [eax], edx
$LN35@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 500  :         if (!_Pcvt) { // no codecvt facet, just get it

	cmp	DWORD PTR [ebx+56], 0
	mov	eax, DWORD PTR [ebx+76]
	jne	SHORT $LN11@uflow

; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	push	eax
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN18@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al

; 394  :     }

	jmp	$LN220@uflow
$LN11@uflow:

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR __Str$[ebp+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Str$[ebp+20], 15		; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR __Str$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp__fgetc
	add	esp, 4

; 511  : 
; 512  :             if (_Meta == EOF) {

	cmp	eax, -1
	je	$LN244@uflow
	lea	edi, DWORD PTR [ebx+64]
$LL2@uflow:

; 513  :                 return _Traits::eof(); // partial char?
; 514  :             }
; 515  : 
; 516  :             _Str.push_back(static_cast<char>(_Meta)); // append byte and convert

	push	eax
	lea	ecx, DWORD PTR __Str$[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	lea	eax, DWORD PTR __Dest$27[ebp]
	mov	ecx, DWORD PTR [ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Str$[ebp]

; 2153 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR __Str$[ebp]

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]

; 2153 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	push	eax
	lea	eax, DWORD PTR __Ch$29[ebp+1]
	push	eax
	lea	eax, DWORD PTR __Ch$29[ebp]
	push	eax
	lea	eax, DWORD PTR __Src$28[ebp]
	push	eax
	mov	eax, DWORD PTR __Str$[ebp+16]
	add	eax, esi
	push	eax
	push	edx
	push	edi
	call	DWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	test	eax, eax
	js	SHORT $LN244@uflow
	cmp	eax, 1
	jg	$LN245@uflow

; 521  :                 _Dest)) { // test result of converting one element
; 522  :             case codecvt_base::partial:
; 523  :             case codecvt_base::ok:
; 524  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

	lea	eax, DWORD PTR __Ch$29[ebp]
	cmp	DWORD PTR __Dest$27[ebp], eax
	lea	eax, DWORD PTR __Str$[ebp]
	jne	SHORT $LN246@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

	mov	edi, DWORD PTR __Src$28[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

	sub	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Str$[ebp+16]
	cmp	eax, edi
	cmovb	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR __Str$[ebp]

; 3128 :         const size_type _New_size = _Old_size - _Count;

	sub	eax, edi

; 3129 :         _Mypair._Myval2._Mysize   = _New_size;

	mov	DWORD PTR __Str$[ebp+16], eax

; 3130 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	inc	eax

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax

; 3130 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	eax, DWORD PTR [edx+edi]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	edx
	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

	push	DWORD PTR [ebx+76]
	call	DWORD PTR __imp__fgetc
	add	esp, 16					; 00000010H

; 511  : 
; 512  :             if (_Meta == EOF) {

	lea	edi, DWORD PTR [ebx+64]
	cmp	eax, -1
	jne	$LL2@uflow
$LN244@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	or	esi, -1
$LN23@uflow:
	mov	edx, DWORD PTR __Str$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	$LN200@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN210@uflow

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN210@uflow
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN246@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	esi, DWORD PTR __Str$[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	ecx, DWORD PTR __Src$28[ebp]
	sub	esi, ecx
	add	esi, eax

; 526  :                     while (0 < _Nleft) {

	test	esi, esi
	jle	SHORT $LN258@uflow
	mov	edi, DWORD PTR __imp__ungetc
$LL248@uflow:

; 527  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

	push	DWORD PTR [ebx+76]
	movsx	eax, BYTE PTR [esi+ecx-1]
	dec	esi
	push	eax
	call	edi
	add	esp, 8
	test	esi, esi
	jle	SHORT $LN258@uflow

; 526  :                     while (0 < _Nleft) {

	mov	ecx, DWORD PTR __Src$28[ebp]
	jmp	SHORT $LL248@uflow
$LN258@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	esi, BYTE PTR __Ch$29[ebp]
	jmp	SHORT $LN23@uflow
$LN245@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	cmp	eax, 3
	jne	SHORT $LN244@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$[ebp]

; 2144 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 538  :                 return static_cast<int_type>(_Str.front());

	movsx	esi, BYTE PTR [eax]
	jmp	SHORT $LN23@uflow
$LN210@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN200@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 541  :                 return _Traits::eof(); // conversion failed

	mov	eax, esi
$LN220@uflow:

; 542  :             }
; 543  :         }
; 544  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN261@uflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 187  :         return *_IGnext;

	mov	eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	ecx, eax
	jae	SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [ecx]
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 488  :     }

	ret	0
$LN2@underflow:

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+28]
	mov	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	edi, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

	jne	SHORT $LN4@underflow

; 483  :             return _Meta; // uflow failed, return EOF

	pop	edi
	or	eax, eax
	pop	esi

; 488  :     }

	ret	0
$LN4@underflow:

; 484  :         } else { // get a char, don't point past it
; 485  :             pbackfail(_Meta);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+16]

; 486  :             return _Meta;

	mov	eax, edi
	pop	edi
	pop	esi

; 488  :     }

	ret	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

	push	ebp
	mov	ebp, esp
	push	ebx

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	ebx, DWORD PTR __Meta$[ebp]
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 187  :         return *_IGnext;

	mov	eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	DWORD PTR [eax], ecx
	jae	SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	ebx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [ecx-1]

; 397  :         return _Left == _Right;

	cmp	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	jne	SHORT $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 218  :         ++*_IGcount;

	mov	eax, DWORD PTR [esi+44]
	inc	DWORD PTR [eax]

; 219  :         return --*_IGnext;

	mov	eax, DWORD PTR [esi+28]
	dec	DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 464  :             return _Traits::not_eof(_Meta);

	xor	eax, eax
	cmp	ebx, -1
	cmove	ebx, eax
$LN54@pbackfail:

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN2@pbackfail:

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	ebx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

	je	SHORT $LN7@pbackfail

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN52@pbackfail

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

	push	eax
	movzx	ecx, bl
	push	ecx
	call	DWORD PTR __imp__ungetc
	add	esp, 8
	cmp	eax, -1

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	jne	SHORT $LN54@pbackfail
$LN52@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 187  :         return *_IGnext;

	mov	edx, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

	lea	ecx, DWORD PTR [esi+60]
	cmp	DWORD PTR [edx], ecx
	je	SHORT $LN7@pbackfail

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [ecx], bl

; 784  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN53@pbackfail

; 785  :             _Set_eback = _Mysb::eback();

	mov	DWORD PTR [esi+80], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 786  :             _Set_egptr = _Mysb::egptr();

	mov	DWORD PTR [esi+84], eax
$LN53@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	DWORD PTR [edi], ecx

; 209  :         *_IGnext  = _Next;

	mov	eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 472  :             return _Meta;

	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 209  :         *_IGnext  = _Next;

	mov	DWORD PTR [eax], ecx

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	pop	esi
	mov	DWORD PTR [eax], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 472  :             return _Meta;

	mov	eax, ebx

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

	pop	ebx
	pop	ebp
	ret	4
$LN7@pbackfail:
	pop	esi

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail

	or	eax, -1

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

	pop	ebx
	pop	ebp
	ret	4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$ = -48						; size = 4
__Dest$ = -44						; size = 4
__Ch$ = -37						; size = 1
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	mov	ebx, DWORD PTR __Meta$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	ebx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 407  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	jne	SHORT $LN4@overflow

; 408  :             return _Traits::not_eof(_Meta); // EOF, return success code

	pop	esi
	xor	eax, eax

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 195  :         return *_IPnext;

	mov	eax, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN5@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

	mov	edx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [edx]
	add	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	cmp	eax, edx
	jae	SHORT $LN5@overflow

; 412  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	call	DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
	pop	esi
	mov	BYTE PTR [eax], bl

; 413  :             return _Meta;

	mov	eax, ebx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@overflow:

; 414  :         }
; 415  : 
; 416  :         if (!_Myfile) {

	cmp	DWORD PTR [esi+76], 0
	push	edi
	je	$LN12@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN33@overflow

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN33@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 421  :         if (!_Pcvt) { // no codecvt facet, put as is

	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	jne	SHORT $LN7@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	eax, bl

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

	jmp	SHORT $LN45@overflow
$LN7@overflow:

; 423  :         }
; 424  : 
; 425  :         // put using codecvt facet
; 426  :         constexpr size_t _Codecvt_temp_buf = 32;
; 427  :         char _Str[_Codecvt_temp_buf];
; 428  :         const _Elem _Ch = _Traits::to_char_type(_Meta);
; 429  :         const _Elem* _Src;
; 430  :         char* _Dest;
; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

	lea	eax, DWORD PTR __Dest$[ebp]
	mov	BYTE PTR __Ch$[ebp], bl
	push	eax
	lea	eax, DWORD PTR __Str$[ebp+32]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp]
	push	eax
	lea	eax, DWORD PTR __Src$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp+1]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+64]
	push	eax
	call	DWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	test	eax, eax
	js	SHORT $LN12@overflow
	cmp	eax, 1
	jle	SHORT $LN8@overflow
	cmp	eax, 3
	jne	SHORT $LN12@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	eax, BYTE PTR __Ch$[ebp]
$LN45@overflow:
	push	DWORD PTR [esi+76]
	push	eax
	call	DWORD PTR __imp__fputc
	add	esp, 8

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

	or	ecx, -1

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

	cmp	eax, ecx

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

	cmovne	ecx, ebx
	pop	edi
	pop	esi
	mov	eax, ecx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@overflow:

; 432  :             _Dest)) { // test result of converting one element
; 433  :         case codecvt_base::partial:
; 434  :         case codecvt_base::ok: { // converted something, try to put it out
; 435  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	edi, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR __Str$[ebp]
	sub	edi, eax

; 436  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN9@overflow
	push	DWORD PTR [esi+76]
	push	edi
	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LN12@overflow
$LN9@overflow:

; 437  :                 return _Traits::eof(); // write failed
; 438  :             }
; 439  : 
; 440  :             _Wrotesome = true; // write succeeded
; 441  :             if (_Src != &_Ch) {

	lea	eax, DWORD PTR __Ch$[ebp]
	mov	BYTE PTR [esi+61], 1
	cmp	DWORD PTR __Src$[ebp], eax
	je	SHORT $LN12@overflow

; 442  :                 return _Meta; // converted whole element

	pop	edi
	pop	esi
	mov	eax, ebx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@overflow:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	or	eax, -1
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 400  :         if (_Myfile) {

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Unlock

; 401  :             _CSTD _unlock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___unlock_file
	pop	ecx
$LN2@Unlock:

; 402  :         }
; 403  :     }

	ret	0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 394  :         if (_Myfile) {

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Lock

; 395  :             _CSTD _lock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___lock_file
	pop	ecx
$LN2@Lock:

; 396  :         }
; 397  :     }

	ret	0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 171  :         if (_Myfile) {

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	je	SHORT $LN6@basic_file
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN6@basic_file

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN6@basic_file:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 175  :         if (_Closef) {

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN3@basic_file

; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN13@basic_file

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

	mov	ecx, esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN13@basic_file:

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 0
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0
$LN3@basic_file:

; 176  :             close();
; 177  :         }
; 178  :     }

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 979  :     void close() {

	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR [ebx+92], 0
	je	SHORT $LN5@close

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

	lea	ecx, DWORD PTR [ebx+16]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR [ebx+92]
	xor	ecx, ecx
	lea	edi, DWORD PTR [ebx+16]
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@close
$LN5@close:

; 702  :         _Closef    = _Which == _Openfl;

	xor	edi, edi
$LN6@close:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	lea	ecx, DWORD PTR [ebx+16]
	mov	BYTE PTR [ebx+88], 0
	mov	BYTE PTR [ebx+77], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [ebx+80], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [ebx+92], 0
	mov	DWORD PTR [ebx+84], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [ebx+72], 0

; 980  :         if (!_Filebuffer.close()) {

	test	edi, edi
	jne	SHORT $LN2@close

; 981  :             _Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN2@close:

; 982  :         }
; 983  :     }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR [ecx+92], 0
	setne	al

; 955  :         return _Filebuffer.is_open();
; 956  :     }

	ret	0
?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-112]
	lea	ecx, DWORD PTR [esi-96]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-112]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-112]
	mov	DWORD PTR [edx+esi-116], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-88]
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Str$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$ = 16						; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 819  :     explicit basic_ifstream(

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	ebx, DWORD PTR __Str$[ebp]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@basic_ifst

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN7@basic_ifst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 812  :         : _Mybase(_STD addressof(_Filebuffer)) {

	lea	ecx, DWORD PTR [edi+112]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR [ecx+edi-4], eax

; 162  :     basic_filebuf() : _Mysb() {

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 814  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

	push	DWORD PTR __Prot$[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	33					; 00000021H
	push	ebx
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $LN13@basic_ifst

; 815  :             _Myios::setstate(ios_base::failbit);

	push	eax
	mov	eax, DWORD PTR [edi]
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN13@basic_ifst:

; 820  :         const string& _Str, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 821  :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR [ecx+edi-4], eax
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$1:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN16@basic_ifst
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN16@basic_ifst:
	ret	0
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??B?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QBE_NXZ PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::operator bool, COMDAT
; _this$dead$ = ecx

; 1205 :         return !this->_Empty();

	cmp	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
	setne	al

; 1206 :     }

	ret	0
??B?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QBE_NXZ ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ
_TEXT	SEGMENT
??0?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>, COMDAT
; _this$dead$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0

; 1120 :     function() noexcept {}

	mov	eax, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	ret	0
??0?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@XZ ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 972  :     ~_Func_class() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Func_class

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN4@Func_class:
	pop	esi

; 973  :         _Tidy();
; 974  :     }

	ret	0
??1?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 24
??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$dead$ = ecx

; 964  :     _Ret operator()(_Types... _Args) const {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 965  :         if (_Empty()) {

	jne	SHORT $LN2@operator

; 966  :             _Xbad_function_call();

	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
$LN2@operator:

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _<_Args_0>$[ebp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	bl, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN19@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN29@operator

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN29@operator
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN29@operator:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN19@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	al, bl

; 970  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN36@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	lea	ecx, DWORD PTR _<_Args_0>$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??B?$function@$$A6A_NH@Z@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$function@$$A6A_NH@Z@std@@QBE_NXZ PROC		; std::function<bool __cdecl(int)>::operator bool, COMDAT
; _this$dead$ = ecx

; 1205 :         return !this->_Empty();

	cmp	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
	setne	al

; 1206 :     }

	ret	0
??B?$function@$$A6A_NH@Z@std@@QBE_NXZ ENDP		; std::function<bool __cdecl(int)>::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$function@$$A6A_NH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??0?$function@$$A6A_NH@Z@std@@QAE@XZ PROC		; std::function<bool __cdecl(int)>::function<bool __cdecl(int)>, COMDAT
; _this$dead$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0

; 1120 :     function() noexcept {}

	mov	eax, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	ret	0
??0?$function@$$A6A_NH@Z@std@@QAE@XZ ENDP		; std::function<bool __cdecl(int)>::function<bool __cdecl(int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$_Func_class@_NH@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Func_class@_NH@std@@QAE@XZ PROC			; std::_Func_class<bool,int>::~_Func_class<bool,int>, COMDAT
; _this$ = ecx

; 972  :     ~_Func_class() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Func_class

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN4@Func_class:
	pop	esi

; 973  :         _Tidy();
; 974  :     }

	ret	0
??1?$_Func_class@_NH@std@@QAE@XZ ENDP			; std::_Func_class<bool,int>::~_Func_class<bool,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??R?$_Func_class@_NH@std@@QBE_NH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??R?$_Func_class@_NH@std@@QBE_NH@Z PROC			; std::_Func_class<bool,int>::operator(), COMDAT
; _this$dead$ = ecx

; 964  :     _Ret operator()(_Types... _Args) const {

	push	ebp
	mov	ebp, esp

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 965  :         if (_Empty()) {

	jne	SHORT $LN2@operator

; 966  :             _Xbad_function_call();

	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
$LN2@operator:

; 967  :         }
; 968  :         const auto _Impl = _Getimpl();
; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax

; 970  :     }

	pop	ebp
	ret	4
$LN6@operator:
??R?$_Func_class@_NH@std@@QBE_NH@Z ENDP			; std::_Func_class<bool,int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??B?$function@$$A6A_NHH@Z@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$function@$$A6A_NHH@Z@std@@QBE_NXZ PROC		; std::function<bool __cdecl(int,int)>::operator bool, COMDAT
; _this$dead$ = ecx

; 1205 :         return !this->_Empty();

	cmp	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
	setne	al

; 1206 :     }

	ret	0
??B?$function@$$A6A_NHH@Z@std@@QBE_NXZ ENDP		; std::function<bool __cdecl(int,int)>::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$function@$$A6A_NHH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??0?$function@$$A6A_NHH@Z@std@@QAE@XZ PROC		; std::function<bool __cdecl(int,int)>::function<bool __cdecl(int,int)>, COMDAT
; _this$dead$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0

; 1120 :     function() noexcept {}

	mov	eax, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	ret	0
??0?$function@$$A6A_NHH@Z@std@@QAE@XZ ENDP		; std::function<bool __cdecl(int,int)>::function<bool __cdecl(int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??1?$_Func_class@_NHH@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Func_class@_NHH@std@@QAE@XZ PROC			; std::_Func_class<bool,int,int>::~_Func_class<bool,int,int>, COMDAT
; _this$ = ecx

; 972  :     ~_Func_class() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Func_class

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN4@Func_class:
	pop	esi

; 973  :         _Tidy();
; 974  :     }

	ret	0
??1?$_Func_class@_NHH@std@@QAE@XZ ENDP			; std::_Func_class<bool,int,int>::~_Func_class<bool,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??R?$_Func_class@_NHH@std@@QBE_NHH@Z
_TEXT	SEGMENT
_<_Args_0>$ = -4					; size = 4
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
??R?$_Func_class@_NHH@std@@QBE_NHH@Z PROC		; std::_Func_class<bool,int,int>::operator(), COMDAT
; _this$dead$ = ecx

; 964  :     _Ret operator()(_Types... _Args) const {

	push	ebp
	mov	ebp, esp
	push	ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	mov	DWORD PTR _<_Args_0>$[ebp], 0
	test	ecx, ecx

; 965  :         if (_Empty()) {

	jne	SHORT $LN2@operator

; 966  :             _Xbad_function_call();

	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
$LN2@operator:

; 967  :         }
; 968  :         const auto _Impl = _Getimpl();
; 969  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	lea	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR [eax+8]
	call	eax

; 970  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@operator:
??R?$_Func_class@_NHH@std@@QBE_NHH@Z ENDP		; std::_Func_class<bool,int,int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 69   :         // basic_filebuf would set _Fpos.
; 70   :         return _Myoff + _Fpos;

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR [ecx+4]

; 71   :     }

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 1420 :     _NODISCARD iterator end() noexcept {

	push	ebp
	mov	ebp, esp

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1421 :         auto& _My_data = _Mypair._Myval2;
; 1422 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1423 :     }

	pop	ebp
	ret	4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 1410 :     _NODISCARD iterator begin() noexcept {

	push	ebp
	mov	ebp, esp

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1411 :         auto& _My_data = _Mypair._Myval2;
; 1412 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1413 :     }

	pop	ebp
	ret	4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 469  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

	push	ebp
	mov	ebp, esp
	push	esi

; 458  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[ebp]

; 469  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

	push	edi
	mov	edi, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0

; 458  :         if (_Count != 0) {

	test	esi, esi
	je	SHORT $LN52@vector

; 1663 :         if (_Newcapacity > max_size()) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	SHORT $LN76@vector
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN19@vector

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	SHORT $LN77@vector

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN28@vector

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@vector
$LN28@vector:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@vector:

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ebx, eax
$LN18@vector:

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [ebx+esi]
	mov	DWORD PTR [edi], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	0
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR [edi+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [ebx+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 461  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

	mov	DWORD PTR [edi+4], eax
	pop	ebx
$LN52@vector:

; 472  :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN76@vector:

; 1664 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN77@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN74@vector:
	int	3
??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 3400 :     _NODISCARD iterator end() noexcept {

	push	ebp
	mov	ebp, esp

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	eax, ecx

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@end

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ecx]
$LN4@end:

; 3401 :         return iterator(

	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax

; 1779 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 3402 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3403 :             _STD addressof(_Mypair._Myval2));
; 3404 :     }

	pop	ebp
	ret	4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 3392 :     _NODISCARD iterator begin() noexcept {

	push	ebp
	mov	ebp, esp

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jb	SHORT $LN12@begin

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN12@begin:

; 3393 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3394 :     }

	mov	DWORD PTR [eax], ecx
	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-104]
	push	edi
	lea	edi, DWORD PTR [esi-104]
	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	176					; 000000b0H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 948  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-112]
	push	edi
	lea	edi, DWORD PTR [esi-112]
	lea	ecx, DWORD PTR [esi-96]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-112]
	mov	DWORD PTR [edx+esi-116], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-88]
	call	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	184					; 000000b8H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 1779 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1004 :     explicit basic_ofstream(const char* _Filename, ios_base::openmode _Mode = ios_base::out,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T1[ebp], 0

; 1005 :         int _Prot = ios_base::_Default_open_prot)
; 1006 :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

	lea	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR [ecx+edi-4], eax

; 162  :     basic_filebuf() : _Mysb() {

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 1007 :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot)) {

	push	16					; 00000010H
	push	34					; 00000022H
	push	DWORD PTR __Filename$[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $LN23@basic_ofst

; 1008 :             _Myios::setstate(ios_base::failbit);

	push	eax
	mov	eax, DWORD PTR [edi]
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN23@basic_ofst:

; 1009 :         }
; 1010 :     }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN6@basic_ofst
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN6@basic_ofst:
	ret	0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 783  :     void _Set_back() { // set up putback area

	mov	edx, ecx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [edx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 784  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	lea	esi, DWORD PTR [edx+60]
	mov	eax, DWORD PTR [edi]
	cmp	eax, esi
	je	SHORT $LN13@Set_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

	mov	ecx, DWORD PTR [edx+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 785  :             _Set_eback = _Mysb::eback();

	mov	DWORD PTR [edx+80], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

	mov	eax, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 786  :             _Set_egptr = _Mysb::egptr();

	mov	DWORD PTR [edx+84], eax
$LN13@Set_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	DWORD PTR [edi], esi

; 209  :         *_IGnext  = _Next;

	mov	eax, DWORD PTR [edx+28]

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	pop	edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR [edx+44]
	pop	esi
	mov	DWORD PTR [eax], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 789  :     }

	ret	0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 777  :     void _Reset_back() { // restore buffer after putback

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 183  :         return *_IGfirst;

	mov	edi, DWORD PTR [ecx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

	lea	eax, DWORD PTR [ecx+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN2@Reset_back

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ecx+80]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	DWORD PTR [edi], edx

; 209  :         *_IGnext  = _Next;
; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	esi, edx
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax], esi
	pop	esi
$LN2@Reset_back:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 781  :     }

	ret	0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 760  :     void _Initcvt(const _Cvt& _Newcvt) { // initialize codecvt pointer

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 761  :         if (_Newcvt.always_noconv()) {

	mov	edi, DWORD PTR __Newcvt$[ebp]
	mov	esi, ecx
	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN2@Initcvt

; 762  :             _Pcvt = nullptr; // nothing to do

	pop	edi
	mov	DWORD PTR [esi+56], 0

; 766  :         }
; 767  :     }

	pop	esi
	pop	ebp
	ret	4
$LN2@Initcvt:

; 763  :         } else { // set up for nontrivial codecvt facet
; 764  :             _Pcvt = _STD addressof(_Newcvt);
; 765  :             _Mysb::_Init(); // reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
	pop	edi

; 766  :         }
; 767  :     }

	pop	esi
	pop	ebp
	ret	4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$ = -40						; size = 4
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 724  :     bool _Endwrite() { // put shift to initial conversion state, as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 725  :         if (!_Pcvt || !_Wrotesome) {

	cmp	DWORD PTR [esi+56], 0
	je	$LN5@Endwrite
	cmp	BYTE PTR [esi+61], 0
	je	$LN5@Endwrite

; 730  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

	mov	eax, DWORD PTR [esi]
	push	edi
	push	-1
	call	DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 397  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 730  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

	je	SHORT $LN15@Endwrite

; 731  :             return false;
; 732  :         }
; 733  : 
; 734  :         constexpr size_t _Codecvt_temp_buf = 32;
; 735  :         char _Str[_Codecvt_temp_buf];
; 736  :         char* _Dest;
; 737  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

	mov	ecx, DWORD PTR [esi+56]
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp+32]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+64]
	push	eax
	call	DWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
	sub	eax, 0
	je	SHORT $LN7@Endwrite
	sub	eax, 1
	je	SHORT $LN8@Endwrite
	sub	eax, 2
	jne	SHORT $LN15@Endwrite

; 749  :         }
; 750  : 
; 751  :         case codecvt_base::noconv:
; 752  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [esi+61], al

; 753  :             return true; // nothing else to do

	mov	al, 1
	pop	edi
	pop	esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Endwrite:

; 738  :         case codecvt_base::ok:
; 739  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [esi+61], 0
$LN8@Endwrite:

; 740  : 
; 741  :         case codecvt_base::partial: // fall through
; 742  :         { // put any generated bytes
; 743  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	edi, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR __Str$[ebp]
	sub	edi, eax

; 744  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN9@Endwrite
	push	DWORD PTR [esi+76]
	push	edi
	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LN15@Endwrite
$LN9@Endwrite:

; 746  :             }
; 747  : 
; 748  :             return !_Wrotesome;

	cmp	BYTE PTR [esi+61], 0
	pop	edi
	sete	al
	pop	esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@Endwrite:
	pop	edi

; 745  :                 return false; // write failed

	xor	al, al
	pop	esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Endwrite:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -4						; size = 4
__Pn$2 = 8						; size = 4
__File$ = 8						; size = 4
__Pb$3 = 12						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 697  :     void _Init(FILE* _File, _Initfl _Which) { // initialize to C stream _File after {new, open, close}

	push	ebp
	mov	ebp, esp
	push	ecx

; 698  :         using _State_type = typename _Traits::state_type;
; 699  : 
; 700  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 701  : 
; 702  :         _Closef    = _Which == _Openfl;

	cmp	DWORD PTR __Which$[ebp], 1
	push	esi
	mov	esi, ecx
	sete	al
	push	edi
	mov	BYTE PTR [esi+72], al

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	mov	edi, DWORD PTR __File$[ebp]
	test	edi, edi
	je	SHORT $LN2@Init

; 712  :             ::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR __Pb$3[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR __Pn$2[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$3[ebp]
	mov	DWORD PTR __Nr$1[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	DWORD PTR [esi+12], eax

; 277  :         _IPfirst = _Pf;

	mov	DWORD PTR [esi+16], eax

; 278  :         _IGnext  = _Gn;

	mov	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR [esi+28], eax

; 279  :         _IPnext  = _Pn;

	mov	DWORD PTR [esi+32], eax

; 280  :         _IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR [esi+44], eax

; 281  :         _IPcount = _Pc;

	mov	DWORD PTR [esi+48], eax
$LN2@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	pop	edi
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+56], 0
	pop	esi

; 722  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 374  :     basic_filebuf* close() {

	push	esi
	mov	esi, ecx
	push	edi

; 375  :         basic_filebuf* _Ans;
; 376  :         if (_Myfile) { // put any homing sequence and close file

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN2@close

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

	push	DWORD PTR [esi+76]
	xor	ecx, ecx
	mov	edi, esi
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@close
$LN2@close:

; 702  :         _Closef    = _Which == _Openfl;

	xor	edi, edi
$LN3@close:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 0
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 720  :         _State  = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

	mov	eax, edi

; 720  :         _State  = _Stinit;

	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

	pop	edi

; 719  :         _Myfile = _File;

	mov	DWORD PTR [esi+76], 0

; 720  :         _State  = _Stinit;

	mov	DWORD PTR [esi+68], ecx

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

	pop	esi

; 391  :     }

	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 272  :         return static_cast<bool>(_Myfile);

	cmp	DWORD PTR [ecx+76], 0
	setne	al

; 273  :     }

	ret	0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$ = 16						; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 810  :     explicit basic_ifstream(

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T1[ebp], 0

; 811  :         const char* _Filename, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 812  :         : _Mybase(_STD addressof(_Filebuffer)) {

	lea	ecx, DWORD PTR [edi+112]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR [ecx+edi-4], eax

; 162  :     basic_filebuf() : _Mysb() {

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 813  :         // _Prot is an extension
; 814  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

	push	DWORD PTR __Prot$[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	33					; 00000021H
	push	DWORD PTR __Filename$[ebp]
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $LN23@basic_ifst

; 815  :             _Myios::setstate(ios_base::failbit);

	push	eax
	mov	eax, DWORD PTR [edi]
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN23@basic_ifst:

; 816  :         }
; 817  :     }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN6@basic_ifst
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN6@basic_ifst:
	ret	0
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	DWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getimpl@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Getimpl, COMDAT
; _this$ = ecx

; 1092 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, DWORD PTR [ecx+36]

; 1093 :     }

	ret	0
?_Getimpl@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Getimpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Tidy@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXXZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tidy, COMDAT
; _this$ = ecx

; 1048 :     void _Tidy() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN2@Tidy

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN2@Tidy:

; 1052 :         }
; 1053 :     }

	pop	esi
	ret	0
?_Tidy@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXXZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Empty@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IBE_NXZ
_TEXT	SEGMENT
?_Empty@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IBE_NXZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Empty, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	cmp	DWORD PTR [ecx+36], 0
	sete	al

; 983  :     }

	ret	0
?_Empty@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IBE_NXZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR [ecx+36], 0

; 962  :     }

	mov	eax, ecx
	ret	0
??0?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@_NH@std@@ABEPAV?$_Func_base@_NH@2@XZ
_TEXT	SEGMENT
?_Getimpl@?$_Func_class@_NH@std@@ABEPAV?$_Func_base@_NH@2@XZ PROC ; std::_Func_class<bool,int>::_Getimpl, COMDAT
; _this$ = ecx

; 1092 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, DWORD PTR [ecx+36]

; 1093 :     }

	ret	0
?_Getimpl@?$_Func_class@_NH@std@@ABEPAV?$_Func_base@_NH@2@XZ ENDP ; std::_Func_class<bool,int>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Tidy@?$_Func_class@_NH@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Func_class@_NH@std@@IAEXXZ PROC		; std::_Func_class<bool,int>::_Tidy, COMDAT
; _this$ = ecx

; 1048 :     void _Tidy() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN2@Tidy

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN2@Tidy:

; 1052 :         }
; 1053 :     }

	pop	esi
	ret	0
?_Tidy@?$_Func_class@_NH@std@@IAEXXZ ENDP		; std::_Func_class<bool,int>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Empty@?$_Func_class@_NH@std@@IBE_NXZ
_TEXT	SEGMENT
?_Empty@?$_Func_class@_NH@std@@IBE_NXZ PROC		; std::_Func_class<bool,int>::_Empty, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	cmp	DWORD PTR [ecx+36], 0
	sete	al

; 983  :     }

	ret	0
?_Empty@?$_Func_class@_NH@std@@IBE_NXZ ENDP		; std::_Func_class<bool,int>::_Empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$_Func_class@_NH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_class@_NH@std@@QAE@XZ PROC			; std::_Func_class<bool,int>::_Func_class<bool,int>, COMDAT
; _this$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR [ecx+36], 0

; 962  :     }

	mov	eax, ecx
	ret	0
??0?$_Func_class@_NH@std@@QAE@XZ ENDP			; std::_Func_class<bool,int>::_Func_class<bool,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@_NHH@std@@ABEPAV?$_Func_base@_NHH@2@XZ
_TEXT	SEGMENT
?_Getimpl@?$_Func_class@_NHH@std@@ABEPAV?$_Func_base@_NHH@2@XZ PROC ; std::_Func_class<bool,int,int>::_Getimpl, COMDAT
; _this$ = ecx

; 1092 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, DWORD PTR [ecx+36]

; 1093 :     }

	ret	0
?_Getimpl@?$_Func_class@_NHH@std@@ABEPAV?$_Func_base@_NHH@2@XZ ENDP ; std::_Func_class<bool,int,int>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Tidy@?$_Func_class@_NHH@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Func_class@_NHH@std@@IAEXXZ PROC		; std::_Func_class<bool,int,int>::_Tidy, COMDAT
; _this$ = ecx

; 1048 :     void _Tidy() noexcept {

	push	esi
	mov	esi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN2@Tidy

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	DWORD PTR [esi+36], 0
$LN2@Tidy:

; 1052 :         }
; 1053 :     }

	pop	esi
	ret	0
?_Tidy@?$_Func_class@_NHH@std@@IAEXXZ ENDP		; std::_Func_class<bool,int,int>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Empty@?$_Func_class@_NHH@std@@IBE_NXZ
_TEXT	SEGMENT
?_Empty@?$_Func_class@_NHH@std@@IBE_NXZ PROC		; std::_Func_class<bool,int,int>::_Empty, COMDAT
; _this$ = ecx

; 982  :         return !_Getimpl();

	cmp	DWORD PTR [ecx+36], 0
	sete	al

; 983  :     }

	ret	0
?_Empty@?$_Func_class@_NHH@std@@IBE_NXZ ENDP		; std::_Func_class<bool,int,int>::_Empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??0?$_Func_class@_NHH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_class@_NHH@std@@QAE@XZ PROC			; std::_Func_class<bool,int,int>::_Func_class<bool,int,int>, COMDAT
; _this$ = ecx

; 961  :         _Set(nullptr);

	mov	DWORD PTR [ecx+36], 0

; 962  :     }

	mov	eax, ecx
	ret	0
??0?$_Func_class@_NHH@std@@QAE@XZ ENDP			; std::_Func_class<bool,int,int>::_Func_class<bool,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1779 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1780 :         this->_Adopt(_Pstring);
; 1781 :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 59   :     _NODISCARD _Statetype state() const {

	push	ebp
	mov	ebp, esp

; 60   :         return _Mystate;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 61   :     }

	pop	ebp
	ret	4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Fileposition$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Fileposition$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __State$[ebp+4]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	pop	ebp
	ret	16					; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ
_TEXT	SEGMENT
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@front

; 3543 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3544 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3545 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3546 : 
; 3547 :         return _Mypair._Myval2._Myptr()[0];

	mov	eax, DWORD PTR [ecx]

; 3548 :     }

	ret	0
$LN8@front:

; 3543 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3544 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3545 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3546 : 
; 3547 :         return _Mypair._Myval2._Myptr()[0];

	mov	eax, ecx

; 3548 :     }

	ret	0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 3122 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	ecx, DWORD PTR __Count$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edx, esi

; 2182 :         return _Min_value(_Size, _Mysize - _Off);

	mov	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	cmp	eax, ecx
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@erase

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [esi]
$LN8@erase:

; 3123 :         _Mypair._Myval2._Check_offset(_Off);
; 3124 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 3125 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3126 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 3127 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 3128 :         const size_type _New_size = _Old_size - _Count;

	sub	eax, ecx

; 3129 :         _Mypair._Myval2._Mysize   = _New_size;

	mov	DWORD PTR [esi+16], eax

; 3130 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	inc	eax

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax

; 3130 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	eax, DWORD PTR [edx+ecx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 3131 :         return *this;

	mov	eax, esi
	pop	esi

; 3132 :     }

	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT
; __Meta$ = ecx

; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {

	mov	eax, DWORD PTR [ecx]

; 401  :         return _Meta != eof() ? _Meta : !eof();

	xor	ecx, ecx
	cmp	eax, -1
	cmove	eax, ecx

; 402  :     }

	ret	0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Nr$4 = 8						; size = 4
__Filename$ = 8						; size = 4
__Pn$5 = 12						; size = 4
__Mode$ = 12						; size = 4
__Pb$6 = 16						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 275  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 276  :         // _Prot is an extension
; 277  :         if (_Myfile) {

	cmp	DWORD PTR [esi+76], 0
	jne	$LN32@open

; 278  :             return nullptr;
; 279  :         }
; 280  : 
; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

	push	DWORD PTR __Prot$[ebp]
	push	DWORD PTR __Mode$[ebp]
	push	DWORD PTR __Filename$[ebp]
	call	DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 282  :         if (!_File) {

	test	edi, edi
	je	$LN32@open

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 1
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 712  :             ::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$4[ebp]
	mov	DWORD PTR __Pb$6[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$5[ebp]
	mov	DWORD PTR __Pn$5[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$6[ebp]
	mov	DWORD PTR __Nr$4[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 276  :         _IGfirst = _Gf;

	mov	DWORD PTR [esi+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	mov	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\streambuf

; 277  :         _IPfirst = _Pf;

	mov	DWORD PTR [esi+16], eax

; 278  :         _IGnext  = _Gn;

	mov	eax, DWORD PTR __Pn$5[ebp]
	mov	DWORD PTR [esi+28], eax

; 279  :         _IPnext  = _Pn;

	mov	DWORD PTR [esi+32], eax

; 280  :         _IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$4[ebp]
	mov	DWORD PTR [esi+44], eax

; 281  :         _IPcount = _Pc;

	mov	DWORD PTR [esi+48], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax

; 719  :         _Myfile = _File;

	mov	DWORD PTR [esi+76], edi

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	call	DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	edi, eax

; 761  :         if (_Newcvt.always_noconv()) {

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN18@open

; 762  :             _Pcvt = nullptr; // nothing to do

	mov	DWORD PTR [esi+56], 0

; 763  :         } else { // set up for nontrivial codecvt facet

	jmp	SHORT $LN19@open
$LN18@open:

; 764  :             _Pcvt = _STD addressof(_Newcvt);
; 765  :             _Mysb::_Init(); // reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN19@open:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale

; 352  :         if (_Ptr) {

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN30@open

; 353  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN30@open
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN30@open:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream

; 288  :         return this; // open succeeded

	mov	eax, esi

; 289  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN32@open:

; 283  :             return nullptr; // open failed

	xor	eax, eax

; 289  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 162  :     basic_filebuf() : _Mysb() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 720  :         _State  = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 163  :         _Init(nullptr, _Newfl);
; 164  :     }

	mov	eax, esi

; 719  :         _Myfile = _File;

	mov	DWORD PTR [esi+76], 0

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 163  :         _Init(nullptr, _Newfl);
; 164  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Set@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AAEXPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AAEXPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Set, COMDAT
; _this$ = ecx

; 1095 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	push	ebp
	mov	ebp, esp

; 1096 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1097 :     }

	pop	ebp
	ret	4
?_Set@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AAEXPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Local@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Local@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABE_NXZ PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Local, COMDAT
; _this$ = ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	DWORD PTR [ecx+36], ecx
	sete	al

; 1081 :     }

	ret	0
?_Local@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABE_NXZ ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Local
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Set@?$_Func_class@_NH@std@@AAEXPAV?$_Func_base@_NH@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@_NH@std@@AAEXPAV?$_Func_base@_NH@2@@Z PROC ; std::_Func_class<bool,int>::_Set, COMDAT
; _this$ = ecx

; 1095 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	push	ebp
	mov	ebp, esp

; 1096 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1097 :     }

	pop	ebp
	ret	4
?_Set@?$_Func_class@_NH@std@@AAEXPAV?$_Func_base@_NH@2@@Z ENDP ; std::_Func_class<bool,int>::_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Local@?$_Func_class@_NH@std@@ABE_NXZ
_TEXT	SEGMENT
?_Local@?$_Func_class@_NH@std@@ABE_NXZ PROC		; std::_Func_class<bool,int>::_Local, COMDAT
; _this$ = ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	DWORD PTR [ecx+36], ecx
	sete	al

; 1081 :     }

	ret	0
?_Local@?$_Func_class@_NH@std@@ABE_NXZ ENDP		; std::_Func_class<bool,int>::_Local
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Set@?$_Func_class@_NHH@std@@AAEXPAV?$_Func_base@_NHH@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@_NHH@std@@AAEXPAV?$_Func_base@_NHH@2@@Z PROC ; std::_Func_class<bool,int,int>::_Set, COMDAT
; _this$ = ecx

; 1095 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	push	ebp
	mov	ebp, esp

; 1096 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1097 :     }

	pop	ebp
	ret	4
?_Set@?$_Func_class@_NHH@std@@AAEXPAV?$_Func_base@_NHH@2@@Z ENDP ; std::_Func_class<bool,int,int>::_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Local@?$_Func_class@_NHH@std@@ABE_NXZ
_TEXT	SEGMENT
?_Local@?$_Func_class@_NHH@std@@ABE_NXZ PROC		; std::_Func_class<bool,int,int>::_Local, COMDAT
; _this$ = ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	DWORD PTR [ecx+36], ecx
	sete	al

; 1081 :     }

	ret	0
?_Local@?$_Func_class@_NHH@std@@ABE_NXZ ENDP		; std::_Func_class<bool,int,int>::_Local
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2180 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

	push	ebp
	mov	ebp, esp

; 2181 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2182 :         return _Min_value(_Size, _Mysize - _Off);

	mov	ecx, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2183 :     }

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@X@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$1$ = -8						; size = 4
__Count$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@X@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,void>, COMDAT
; _this$ = ecx

; 1141 :     void assign(_Iter _First, _Iter _Last) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1142 :         _Adl_verify_range(_First, _Last);
; 1143 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR __First$1$[ebp], eax
	push	esi
	sub	edx, eax
	mov	DWORD PTR __Count$1$[ebp], edx

; 1108 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx]
	sub	ecx, esi

; 1109 :             if (_Newsize > _Oldcapacity) {

	cmp	edx, ecx
	jbe	$LN61@assign

; 1286 :         if (_Newsize > max_size()) {

	cmp	edx, 2147483647				; 7fffffffH
	ja	$LN68@assign
	push	edi

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edi, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edi, 1
	sub	eax, edi
	cmp	ecx, eax
	jbe	SHORT $LN13@assign

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	edi, edx
	jmp	SHORT $LN14@assign
$LN13@assign:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	edi, ecx

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	edi, edx
	cmovb	edi, edx
$LN14@assign:

; 1292 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN10@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN32@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN50@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN32@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1296 :             _Myfirst = pointer();

	mov	DWORD PTR [ebx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1297 :             _Mylast  = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1298 :             _Myend   = pointer();

	mov	DWORD PTR [ebx+8], 0
$LN10@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN41@assign

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	SHORT $LN69@assign

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN50@assign

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN40@assign
$LN50@assign:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN41@assign:

; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN42@assign

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN40@assign
$LN42@assign:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN40@assign:
	mov	edx, DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR [ebx], esi
	mov	DWORD PTR [ebx+4], esi
	mov	DWORD PTR [ebx+8], eax
	mov	eax, DWORD PTR __First$1$[ebp]
	pop	edi
$LN61@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	eax
	push	esi
	call	_memmove

; 3313 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Count$1$[ebp]
	add	esp, 12					; 0000000cH
	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1113 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

	mov	DWORD PTR [ebx+4], eax
	pop	esi
	pop	ebx

; 1144 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN68@assign:

; 1287 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN69@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN66@assign:
	int	3
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@X@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@std@@YAPADABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@std@@YAPADABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>, COMDAT
; __It$ = ecx

; 1122 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1123 :     return _It._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1124 : }

	ret	0
??$_Get_unwrapped@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@std@@YAPADABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Guard$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$dead$ = 16						; size = 4
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,void>, COMDAT
; _this$ = ecx

; 2374 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2379 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());

	mov	ebx, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	mov	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2379 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());

	mov	esi, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	sub	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2398 :         reserve(_Count);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [edi], 0

; 2398 :         reserve(_Count);

	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2386 :         _Tidy_deallocate_guard<basic_string> _Guard{this};

	mov	DWORD PTR __Guard$4[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2387 :         for (; _First != _Last; ++_First) {

	cmp	esi, ebx
	je	SHORT $LN53@allocator
$LL16@allocator:

; 2388 :             push_back(*_First);

	movzx	eax, BYTE PTR [esi]
	mov	ecx, edi
	push	eax
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
	inc	esi
	cmp	esi, ebx
	jne	SHORT $LL16@allocator
$LN53@allocator:

; 2380 :         _Proxy._Release();
; 2381 :     }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z$0:
	lea	ecx, DWORD PTR __Guard$4[ebp]
	jmp	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
__ehhandler$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,void>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@std@@YAPAEABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@std@@YAPAEABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>, COMDAT
; __It$ = ecx

; 1122 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1123 :     return _It._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1124 : }

	ret	0
??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@std@@YAPAEABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave_guard$5 = -24					; size = 4
__Lock$6 = -20						; size = 4
__Psave$7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT
; __Loc$ = ecx

; 427  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 428  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$6[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 429  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 430  : 
; 431  :     const size_t _Id         = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
	mov	DWORD PTR __Psave$7[ebp], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
	mov	edi, eax

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	eax, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN15@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	SHORT $LN30@use_facet
	jmp	SHORT $LN32@use_facet
$LN15@use_facet:

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN32@use_facet:

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN10@use_facet

; 377  :             return _Facptr; // found facet or not transparent
; 378  :         }
; 379  : 
; 380  :         // look in current locale
; 381  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 382  :         if (_Id < _Ptr0->_Facetcount) {

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN33@use_facet

; 383  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN10@use_facet:

; 432  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 433  : 
; 434  :     if (!_Pf) {

	test	esi, esi
	jne	SHORT $LN30@use_facet
$LN33@use_facet:

; 435  :         if (_Psave) {

	mov	esi, DWORD PTR __Psave$7[ebp]
	test	esi, esi
	jne	SHORT $LN30@use_facet

; 436  :             _Pf = _Psave; // lazy facet already allocated
; 437  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	lea	eax, DWORD PTR __Psave$7[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN38@use_facet

; 440  : #else // _HAS_EXCEPTIONS
; 441  :             abort(); // lazy disallowed
; 442  : #endif // _HAS_EXCEPTIONS
; 443  :         } else { // queue up lazy facet for destruction
; 444  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	esi, DWORD PTR __Psave$7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	DWORD PTR __Psave_guard$5[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale

; 450  :             _Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 451  : #endif // defined(_M_CEE)
; 452  : 
; 453  :             _Pfmod->_Incref();

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 454  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	esi, DWORD PTR __Psave$7[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN30@use_facet:

; 455  :             _Pf                       = _Psave;
; 456  : 
; 457  :             (void) _Psave_guard.release();
; 458  :         }
; 459  :     }
; 460  : 
; 461  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$6[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	mov	eax, esi

; 462  :     _END_LOCK()
; 463  : } // end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@use_facet:

; 438  : #if _HAS_EXCEPTIONS
; 439  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
$LN35@use_facet:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$6[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$5[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 454  :     void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 455  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 456  :         auto& _My_data  = _Mypair._Myval2;
; 457  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 458  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[ebp]
	mov	ebx, ecx
	test	esi, esi
	je	SHORT $LN46@Construct_

; 1663 :         if (_Newcapacity > max_size()) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	SHORT $LN69@Construct_
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN13@Construct_

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	SHORT $LN70@Construct_

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN22@Construct_

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Construct_
$LN22@Construct_:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN13@Construct_:

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
$LN12@Construct_:

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR [ebx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	0
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR [ebx+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 461  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

	mov	DWORD PTR [ebx+4], eax
	pop	edi
$LN46@Construct_:

; 466  :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN69@Construct_:

; 1664 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN70@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN67@Construct_:
	int	3
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT
; __Ptr$ = ecx

; 236  :     return _Ptr;

	mov	eax, ecx

; 237  : }

	ret	0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 310  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 311  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ
_TEXT	SEGMENT
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 2068 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

	mov	eax, DWORD PTR [ecx]

; 2069 :     }

	ret	0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1652 :     void _Buy_nonzero(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	esi

; 1653 :         // allocate array with _Newcapacity elements
; 1654 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1655 :         auto& _My_data    = _Mypair._Myval2;
; 1656 :         pointer& _Myfirst = _My_data._Myfirst;
; 1657 :         pointer& _Mylast  = _My_data._Mylast;
; 1658 :         pointer& _Myend   = _My_data._Myend;
; 1659 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1660 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1661 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1662 : 
; 1663 :         if (_Newcapacity > max_size()) {

	mov	esi, DWORD PTR __Newcapacity$[ebp]
	push	edi
	mov	edi, ecx
	cmp	esi, 2147483647				; 7fffffffH
	ja	SHORT $LN33@Buy_nonzer
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN9@Buy_nonzer

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	SHORT $LN34@Buy_nonzer

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN18@Buy_nonzer

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1668 :     }

	pop	ebp
	ret	4
$LN18@Buy_nonzer:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Buy_nonzer:

; 179  :     if (_Bytes != 0) {

	test	esi, esi
	je	SHORT $LN10@Buy_nonzer

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 51   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1668 :     }

	pop	ebp
	ret	4
$LN10@Buy_nonzer:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 183  :     return nullptr;

	xor	eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1668 :     }

	pop	ebp
	ret	4
$LN33@Buy_nonzer:

; 1664 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN34@Buy_nonzer:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN31@Buy_nonzer:
	int	3
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1081 :     // check that [_First, _Last) forms an iterator range
; 1082 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1083 :         _Verify_range(_First, _Last);
; 1084 :     } else {
; 1085 :         (void) _First; // TRANSITION, VSO#486357
; 1086 :         (void) _Last; // TRANSITION, VSO#486357
; 1087 :     }
; 1088 : }

	ret	0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Assign_range@PAD@?$vector@EV?$allocator@E@std@@@std@@AAEXPAD0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAD@?$vector@EV?$allocator@E@std@@@std@@AAEXPAD0Uforward_iterator_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_range<char *>, COMDAT
; _this$ = ecx

; 1095 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1095 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	mov	DWORD PTR __Last$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1108 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi]
	sub	ecx, esi

; 1109 :             if (_Newsize > _Oldcapacity) {

	cmp	edx, ecx
	jbe	$LN59@Assign_ran

; 1286 :         if (_Newsize > max_size()) {

	cmp	edx, 2147483647				; 7fffffffH
	ja	$LN65@Assign_ran
	push	ebx

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ebx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	ebx, 1
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN11@Assign_ran

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	ebx, edx
	jmp	SHORT $LN12@Assign_ran
$LN11@Assign_ran:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	ebx, ecx

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	ebx, edx
	cmovb	ebx, edx
$LN12@Assign_ran:

; 1292 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN8@Assign_ran
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN30@Assign_ran

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN48@Assign_ran

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN30@Assign_ran:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1296 :             _Myfirst = pointer();

	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1297 :             _Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1298 :             _Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
$LN8@Assign_ran:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN39@Assign_ran

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ebx+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, ebx
	jbe	SHORT $LN66@Assign_ran

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN48@Assign_ran

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN38@Assign_ran
$LN48@Assign_ran:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN39@Assign_ran:

; 179  :     if (_Bytes != 0) {

	test	ebx, ebx
	je	SHORT $LN40@Assign_ran

; 51   :         return ::operator new(_Bytes);

	push	ebx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN38@Assign_ran
$LN40@Assign_ran:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN38@Assign_ran:
	mov	edx, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR __First$[ebp]
	pop	ebx
$LN59@Assign_ran:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	eax
	push	esi
	call	_memmove

; 3313 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 12					; 0000000cH
	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1113 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi

; 1137 :     }

	pop	ebp
	ret	12					; 0000000cH
$LN65@Assign_ran:

; 1287 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN66@Assign_ran:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN63@Assign_ran:
	int	3
??$_Assign_range@PAD@?$vector@EV?$allocator@E@std@@@std@@AAEXPAD0Uforward_iterator_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_range<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1081 :     // check that [_First, _Last) forms an iterator range
; 1082 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1083 :         _Verify_range(_First, _Last);
; 1084 :     } else {
; 1085 :         (void) _First; // TRANSITION, VSO#486357
; 1086 :         (void) _Last; // TRANSITION, VSO#486357
; 1087 :     }
; 1088 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Guard$3 = 12						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>, COMDAT
; _this$ = ecx

; 2395 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ebx, DWORD PTR __Last$[ebp]
	mov	eax, ebx
	mov	esi, DWORD PTR __First$[ebp]
	sub	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2398 :         reserve(_Count);

	push	eax
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 2386 :         _Tidy_deallocate_guard<basic_string> _Guard{this};

	mov	DWORD PTR __Guard$3[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2387 :         for (; _First != _Last; ++_First) {

	cmp	esi, ebx
	je	SHORT $LN7@Construct
$LL8@Construct:

; 2388 :             push_back(*_First);

	movzx	eax, BYTE PTR [esi]
	mov	ecx, edi
	push	eax
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
	inc	esi
	cmp	esi, ebx
	jne	SHORT $LL8@Construct
$LN7@Construct:

; 2399 :         _Construct(_First, _Last, input_iterator_tag());
; 2400 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z$0:
	lea	ecx, DWORD PTR __Guard$3[ebp]
	jmp	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
__ehhandler$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAE0Uforward_iterator_tag@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z PROC ; std::forward<std::allocator<unsigned char> const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z ENDP ; std::forward<std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@$$CBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z PROC			; std::_Unfancy<char const >, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

	mov	eax, ecx

; 290  : }

	ret	0
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z ENDP			; std::_Unfancy<char const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1272 :     void _Clear_and_reserve_geometric(const size_type _Newsize) {

	push	ebp
	mov	ebp, esp
	push	esi

; 1273 :         auto& _My_data    = _Mypair._Myval2;
; 1274 :         pointer& _Myfirst = _My_data._Myfirst;
; 1275 :         pointer& _Mylast  = _My_data._Mylast;
; 1276 :         pointer& _Myend   = _My_data._Myend;
; 1277 : 
; 1278 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1279 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1280 :         {
; 1281 :             _Lockit _Lock(_LOCK_DEBUG);
; 1282 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter); // asserts that all iterators are orphaned
; 1283 :         } // unlock
; 1284 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1285 : 
; 1286 :         if (_Newsize > max_size()) {

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN57@Clear_and_

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 2147483647				; 7fffffffH

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	push	ebx

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	sub	eax, ebx
	cmp	ecx, eax
	ja	SHORT $LN7@Clear_and_

; 1623 :             return _Newsize; // geometric growth would overflow
; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN7@Clear_and_:

; 1288 :         }
; 1289 : 
; 1290 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1291 : 
; 1292 :         if (_Myfirst) { // destroy and deallocate old array

	test	edx, edx
	je	SHORT $LN3@Clear_and_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN25@Clear_and_

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ebx, DWORD PTR [edx-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edx, ebx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN43@Clear_and_

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edx, ebx
$LN25@Clear_and_:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1296 :             _Myfirst = pointer();

	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1297 :             _Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1298 :             _Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
$LN3@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	pop	ebx
	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN34@Clear_and_

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	SHORT $LN58@Clear_and_

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN43@Clear_and_

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1302 :     }

	pop	ebp
	ret	4
$LN43@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN34@Clear_and_:

; 179  :     if (_Bytes != 0) {

	test	esi, esi
	je	SHORT $LN35@Clear_and_

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 51   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1302 :     }

	pop	ebp
	ret	4
$LN35@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 183  :     return nullptr;

	xor	eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1302 :     }

	pop	ebp
	ret	4
$LN57@Clear_and_:

; 1287 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN58@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN55@Clear_and_:
	int	3
?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z
_TEXT	SEGMENT
__Guard$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>, COMDAT
; _this$ = ecx

; 2384 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2385 :         // initialize from [_First, _Last), input iterators
; 2386 :         _Tidy_deallocate_guard<basic_string> _Guard{this};

	mov	DWORD PTR __Guard$[ebp], edi

; 2387 :         for (; _First != _Last; ++_First) {

	mov	esi, DWORD PTR __First$[ebp]
	mov	ebx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	esi, ebx
	je	SHORT $LN3@Construct
	npad	4
$LL4@Construct:

; 2388 :             push_back(*_First);

	movzx	eax, BYTE PTR [esi]
	mov	ecx, edi
	push	eax
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
	inc	esi
	cmp	esi, ebx
	jne	SHORT $LL4@Construct
$LN3@Construct:

; 2389 :         }
; 2390 : 
; 2391 :         _Guard._Target = nullptr;
; 2392 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z$0:
	lea	ecx, DWORD PTR __Guard$[ebp]
	jmp	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
__ehhandler$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@PAE@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPAEQAEUinput_iterator_tag@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<unsigned char *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$distance@PAD@std@@YAHPAD0@Z
_TEXT	SEGMENT
??$distance@PAD@std@@YAHPAD0@Z PROC			; std::distance<char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	mov	eax, edx

; 1648 :     } else {
; 1649 :         _Adl_verify_range(_First, _Last);
; 1650 :         auto _UFirst             = _Get_unwrapped(_First);
; 1651 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1652 :         _Iter_diff_t<_InIt> _Off = 0;
; 1653 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1654 :             ++_Off;
; 1655 :         }
; 1656 : 
; 1657 :         return _Off;
; 1658 :     }
; 1659 : }

	ret	0
??$distance@PAD@std@@YAHPAD0@Z ENDP			; std::distance<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Copy_memmove@PADPAE@std@@YAPAEPAD0PAE@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PADPAE@std@@YAPAEPAD0PAE@Z PROC	; std::_Copy_memmove<char *,unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3307 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { // implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	push	esi

; 3308 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3309 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3310 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 3313 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 3314 : }

	pop	ebp
	ret	0
??$_Copy_memmove@PADPAE@std@@YAPAEPAD0PAE@Z ENDP	; std::_Copy_memmove<char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Refancy@PAE$0A@@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Refancy@PAE$0A@@std@@YAPAEPAE@Z PROC		; std::_Refancy<unsigned char *,0>, COMDAT
; __Ptr$ = ecx

; 236  :     return _Ptr;

	mov	eax, ecx

; 237  : }

	ret	0
??$_Refancy@PAE$0A@@std@@YAPAEPAE@Z ENDP		; std::_Refancy<unsigned char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$distance@PAE@std@@YAHPAE0@Z
_TEXT	SEGMENT
??$distance@PAE@std@@YAHPAE0@Z PROC			; std::distance<unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1647 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	mov	eax, edx

; 1648 :     } else {
; 1649 :         _Adl_verify_range(_First, _Last);
; 1650 :         auto _UFirst             = _Get_unwrapped(_First);
; 1651 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1652 :         _Iter_diff_t<_InIt> _Off = 0;
; 1653 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1654 :             ++_Off;
; 1655 :         }
; 1656 : 
; 1657 :         return _Off;
; 1658 :     }
; 1659 : }

	ret	0
??$distance@PAE@std@@YAHPAE0@Z ENDP			; std::distance<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 5121 :     ~_Tidy_deallocate_guard() {

	push	esi

; 5122 :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN6@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN13@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN23@Tidy_deall

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN20@Tidy_deall

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN23@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
$LN6@Tidy_deall:
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 5125 :     }

	ret	0
$LN20@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN28@Tidy_deall:
	int	3
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 374  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

	push	ebp
	mov	ebp, esp

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[ebp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

	test	eax, eax
	jne	SHORT $LN1@Getfacet
	jmp	SHORT $LN8@Getfacet
$LN6@Getfacet:

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	eax, eax
$LN8@Getfacet:

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 377  :             return _Facptr; // found facet or not transparent
; 378  :         }
; 379  : 
; 380  :         // look in current locale
; 381  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 382  :         if (_Id < _Ptr0->_Facetcount) {

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN4@Getfacet

; 383  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 387  :     }

	pop	ebp
	ret	4
$LN4@Getfacet:

; 384  :         }
; 385  : 
; 386  :         return nullptr; // no entry in current locale

	xor	eax, eax
$LN1@Getfacet:
	pop	esi

; 387  :     }

	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	xorps	xmm0, xmm0

; 132  :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h

; 62   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 63   :     {
; 64   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_typeinfo.h

; 131  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 86   :     {

	push	esi
	mov	esi, ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 69   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 68   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 65   :     _THROW(bad_cast{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	mov	eax, ecx
	push	eax
	call	__CxxThrowException@8
$LN3@Throw_bad_:
	int	3
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 1818 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory

; 1818 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$dead$ = ecx

; 1763 :     void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	push	ebp
	mov	ebp, esp

; 1764 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1765 :         delete _Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Ptr$[ebp], 1

; 1766 :     }

	pop	ebp

; 1764 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1765 :         delete _Ptr;

	jmp	DWORD PTR [eax]
$LN3@operator:

; 1766 :     }

	pop	ebp
	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

	mov	eax, ecx

; 1337 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 1872 :         if (_Mypair._Myval2) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN6@unique_ptr

; 1765 :         delete _Ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN6@unique_ptr:

; 1873 :             _Mypair._Get_first()(_Mypair._Myval2);
; 1874 :         }
; 1875 :     }

	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z
_TEXT	SEGMENT
??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z PROC ; std::exchange<std::_Facet_base *,std::_Facet_base *>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 570  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx]

; 571  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 572  :     return _Old_val;
; 573  : }

	ret	0
??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z ENDP ; std::exchange<std::_Facet_base *,std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 570  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx]

; 571  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\memory

; 1903 :     }

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2177 :         _Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN3@Xran:
	int	3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$dead$ = ecx

; 2165 :         if (_Mysize < _Off) {
; 2166 :             _Xran();
; 2167 :         }
; 2168 :     }

	ret	4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 1068 :     void _Adopt(const void*) noexcept {}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 352  :         if (_Ptr) {

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 353  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 354  :         }
; 355  :     }

	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = cl
; __File$ = edx

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

	push	edx
	movsx	eax, cl
	push	eax
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	eax, -1
	setne	al

; 108  : }

	ret	0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

	movzx	eax, BYTE PTR [ecx]
	push	edx
	push	eax
	call	DWORD PTR __imp__ungetc
	add	esp, 8
	cmp	eax, -1
	setne	al

; 131  : }

	ret	0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$dead$ = ecx

; 3526 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 3526 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

	push	edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 3527 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3527 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [esi+edi], al

; 3529 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [esi+edi+1], 0
	pop	edi
	pop	esi

; 3530 :             },

	pop	ebp
	ret	16					; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 4129 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 4130 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4131 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4132 :         auto& _My_data            = _Mypair._Myval2;
; 4133 :         const size_type _Old_size = _My_data._Mysize;
; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	push	edi
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	cmp	eax, 1
	jb	$LN65@Reallocate

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]
	lea	edi, DWORD PTR [edx+1]

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4088 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN10@Reallocate

; 4092 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN66@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN53@Reallocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx+20], edi
	push	edx
	jb	SHORT $LN3@Reallocate

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	esi
	call	_memcpy

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	al, BYTE PTR _<_Args_0>$[ebp]
	mov	BYTE PTR [esi+ecx], al

; 3529 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [esi+ecx+1], 0

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4157 :         return *this;

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	esi
	call	_memcpy

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	al, BYTE PTR _<_Args_0>$[ebp]
	mov	BYTE PTR [esi+ecx], al

; 4157 :         return *this;

	mov	eax, ebx

; 3529 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [esi+ecx+1], 0

; 4157 :         return *this;

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN65@Reallocate:

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN66@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN63@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
__Old_size$1$ = -12					; size = 4
__Old$1$ = -8						; size = 4
tv556 = -4						; size = 4
$T12 = -4						; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3514 :     void push_back(const _Elem _Ch) { // insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 3515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	ebx, DWORD PTR [esi+16]

; 3516 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old_size$1$[ebp], ebx
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	ebx, ecx
	jae	SHORT $LN2@push_back

; 3517 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@push_back

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [esi]
$LN5@push_back:

; 3518 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 3519 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [esi+ebx], al

; 3520 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [esi+ebx+1], 0
	pop	esi

; 3532 :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@push_back:

; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ebx
	cmp	eax, 1
	jb	$LN77@push_back
	push	edi

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	edi, DWORD PTR [ebx+1]

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH
	cmp	edi, edx

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN17@push_back

; 4088 :             return _Max;

	mov	edi, edx
	jmp	SHORT $LN74@push_back
$LN17@push_back:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ecx
	shr	eax, 1
	sub	edx, eax
	cmp	ecx, edx
	jbe	SHORT $LN18@push_back

; 4092 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN74@push_back
$LN18@push_back:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN74@push_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR $T12[ebp], edi
	inc	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN25@push_back

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	$LN78@push_back

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN61@push_back

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN24@push_back
$LN25@push_back:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN26@push_back

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN24@push_back
$LN26@push_back:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN24@push_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4144 :         _My_data._Mysize      = _New_size;

	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [esi+16], eax

; 4145 :         _My_data._Myres       = _New_capacity;

	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR [esi+20], eax

; 4146 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv556[ebp], eax

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN11@push_back

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Old_size$1$[ebp]

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	ebx, DWORD PTR [esi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	edi
	call	_memcpy

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	ecx, DWORD PTR tv556[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al

; 3529 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [ecx+1], 0

; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN64@push_back

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [ebx-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ebx, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ebx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN61@push_back

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ebx, edx
$LN64@push_back:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4154 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 3532 :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN61@push_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN11@push_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	esi
	push	edi
	call	_memcpy

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	lea	ecx, DWORD PTR [edi+ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3528 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [ecx], al

; 3529 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [ecx+1], 0

; 4154 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 3532 :     }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN77@push_back:

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN78@push_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN73@push_back:
	int	3
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 65   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

	push	esi

; 66   :     int _Meta;
; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	push	edx
	mov	esi, ecx
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@Fgetc

; 68   :         return false;

	xor	al, al
	pop	esi

; 72   :     }
; 73   : }

	ret	0
$LN2@Fgetc:

; 69   :     } else { // got one, convert to char
; 70   :         _Byte = static_cast<char>(_Meta);

	mov	BYTE PTR [esi], al

; 71   :         return true;

	mov	al, 1
	pop	esi

; 72   :     }
; 73   : }

	ret	0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z PROC ; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT
; __Meta$ = ecx

; 389  :         return static_cast<_Elem>(_Meta);

	mov	al, BYTE PTR [ecx]

; 390  :     }

	ret	0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z ENDP ; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z PROC ; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT
; __Ch$ = ecx

; 393  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [ecx]

; 394  :     }

	ret	0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z ENDP ; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3493 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN8@operator

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN8@operator:

; 3494 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3495 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3496 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3497 :         return _Mypair._Myval2._Myptr()[_Off];
; 3498 :     }

	add	eax, ecx
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2706 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp

; 2708 :     }

	pop	ebp

; 2707 :         return assign(_Ptr);

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 2286 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2287 :         _Tidy_init();
; 2288 :     }

	mov	eax, ecx

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2286 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2287 :         _Tidy_init();
; 2288 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h
;	COMDAT ?makeDWORD@thatboy@@YAIGG@Z
_TEXT	SEGMENT
?makeDWORD@thatboy@@YAIGG@Z PROC			; thatboy::makeDWORD, COMDAT
; _a$ = cx
; _b$ = dx

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	movzx	eax, dx
	shl	eax, 16					; 00000010H
	movzx	ecx, cx
	or	eax, ecx

; 34   : 	}

	ret	0
?makeDWORD@thatboy@@YAIGG@Z ENDP			; thatboy::makeDWORD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h
;	COMDAT ?makeWORD@thatboy@@YAGEE@Z
_TEXT	SEGMENT
?makeWORD@thatboy@@YAGEE@Z PROC				; thatboy::makeWORD, COMDAT
; _a$ = cl
; _b$ = dl

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	eax, dl
	shl	ax, 8
	movzx	ecx, cl
	or	ax, cx

; 29   : 	}

	ret	0
?makeWORD@thatboy@@YAGEE@Z ENDP				; thatboy::makeWORD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptBase.h
;	COMDAT ?makeDWORD@thatboy@@YAIEEEE@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
_d$ = 12						; size = 1
?makeDWORD@thatboy@@YAIEEEE@Z PROC			; thatboy::makeDWORD, COMDAT
; _a$ = cl
; _b$ = dl

; 37   : 	{

	push	ebp
	mov	ebp, esp

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	eax, BYTE PTR _d$[ebp]

; 37   : 	{

	push	ebx

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	shl	ax, 8

; 37   : 	{

	mov	bl, cl
	push	esi

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	esi, BYTE PTR _c$[ebp]
	movzx	eax, ax

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	or	eax, esi

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	edx, dl
	shl	dx, 8

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	shl	eax, 16					; 00000010H

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	ecx, dx

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	or	eax, ecx

; 28   : 		return (((WORD)(a)) | ((WORD)(b) << 8));

	movzx	ecx, bl

; 38   : 		return makeDWORD(makeWORD(a, b), makeWORD(c, d));

	pop	esi

; 33   : 		return (((DWORD)(a)) | ((DWORD)(b) << 16));

	or	eax, ecx

; 38   : 		return makeDWORD(makeWORD(a, b), makeWORD(c, d));

	pop	ebx

; 39   : 	}

	pop	ebp
	ret	0
?makeDWORD@thatboy@@YAIEEEE@Z ENDP			; thatboy::makeDWORD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3649 :         return size() == 0;

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 3650 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

	mov	eax, ecx

; 685  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__New_capacity$1$ = 8					; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2555 :     void _Construct_lv_contents(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2556 :         // assign by copying data stored in _Right
; 2557 :         // pre: this != &_Right
; 2558 :         // pre: *this owns no memory, iterators orphaned (note:
; 2559 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2560 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2561 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2556 :         // assign by copying data stored in _Right
; 2557 :         // pre: this != &_Right
; 2558 :         // pre: *this owns no memory, iterators orphaned (note:
; 2559 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2560 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2561 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebx, DWORD PTR [esi+16]

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@Construct_

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [esi]
$LN5@Construct_:

; 2562 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2563 :         auto& _My_data                = _Mypair._Myval2;
; 2564 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN2@Construct_

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR [edi], xmm0

; 2578 :     }

	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], 15			; 0000000fH
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN2@Construct_:

; 2572 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	ecx, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2572 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	eax, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	cmp	eax, ecx
	cmova	eax, ecx
	mov	DWORD PTR __New_capacity$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2573 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	inc	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN16@Construct_

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN42@Construct_

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN25@Construct_

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN15@Construct_
$LN25@Construct_:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@Construct_:

; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN17@Construct_

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ecx, eax
	jmp	SHORT $LN15@Construct_
$LN17@Construct_:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ecx, ecx
$LN15@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2575 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [edi], ecx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	esi
	push	ecx
	call	_memcpy

; 2576 :         _My_data._Mysize = _Right_size;
; 2577 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __New_capacity$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 2578 :     }

	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN42@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN39@Construct_:
	int	3
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2270 :     basic_string(const basic_string& _Right)

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2561 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2561 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Right_size$1$[ebp], eax

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@basic_stri

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [edi]
$LN11@basic_stri:

; 2564 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN8@basic_stri

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]

; 2567 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH

; 2276 :     }

	pop	edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR [esi], xmm0

; 2276 :     }

	mov	DWORD PTR [esi+16], eax
	mov	eax, esi
	mov	DWORD PTR [esi+20], ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN8@basic_stri:

; 2572 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2572 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	ebx, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	cmp	ebx, eax
	cmova	ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2573 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN48@basic_stri

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN31@basic_stri

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@basic_stri
$LN31@basic_stri:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@basic_stri:

; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN23@basic_stri

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ecx, eax
	jmp	SHORT $LN21@basic_stri
$LN23@basic_stri:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ecx, ecx
$LN21@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2575 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$1$[ebp]
	inc	eax
	mov	DWORD PTR [esi], ecx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edi
	push	ecx
	call	_memcpy
	mov	eax, DWORD PTR __Right_size$1$[ebp]
	add	esp, 12					; 0000000cH

; 2276 :     }

	mov	DWORD PTR [esi+16], eax
	mov	eax, esi
	mov	DWORD PTR [esi+20], ebx
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN48@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN46@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Off$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Off$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	movq	QWORD PTR [ecx+16], xmm0
	pop	ebp
	ret	8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
END
