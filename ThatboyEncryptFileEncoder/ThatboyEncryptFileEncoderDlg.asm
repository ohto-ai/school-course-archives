; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\thatboyencryptfileencoderdlg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_08DBHNDAEH@?N?D?$LM?$PO?B?$LH?$LO?$LG@	; `string'
PUBLIC	??_C@_08LBKAJPNE@Wood?4she@			; `string'
PUBLIC	??_C@_08DGPLIAJK@?$LE?r?$LP?$KK?N?D?$LM?$PO@	; `string'
PUBLIC	??_C@_0CN@BIAAHMID@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?K?y?S?P?N?D@ ; `string'
PUBLIC	??_C@_04FHCNAFFK@?$LD?I?$LJ?$KG@		; `string'
PUBLIC	??_C@_08KNJFAAFE@?$LC?Y?W?w?V?P?$LG?O@		; `string'
PUBLIC	??_C@_0N@LMLCADBC@?N?D?$LM?$PO?$LE?r?$LP?$KK?$LE?m?N?s@ ; `string'
PUBLIC	??_C@_0N@EHGMKEHD@?N?D?$LM?$PO?$MA?$OA?P?M?$LE?m?N?s@ ; `string'
PUBLIC	??_C@_0L@BLBNHGNN@?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@ ; `string'
PUBLIC	??_C@_0L@NHOEFCGM@?C?$NM?B?k?$LC?$LL?F?$KF?E?d@	; `string'
PUBLIC	??_C@_0L@EGNECDJP@?I?h?$LB?$LI?$LC?$LL?F?$KF?E?d@ ; `string'
PUBLIC	??_C@_08DEIJEIHL@?P?h?R?$KK?C?$NM?B?k@		; `string'
PUBLIC	??_C@_08MGFBOHLC@?P?h?R?$KK?I?h?$LB?$LI@	; `string'
PUBLIC	??_C@_0M@BHIMCPO@CRC?P?$KD?Q?i?J?$KH?$LA?$NM@	; `string'
PUBLIC	??_C@_0P@HHKGKONE@Base64?$LN?b?B?k?$LE?m?N?s@	; `string'
PUBLIC	??_C@_08ECNGDOBK@?$LE?m?N?s?G?x?$LP?i@		; `string'
PUBLIC	??_C@_08BCICBECK@?N?$LE?V?$KK?G?x?$LP?i@	; `string'
PUBLIC	??_C@_08COCJNBCE@?N?$LE?V?$KK?$LE?m?N?s@	; `string'
PUBLIC	??_C@_04FMCPDGOH@?$LE?m?N?s@			; `string'
PUBLIC	??_C@_0BH@BECGLPEJ@?N?$LE?Q?$KB?T?q?N?D?$LM?$PO?$KD?$KM?$LC?Y?W?w?J?$KH?$LA?$NM?$KD?$KB@ ; `string'
PUBLIC	??_C@_04FKGFBLKM@?4ext@				; `string'
PUBLIC	??_C@_08JPHNKIGA@?$LB?$KD?$LE?f?N?D?$LM?$PO@	; `string'
PUBLIC	??_C@_0BL@OKGJOACA@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?$AA@ ; `string'
PUBLIC	??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BL@FKMFFNGJ@?$LM?S?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@ ; `string'
PUBLIC	??_C@_0BJ@MIKHDLPC@?N?D?$LM?$PO?$LM?S?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ ; `string'
PUBLIC	??_C@_0P@HIODCMAD@?N?D?$LM?$PO?Q?i?V?$KE?$LD?I?$LJ?$KG?$KD?$KB@ ; `string'
PUBLIC	??_C@_0BJ@FNIBAKGM@?N?D?$LM?$PO?Q?i?V?$KE?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ ; `string'
PUBLIC	??_C@_0BE@PDIJHHDA@?K?y?S?P?N?D?$LM?$PO?$CI?$CK?4?$CK?$CJ?$AA?$CK?4?$CK?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BL@PGNDALHG@?$LN?b?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@ ; `string'
PUBLIC	??_C@_0BJ@MICAHIAE@?N?D?$LM?$PO?$LN?b?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ ; `string'
PUBLIC	??_C@_08OAHPJFNN@?$CFH?3?$CFM?3?$CFS@		; `string'
PUBLIC	??_C@_06KJKBOKBH@?$FL?$CFs?$FN?$CFs@		; `string'
PUBLIC	??_C@_0BN@FEBDKGNG@Thatboy?5Encrypt?5File?5Encoder@ ; `string'
PUBLIC	??_C@_06DNBNKLGN@?$CC?$CF?$FL?$FO?$CC?$FN@	; `string'
PUBLIC	??_C@_05HPMPOKFN@?$CF?$FL?$FO?6?$FN@		; `string'
PUBLIC	??_C@_0CE@HOPGIPCP@Thatboy?5Encrypt?5File?5Encoder?5?9?5@ ; `string'
PUBLIC	??_C@_0P@HGIHICBA@?N?D?$LM?$PO?T?$KN?J?$LM?C?$PL?N?$KK?$KD?$LK@ ; `string'
PUBLIC	??_R2?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
PUBLIC	??_R2?$_Func_base@_NHH@std@@8			; std::_Func_base<bool,int,int>::`RTTI Base Class Array'
PUBLIC	??_R2?$_Func_base@_NH@std@@8			; std::_Func_base<bool,int>::`RTTI Base Class Array'
PUBLIC	??_R2CThatboyEncryptFileEncoderDlg@@8		; CThatboyEncryptFileEncoderDlg::`RTTI Base Class Array'
PUBLIC	??_R2CDialogEx@@8				; CDialogEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$_Func_base@_NHH@std@@8		; std::_Func_base<bool,int,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$_Func_base@_NH@std@@8		; std::_Func_base<bool,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CThatboyEncryptFileEncoderDlg@@8	; CThatboyEncryptFileEncoderDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCDialog@@@8				; CDialog `RTTI Type Descriptor'
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R2CWnd@@8					; CWnd::`RTTI Base Class Array'
PUBLIC	??_R3CWnd@@8					; CWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2CDialog@@8					; CDialog::`RTTI Base Class Array'
PUBLIC	??_R3CDialog@@8					; CDialog::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@CDialog@@8			; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CDialogEx@@8			; CDialogEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$_Func_base@_NHH@std@@8			; std::_Func_base<bool,int,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$_Func_base@_NHH@std@@@8		; std::_Func_base<bool,int,int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Func_base@_NH@std@@8			; std::_Func_base<bool,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$_Func_base@_NH@std@@@8		; std::_Func_base<bool,int> `RTTI Type Descriptor'
PUBLIC	??_R3CDialogEx@@8				; CDialogEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCDialogEx@@@8				; CDialogEx `RTTI Type Descriptor'
PUBLIC	??_R3CThatboyEncryptFileEncoderDlg@@8		; CThatboyEncryptFileEncoderDlg::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCThatboyEncryptFileEncoderDlg@@@8	; CThatboyEncryptFileEncoderDlg `RTTI Type Descriptor'
PUBLIC	??_R4CThatboyEncryptFileEncoderDlg@@6B@		; CThatboyEncryptFileEncoderDlg::`RTTI Complete Object Locator'
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7CThatboyEncryptFileEncoderDlg@@6B@		; CThatboyEncryptFileEncoderDlg::`vftable'
EXTRN	__imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z:PROC
EXTRN	__imp_?PreInitDialog@CDialog@@MAEXXZ:PROC
EXTRN	__imp_?OnCancel@CDialog@@MAEXXZ:PROC
EXTRN	__imp_?OnOK@CDialog@@MAEXXZ:PROC
EXTRN	__imp_?OnSetFont@CDialog@@UAEXPAVCFont@@@Z:PROC
EXTRN	__imp_?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z:PROC
EXTRN	__imp_?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z:PROC
EXTRN	__imp_?Create@CDialog@@UAEHPBDPAVCWnd@@@Z:PROC
EXTRN	__imp_?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC
EXTRN	__imp_?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC
EXTRN	__imp_?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:PROC
EXTRN	__imp_?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:PROC
EXTRN	__imp_?IsFrameWnd@CWnd@@UBEHXZ:PROC
EXTRN	__imp_?CheckAutoCenter@CDialog@@UAEHXZ:PROC
EXTRN	__imp_?ResizeDynamicLayout@CWnd@@MAEXXZ:PROC
EXTRN	__imp_?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z:PROC
EXTRN	__imp_?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z:PROC
EXTRN	__imp_?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z:PROC
EXTRN	__imp_?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z:PROC
EXTRN	__imp_?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z:PROC
EXTRN	__imp_?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z:PROC
EXTRN	__imp_?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z:PROC
EXTRN	__imp_?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z:PROC
EXTRN	__imp_?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:PROC
EXTRN	__imp_?PostNcDestroy@CWnd@@MAEXXZ:PROC
EXTRN	__imp_?DefWindowProcA@CWnd@@MAEJIIJ@Z:PROC
EXTRN	__imp_?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:PROC
EXTRN	__imp_?WindowProc@CWnd@@MAEJIIJ@Z:PROC
EXTRN	__imp_?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp_?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:PROC
EXTRN	__imp_?OnNotify@CWnd@@MAEHIJPAJ@Z:PROC
EXTRN	__imp_?OnCommand@CDialogEx@@MAEHIJ@Z:PROC
EXTRN	__imp_?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:PROC
EXTRN	__imp_?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:PROC
EXTRN	__imp_?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC
EXTRN	__imp_?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC
EXTRN	__imp_?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:PROC
EXTRN	__imp_?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:PROC
EXTRN	__imp_?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:PROC
EXTRN	__imp_?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:PROC
EXTRN	__imp_?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:PROC
EXTRN	__imp_?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC
EXTRN	__imp_?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC
EXTRN	__imp_?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:PROC
EXTRN	__imp_?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC
EXTRN	__imp_?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC
EXTRN	__imp_?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC
EXTRN	__imp_?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:PROC
EXTRN	__imp_?get_accChildCount@CWnd@@UAEJPAJ@Z:PROC
EXTRN	__imp_?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:PROC
EXTRN	__imp_?EnsureStdObj@CWnd@@UAEJXZ:PROC
EXTRN	__imp_?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z:PROC
EXTRN	__imp_?EndModalLoop@CWnd@@UAEXH@Z:PROC
EXTRN	__imp_?ContinueModal@CWnd@@UAEHXZ:PROC
EXTRN	__imp_?WinHelpInternal@CWnd@@UAEXKI@Z:PROC
EXTRN	__imp_?HtmlHelpA@CWnd@@UAEXKI@Z:PROC
EXTRN	__imp_?WinHelpA@CWnd@@UAEXKI@Z:PROC
EXTRN	__imp_?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:PROC
EXTRN	__imp_?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:PROC
EXTRN	__imp_?SetMenu@CWnd@@UAEHPAVCMenu@@@Z:PROC
EXTRN	__imp_?GetMenu@CWnd@@UBEPAVCMenu@@XZ:PROC
EXTRN	__imp_?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:PROC
EXTRN	__imp_?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:PROC
EXTRN	__imp_?DestroyWindow@CWnd@@UAEHXZ:PROC
EXTRN	__imp_?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:PROC
EXTRN	__imp_?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:PROC
EXTRN	__imp_?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:PROC
EXTRN	__imp_?PreSubclassWindow@CWnd@@UAEXXZ:PROC
EXTRN	__imp_?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:PROC
EXTRN	__imp_?OnFinalRelease@CWnd@@UAEXXZ:PROC
EXTRN	__imp_?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC
EXTRN	__imp_?GetRuntimeClass@CDialogEx@@UBEPAUCRuntimeClass@@XZ:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp_?SetWindowTextA@CWnd@@QAEXPBD@Z:PROC
EXTRN	__imp_?SetDlgItemTextA@CWnd@@QAEXHPBD@Z:PROC
EXTRN	__imp_?PreTranslateMessage@CDialogEx@@UAEHPAUtagMSG@@@Z:PROC
EXTRN	__imp_?Default@CWnd@@IAEJXZ:PROC
EXTRN	__imp__DragFinish@4:PROC
EXTRN	__imp__DragQueryFileA@16:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp___localtime64_s:PROC
EXTRN	__imp__strftime:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:PROC
EXTRN	__imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ:PROC
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z:PROC
EXTRN	__imp_?IsEmpty@?$CSimpleStringT@D$00@ATL@@QBE_NXZ:PROC
EXTRN	__imp_?GetDlgItemTextA@CWnd@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z:PROC
EXTRN	__imp_?EnableWindow@CWnd@@QAEHH@Z:PROC
EXTRN	__imp_?GetPathName@CFileDialog@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:PROC
EXTRN	__imp_?DoModal@CFileDialog@@UAEHXZ:PROC
EXTRN	__imp_?GetOFN@CFileDialog@@QAEAAUtagOFNA@@XZ:PROC
EXTRN	__imp_??1CFileDialog@@UAE@XZ:PROC
EXTRN	__imp_??0CFileDialog@@QAE@HPBD0K0PAVCWnd@@KH@Z:PROC
EXTRN	__imp_?UpdateData@CWnd@@QAEHH@Z:PROC
EXTRN	__imp_?OnPaint@CDialog@@IAEXXZ:PROC
EXTRN	__imp__DrawIcon@16:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp_??1CPaintDC@@UAE@XZ:PROC
EXTRN	__imp_??0CPaintDC@@QAE@PAVCWnd@@@Z:PROC
EXTRN	__imp__IsIconic@4:PROC
EXTRN	__imp__SkinH_AttachEx@8:PROC
EXTRN	__imp_?AddTool@CToolTipCtrl@@QAEHPAVCWnd@@PBDPBUtagRECT@@I@Z:PROC
EXTRN	__imp_?EnableToolTips@CWnd@@QAEHH@Z:PROC
EXTRN	__imp_?OnInitDialog@CDialog@@UAEHXZ:PROC
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:PROC
EXTRN	__imp_?GetString@?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:PROC
EXTRN	__imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp_?GetThisMessageMap@CDialogEx@@KGPBUAFX_MSGMAP@@XZ:PROC
EXTRN	__imp_?AfxThrowMemoryException@@YGXXZ:PROC
EXTRN	__imp_?AfxThrowOleException@@YGXJ@Z:PROC
EXTRN	__imp_?GetData@?$CSimpleStringT@D$00@ATL@@ABEPAUCStringData@2@XZ:PROC
EXTRN	__imp_?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp_?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z:PROC
EXTRN	__imp_??0CToolTipCtrl@@QAE@XZ:PROC
EXTRN	__imp_??0CDialogEx@@QAE@IPAVCWnd@@@Z:PROC
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC ; CWnd::get_accSelection
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC	; CWnd::get_accFocus
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accKeyboardShortcut
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:PROC		; CWnd::DefWindowProcA
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnWndMsg
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:PROC		; CWnd::WindowProc
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:PROC ; CWnd::OnAmbientProperty
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:PROC ; CWnd::GetSuperWndProcAddr
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:PROC		; CWnd::OnNotify
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC ; CWnd::put_accValue
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC	; CWnd::put_accName
EXTRN	?OnCommand@CDialogEx@@MAEHIJ@Z:PROC		; CDialogEx::OnCommand
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:PROC	; CWnd::CreateAccessibleProxy
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:PROC ; CWnd::SetProxy
EXTRN	?Create@CDialog@@UAEHPBDPAVCWnd@@@Z:PROC	; CDialog::Create
EXTRN	?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CDialog::GetOccDialogInfo
EXTRN	?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CDialog::SetOccDialogInfo
EXTRN	?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z:PROC	; CWnd::OnGestureRotate
EXTRN	?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z:PROC	; CWnd::OnGesturePan
EXTRN	?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z:PROC	; CWnd::OnGestureZoom
EXTRN	?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z:PROC	; CWnd::GetGestureStatus
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDefaultAction
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:PROC ; CWnd::get_accHelpTopic
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accHelp
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accState
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accRole
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accValue
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accName
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:PROC ; CWnd::get_accChild
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:PROC			; CWnd::EnsureStdObj
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:PROC		; CWnd::get_accChildCount
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:PROC ; CWnd::get_accParent
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:PROC ; CWnd::accDoDefaultAction
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:PROC	; CWnd::accHitTest
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::accNavigate
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::WinHelpA
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:PROC ; CWnd::GetScrollBarCtrl
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:PROC ; CWnd::OnToolHitTest
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:PROC	; CWnd::CalcWindowRect
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:PROC ; CWnd::PreCreateWindow
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:PROC		; CWnd::DestroyWindow
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:PROC ; CWnd::CreateEx
EXTRN	?SetMenu@CWnd@@UAEHPAVCMenu@@@Z:PROC		; CWnd::SetMenu
EXTRN	?GetMenu@CWnd@@UBEPAVCMenu@@XZ:PROC		; CWnd::GetMenu
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDescription
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:PROC ; CWnd::Create
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:PROC		; CWnd::PreSubclassWindow
EXTRN	?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z:PROC ; CWnd::OnDrawIconicThumbnailOrLivePreview
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:PROC		; CWnd::EndModalLoop
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:PROC ; CWnd::CreateEx
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:PROC ; CWnd::GetInterfaceMap
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:PROC		; CWnd::OnFinalRelease
EXTRN	?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CDialog::OnCmdMsg
EXTRN	?GetRuntimeClass@CDialogEx@@UBEPAUCRuntimeClass@@XZ:PROC ; CDialogEx::GetRuntimeClass
EXTRN	?ContinueModal@CWnd@@UAEHXZ:PROC		; CWnd::ContinueModal
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:PROC		; CWnd::WinHelpInternal
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::HtmlHelpA
EXTRN	?GetThisMessageMap@CDialogEx@@KGPBUAFX_MSGMAP@@XZ:PROC ; CDialogEx::GetThisMessageMap
EXTRN	?PreInitDialog@CDialog@@MAEXXZ:PROC		; CDialog::PreInitDialog
EXTRN	?OnOK@CDialog@@MAEXXZ:PROC			; CDialog::OnOK
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:PROC ; CWnd::CreateControlSite
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:PROC ; CWnd::CreateControlContainer
EXTRN	?CheckAutoCenter@CDialog@@UAEHXZ:PROC		; CDialog::CheckAutoCenter
EXTRN	?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInput
EXTRN	?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInputs
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnChildNotify
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:PROC		; CWnd::PostNcDestroy
EXTRN	?OnCancel@CDialog@@MAEXXZ:PROC			; CDialog::OnCancel
EXTRN	?OnSetFont@CDialog@@UAEXPAVCFont@@@Z:PROC	; CDialog::OnSetFont
EXTRN	?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z:PROC ; CDialog::CreateIndirect
EXTRN	?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z:PROC ; CDialog::CreateIndirect
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:PROC			; CWnd::IsFrameWnd
EXTRN	?ResizeDynamicLayout@CWnd@@MAEXXZ:PROC		; CWnd::ResizeDynamicLayout
EXTRN	?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z:PROC ; CWnd::OnGesturePressAndTap
EXTRN	?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z:PROC ; CWnd::OnGestureTwoFingerTap
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:PROC ; CWnd::accLocation
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:PROC	; CWnd::accSelect
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_7CThatboyEncryptFileEncoderDlg@@6B@
CONST	SEGMENT
??_7CThatboyEncryptFileEncoderDlg@@6B@ DD FLAT:??_R4CThatboyEncryptFileEncoderDlg@@6B@ ; CThatboyEncryptFileEncoderDlg::`vftable'
	DD	FLAT:?GetRuntimeClass@CDialogEx@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECThatboyEncryptFileEncoderDlg@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CThatboyEncryptFileEncoderDlg@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CDialogEx@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CThatboyEncryptFileEncoderDlg@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CThatboyEncryptFileEncoderDlg@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CDialog@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CDialog@@UAEHIPAVCWnd@@@Z
	DD	FLAT:?Create@CDialog@@UAEHPBDPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z
	DD	FLAT:?DoModal@CDialog@@UAEHXZ
	DD	FLAT:?OnInitDialog@CThatboyEncryptFileEncoderDlg@@MAEHXZ
	DD	FLAT:?OnSetFont@CDialog@@UAEXPAVCFont@@@Z
	DD	FLAT:?OnOK@CDialog@@MAEXXZ
	DD	FLAT:?OnCancel@CDialog@@MAEXXZ
	DD	FLAT:?PreInitDialog@CDialog@@MAEXXZ
CONST	ENDS
;	COMDAT ?_messageEntries@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B DD 0fH ; `CThatboyEncryptFileEncoderDlg::GetThisMessageMap'::`2'::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	013H
	DD	FLAT:?OnPaint@CThatboyEncryptFileEncoderDlg@@IAEXXZ
	DD	037H
	DD	00H
	DD	00H
	DD	00H
	DD	029H
	DD	FLAT:?OnQueryDragIcon@CThatboyEncryptFileEncoderDlg@@IAEPAUHICON__@@XZ
	DD	0111H
	DD	00H
	DD	03e9H
	DD	03e9H
	DD	03aH
	DD	FLAT:?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	0111H
	DD	00H
	DD	03edH
	DD	03edH
	DD	03aH
	DD	FLAT:?OnBnClickedNeedPassword@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	0111H
	DD	00H
	DD	03eeH
	DD	03eeH
	DD	03aH
	DD	FLAT:?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	0111H
	DD	00H
	DD	03eaH
	DD	03eaH
	DD	03aH
	DD	FLAT:?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	0111H
	DD	00H
	DD	03ebH
	DD	03ebH
	DD	03aH
	DD	FLAT:?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	0233H
	DD	00H
	DD	00H
	DD	00H
	DD	011H
	DD	FLAT:?OnDropFiles@CThatboyEncryptFileEncoderDlg@@QAEXPAUHDROP__@@@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messageMap@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4U3@B
CONST	SEGMENT
?messageMap@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4U3@B DD FLAT:?GetThisMessageMap@CDialogEx@@KGPBUAFX_MSGMAP@@XZ ; `CThatboyEncryptFileEncoderDlg::GetThisMessageMap'::`2'::messageMap
	DD	FLAT:?_messageEntries@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@ DD FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPAV?$_Func_base@_NH@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAE_N$$QAH@Z
	DD	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEX_N@Z
	DD	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@ DD FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPAV?$_Func_base@_NHH@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAE_N$$QAH0@Z
	DD	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEX_N@Z
	DD	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@ DD FLAT:??_R4?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@ ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAE_N$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	FLAT:?_Target_type@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEX_N@Z
	DD	FLAT:?_Get@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R0?AV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@8
data$r	SEGMENT
??_R0?AV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_880880f1ed3b8a16ebddcbf735e0f1c5> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@8
data$r	SEGMENT
??_R0?AV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_1fa47c227cca097ed6ab7fabc557d9e4> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@8
data$r	SEGMENT
??_R0?AV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_f74fcfde5f7b784984846d3120ae874c> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_f74fcfde5f7b784984846d3120ae874c>@@', 00H
data$r	ENDS
;	COMDAT ??_R4CThatboyEncryptFileEncoderDlg@@6B@
rdata$r	SEGMENT
??_R4CThatboyEncryptFileEncoderDlg@@6B@ DD 00H		; CThatboyEncryptFileEncoderDlg::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCThatboyEncryptFileEncoderDlg@@@8
	DD	FLAT:??_R3CThatboyEncryptFileEncoderDlg@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@ DD 00H ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@@8
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@ DD 00H ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@@8
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@ DD 00H ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCThatboyEncryptFileEncoderDlg@@@8
data$r	SEGMENT
??_R0?AVCThatboyEncryptFileEncoderDlg@@@8 DD FLAT:??_7type_info@@6B@ ; CThatboyEncryptFileEncoderDlg `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCThatboyEncryptFileEncoderDlg@@', 00H
data$r	ENDS
;	COMDAT ??_R3CThatboyEncryptFileEncoderDlg@@8
rdata$r	SEGMENT
??_R3CThatboyEncryptFileEncoderDlg@@8 DD 00H		; CThatboyEncryptFileEncoderDlg::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2CThatboyEncryptFileEncoderDlg@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDialogEx@@@8
data$r	SEGMENT
??_R0?AVCDialogEx@@@8 DD FLAT:??_7type_info@@6B@	; CDialogEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDialogEx@@', 00H
data$r	ENDS
;	COMDAT ??_R3CDialogEx@@8
rdata$r	SEGMENT
??_R3CDialogEx@@8 DD 00H				; CDialogEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CDialogEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_base@_NH@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_base@_NH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_base<bool,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_base@_NH@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_base@_NH@std@@8
rdata$r	SEGMENT
??_R3?$_Func_base@_NH@std@@8 DD 00H			; std::_Func_base<bool,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Func_base@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_base@_NHH@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_base@_NHH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_base<bool,int,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_base@_NHH@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_base@_NHH@std@@8
rdata$r	SEGMENT
??_R3?$_Func_base@_NHH@std@@8 DD 00H			; std::_Func_base<bool,int,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Func_base@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std'
	DB	'@@V?$allocator@D@2@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD 00H ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846'
	DB	'd3120ae874c>@@_NH@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7'
	DB	'fabc557d9e4>@@_NHH@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddc'
	DB	'bf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$all'
	DB	'ocator@D@2@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD 00H ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDialogEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDialogEx@@8 DD FLAT:??_R0?AVCDialogEx@@@8 ; CDialogEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDialogEx@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDialog@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDialog@@8 DD FLAT:??_R0?AVCDialog@@@8	; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R3CDialog@@8
rdata$r	SEGMENT
??_R3CDialog@@8 DD 00H					; CDialog::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R2CDialog@@8
rdata$r	SEGMENT
??_R2CDialog@@8 DD FLAT:??_R1A@?0A@EA@CDialog@@8	; CDialog::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3CWnd@@8
rdata$r	SEGMENT
??_R3CWnd@@8 DD	00H					; CWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2CWnd@@8
rdata$r	SEGMENT
??_R2CWnd@@8 DD	FLAT:??_R1A@?0A@EA@CWnd@@8		; CWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
data$r	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVCDialog@@@8
data$r	SEGMENT
??_R0?AVCDialog@@@8 DD FLAT:??_7type_info@@6B@		; CDialog `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDialog@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CThatboyEncryptFileEncoderDlg@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CThatboyEncryptFileEncoderDlg@@8 DD FLAT:??_R0?AVCThatboyEncryptFileEncoderDlg@@@8 ; CThatboyEncryptFileEncoderDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CThatboyEncryptFileEncoderDlg@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_base@_NH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_base@_NH@std@@8 DD FLAT:??_R0?AV?$_Func_base@_NH@std@@@8 ; std::_Func_base<bool,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_base@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_base@_NHH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_base@_NHH@std@@8 DD FLAT:??_R0?AV?$_Func_base@_NHH@std@@@8 ; std::_Func_base<bool,int,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_base@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD FLAT:??_R0?AV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8 DD FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@@8 ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8 DD FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@@8 ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD FLAT:??_R0?AV?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@8 ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2CDialogEx@@8
rdata$r	SEGMENT
??_R2CDialogEx@@8 DD FLAT:??_R1A@?0A@EA@CDialogEx@@8	; CDialogEx::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CThatboyEncryptFileEncoderDlg@@8
rdata$r	SEGMENT
??_R2CThatboyEncryptFileEncoderDlg@@8 DD FLAT:??_R1A@?0A@EA@CThatboyEncryptFileEncoderDlg@@8 ; CThatboyEncryptFileEncoderDlg::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDialogEx@@8
	DD	FLAT:??_R1A@?0A@EA@CDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_base@_NH@std@@8
rdata$r	SEGMENT
??_R2?$_Func_base@_NH@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_base@_NH@std@@8 ; std::_Func_base<bool,int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_base@_NHH@std@@8
rdata$r	SEGMENT
??_R2?$_Func_base@_NHH@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_base@_NHH@std@@8 ; std::_Func_base<bool,int,int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@8 ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@_NH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@8 ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@_NHH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8 ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0P@HGIHICBA@?N?D?$LM?$PO?T?$KN?J?$LM?C?$PL?N?$KK?$KD?$LK@
CONST	SEGMENT
??_C@_0P@HGIHICBA@?N?D?$LM?$PO?T?$KN?J?$LM?C?$PL?N?$KK?$KD?$LK@ DB 0ceH, 0c4H
	DB	0bcH, 0feH, 0d4H, 0adH, 0caH, 0bcH, 0c3H, 0fbH, 0ceH, 0aaH, 0a3H
	DB	0baH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOPGIPCP@Thatboy?5Encrypt?5File?5Encoder?5?9?5@
CONST	SEGMENT
??_C@_0CE@HOPGIPCP@Thatboy?5Encrypt?5File?5Encoder?5?9?5@ DB 'Thatboy Enc'
	DB	'rypt File Encoder - %s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPMPOKFN@?$CF?$FL?$FO?6?$FN@
CONST	SEGMENT
??_C@_05HPMPOKFN@?$CF?$FL?$FO?6?$FN@ DB '%[^', 0aH, ']', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNBNKLGN@?$CC?$CF?$FL?$FO?$CC?$FN@
CONST	SEGMENT
??_C@_06DNBNKLGN@?$CC?$CF?$FL?$FO?$CC?$FN@ DB '"%[^"]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FEBDKGNG@Thatboy?5Encrypt?5File?5Encoder@
CONST	SEGMENT
??_C@_0BN@FEBDKGNG@Thatboy?5Encrypt?5File?5Encoder@ DB 'Thatboy Encrypt F'
	DB	'ile Encoder', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06KJKBOKBH@?$FL?$CFs?$FN?$CFs@
CONST	SEGMENT
??_C@_06KJKBOKBH@?$FL?$CFs?$FN?$CFs@ DB '[%s]%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAHPJFNN@?$CFH?3?$CFM?3?$CFS@
CONST	SEGMENT
??_C@_08OAHPJFNN@?$CFH?3?$CFM?3?$CFS@ DB '%H:%M:%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MICAHIAE@?N?D?$LM?$PO?$LN?b?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
CONST	SEGMENT
??_C@_0BJ@MICAHIAE@?N?D?$LM?$PO?$LN?b?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ DB 0ceH
	DB	0c4H, 0bcH, 0feH, 0bdH, 0e2H, 0c3H, 0dcH, 0caH, 0a7H, 0b0H, 0dcH
	DB	0a3H, 0acH, 0b4H, 0edH, 0ceH, 0f3H, 0d4H, 0adH, 0d2H, 0f2H, 0a3H
	DB	0baH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PGNDALHG@?$LN?b?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@
CONST	SEGMENT
??_C@_0BL@PGNDALHG@?$LN?b?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@ DB 0bdH
	DB	0e2H, 0c3H, 0dcH, 0b9H, 0a4H, 0d7H, 0f7H, 0cdH, 0eaH, 0b3H, 0c9H
	DB	0a3H, 0a1H, 0ceH, 0c4H, 0bcH, 0feH, 0d2H, 0d1H, 0b1H, 0a3H, 0b4H
	DB	0e6H, 0d6H, 0c1H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PDIJHHDA@?K?y?S?P?N?D?$LM?$PO?$CI?$CK?4?$CK?$CJ?$AA?$CK?4?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_0BE@PDIJHHDA@?K?y?S?P?N?D?$LM?$PO?$CI?$CK?4?$CK?$CJ?$AA?$CK?4?$CK?$AA?$AA@ DB 0cbH
	DB	0f9H, 0d3H, 0d0H, 0ceH, 0c4H, 0bcH, 0feH, '(*.*)', 00H, '*.*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FNIBAKGM@?N?D?$LM?$PO?Q?i?V?$KE?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
CONST	SEGMENT
??_C@_0BJ@FNIBAKGM@?N?D?$LM?$PO?Q?i?V?$KE?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ DB 0ceH
	DB	0c4H, 0bcH, 0feH, 0d1H, 0e9H, 0d6H, 0a4H, 0caH, 0a7H, 0b0H, 0dcH
	DB	0a3H, 0acH, 0b4H, 0edH, 0ceH, 0f3H, 0d4H, 0adH, 0d2H, 0f2H, 0a3H
	DB	0baH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HIODCMAD@?N?D?$LM?$PO?Q?i?V?$KE?$LD?I?$LJ?$KG?$KD?$KB@
CONST	SEGMENT
??_C@_0P@HIODCMAD@?N?D?$LM?$PO?Q?i?V?$KE?$LD?I?$LJ?$KG?$KD?$KB@ DB 0ceH, 0c4H
	DB	0bcH, 0feH, 0d1H, 0e9H, 0d6H, 0a4H, 0b3H, 0c9H, 0b9H, 0a6H, 0a3H
	DB	0a1H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MIKHDLPC@?N?D?$LM?$PO?$LM?S?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
CONST	SEGMENT
??_C@_0BJ@MIKHDLPC@?N?D?$LM?$PO?$LM?S?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@ DB 0ceH
	DB	0c4H, 0bcH, 0feH, 0bcH, 0d3H, 0c3H, 0dcH, 0caH, 0a7H, 0b0H, 0dcH
	DB	0a3H, 0acH, 0b4H, 0edH, 0ceH, 0f3H, 0d4H, 0adH, 0d2H, 0f2H, 0a3H
	DB	0baH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FKMFFNGJ@?$LM?S?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@
CONST	SEGMENT
??_C@_0BL@FKMFFNGJ@?$LM?S?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@ DB 0bcH
	DB	0d3H, 0c3H, 0dcH, 0b9H, 0a4H, 0d7H, 0f7H, 0cdH, 0eaH, 0b3H, 0c9H
	DB	0a3H, 0a1H, 0ceH, 0c4H, 0bcH, 0feH, 0d2H, 0d1H, 0b1H, 0a3H, 0b4H
	DB	0e6H, 0d6H, 0c1H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@
CONST	SEGMENT
??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@ DB 0b3H, 0f6H
	DB	0cfH, 0d6H, 0ceH, 0b4H, 0d6H, 0aaH, 0b4H, 0edH, 0ceH, 0f3H, 0a3H
	DB	0a1H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OKGJOACA@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?$AA@
CONST	SEGMENT
??_C@_0BL@OKGJOACA@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?$AA@ DB 'T'
	DB	'EF', 0bcH, 0d3H, 0c3H, 0dcH, 0ceH, 0c4H, 0bcH, 0feH, '(*.tef)'
	DB	00H, '*.tef', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPHNKIGA@?$LB?$KD?$LE?f?N?D?$LM?$PO@
CONST	SEGMENT
??_C@_08JPHNKIGA@?$LB?$KD?$LE?f?N?D?$LM?$PO@ DB 0b1H, 0a3H, 0b4H, 0e6H, 0ceH
	DB	0c4H, 0bcH, 0feH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKGFBLKM@?4ext@
CONST	SEGMENT
??_C@_04FKGFBLKM@?4ext@ DB '.ext', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BECGLPEJ@?N?$LE?Q?$KB?T?q?N?D?$LM?$PO?$KD?$KM?$LC?Y?W?w?J?$KH?$LA?$NM?$KD?$KB@
CONST	SEGMENT
??_C@_0BH@BECGLPEJ@?N?$LE?Q?$KB?T?q?N?D?$LM?$PO?$KD?$KM?$LC?Y?W?w?J?$KH?$LA?$NM?$KD?$KB@ DB 0ceH
	DB	0b4H, 0d1H, 0a1H, 0d4H, 0f1H, 0ceH, 0c4H, 0bcH, 0feH, 0a3H, 0acH
	DB	0b2H, 0d9H, 0d7H, 0f7H, 0caH, 0a7H, 0b0H, 0dcH, 0a3H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMCPDGOH@?$LE?m?N?s@
CONST	SEGMENT
??_C@_04FMCPDGOH@?$LE?m?N?s@ DB 0b4H, 0edH, 0ceH, 0f3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08COCJNBCE@?N?$LE?V?$KK?$LE?m?N?s@
CONST	SEGMENT
??_C@_08COCJNBCE@?N?$LE?V?$KK?$LE?m?N?s@ DB 0ceH, 0b4H, 0d6H, 0aaH, 0b4H, 0edH
	DB	0ceH, 0f3H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCICBECK@?N?$LE?V?$KK?G?x?$LP?i@
CONST	SEGMENT
??_C@_08BCICBECK@?N?$LE?V?$KK?G?x?$LP?i@ DB 0ceH, 0b4H, 0d6H, 0aaH, 0c7H, 0f8H
	DB	0bfH, 0e9H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ECNGDOBK@?$LE?m?N?s?G?x?$LP?i@
CONST	SEGMENT
??_C@_08ECNGDOBK@?$LE?m?N?s?G?x?$LP?i@ DB 0b4H, 0edH, 0ceH, 0f3H, 0c7H, 0f8H
	DB	0bfH, 0e9H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHKGKONE@Base64?$LN?b?B?k?$LE?m?N?s@
CONST	SEGMENT
??_C@_0P@HHKGKONE@Base64?$LN?b?B?k?$LE?m?N?s@ DB 'Base64', 0bdH, 0e2H, 0c2H
	DB	0ebH, 0b4H, 0edH, 0ceH, 0f3H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHIMCPO@CRC?P?$KD?Q?i?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_0M@BHIMCPO@CRC?P?$KD?Q?i?J?$KH?$LA?$NM@ DB 'CRC', 0d0H, 0a3H, 0d1H, 0e9H
	DB	0caH, 0a7H, 0b0H, 0dcH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MGFBOHLC@?P?h?R?$KK?I?h?$LB?$LI@
CONST	SEGMENT
??_C@_08MGFBOHLC@?P?h?R?$KK?I?h?$LB?$LI@ DB 0d0H, 0e8H, 0d2H, 0aaH, 0c9H, 0e8H
	DB	0b1H, 0b8H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEIJEIHL@?P?h?R?$KK?C?$NM?B?k@
CONST	SEGMENT
??_C@_08DEIJEIHL@?P?h?R?$KK?C?$NM?B?k@ DB 0d0H, 0e8H, 0d2H, 0aaH, 0c3H, 0dcH
	DB	0c2H, 0ebH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGNECDJP@?I?h?$LB?$LI?$LC?$LL?F?$KF?E?d@
CONST	SEGMENT
??_C@_0L@EGNECDJP@?I?h?$LB?$LI?$LC?$LL?F?$KF?E?d@ DB 0c9H, 0e8H, 0b1H, 0b8H
	DB	0b2H, 0bbH, 0c6H, 0a5H, 0c5H, 0e4H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NHOEFCGM@?C?$NM?B?k?$LC?$LL?F?$KF?E?d@
CONST	SEGMENT
??_C@_0L@NHOEFCGM@?C?$NM?B?k?$LC?$LL?F?$KF?E?d@ DB 0c3H, 0dcH, 0c2H, 0ebH
	DB	0b2H, 0bbH, 0c6H, 0a5H, 0c5H, 0e4H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLBNHGNN@?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
CONST	SEGMENT
??_C@_0L@BLBNHGNN@?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@ DB 0b0H, 0e6H, 0b1H, 0beH
	DB	0b2H, 0bbH, 0c6H, 0a5H, 0c5H, 0e4H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHGMKEHD@?N?D?$LM?$PO?$MA?$OA?P?M?$LE?m?N?s@
CONST	SEGMENT
??_C@_0N@EHGMKEHD@?N?D?$LM?$PO?$MA?$OA?P?M?$LE?m?N?s@ DB 0ceH, 0c4H, 0bcH
	DB	0feH, 0c0H, 0e0H, 0d0H, 0cdH, 0b4H, 0edH, 0ceH, 0f3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMLCADBC@?N?D?$LM?$PO?$LE?r?$LP?$KK?$LE?m?N?s@
CONST	SEGMENT
??_C@_0N@LMLCADBC@?N?D?$LM?$PO?$LE?r?$LP?$KK?$LE?m?N?s@ DB 0ceH, 0c4H, 0bcH
	DB	0feH, 0b4H, 0f2H, 0bfH, 0aaH, 0b4H, 0edH, 0ceH, 0f3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNJFAAFE@?$LC?Y?W?w?V?P?$LG?O@
CONST	SEGMENT
??_C@_08KNJFAAFE@?$LC?Y?W?w?V?P?$LG?O@ DB 0b2H, 0d9H, 0d7H, 0f7H, 0d6H, 0d0H
	DB	0b6H, 0cfH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHCNAFFK@?$LD?I?$LJ?$KG@
CONST	SEGMENT
??_C@_04FHCNAFFK@?$LD?I?$LJ?$KG@ DB 0b3H, 0c9H, 0b9H, 0a6H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BIAAHMID@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?K?y?S?P?N?D@
CONST	SEGMENT
??_C@_0CN@BIAAHMID@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?K?y?S?P?N?D@ DB 'T'
	DB	'EF', 0bcH, 0d3H, 0c3H, 0dcH, 0ceH, 0c4H, 0bcH, 0feH, '(*.tef)'
	DB	00H, '*.tef', 00H, 0cbH, 0f9H, 0d3H, 0d0H, 0ceH, 0c4H, 0bcH, 0feH
	DB	'(*.*)', 00H, '*.*', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DGPLIAJK@?$LE?r?$LP?$KK?N?D?$LM?$PO@
CONST	SEGMENT
??_C@_08DGPLIAJK@?$LE?r?$LP?$KK?N?D?$LM?$PO@ DB 0b4H, 0f2H, 0bfH, 0aaH, 0ceH
	DB	0c4H, 0bcH, 0feH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBKAJPNE@Wood?4she@
CONST	SEGMENT
??_C@_08LBKAJPNE@Wood?4she@ DB 'Wood.she', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBHNDAEH@?N?D?$LM?$PO?B?$LH?$LO?$LG@
CONST	SEGMENT
??_C@_08DBHNDAEH@?N?D?$LM?$PO?B?$LH?$LO?$LG@ DB 0ceH, 0c4H, 0bcH, 0feH, 0c2H
	DB	0b7H, 0beH, 0b6H, 00H			; `string'
PUBLIC	?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z		; CWinApp::LoadIconA
PUBLIC	?AfxGetApp@@YGPAVCWinApp@@XZ			; AfxGetApp
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?SetPos@CProgressCtrl@@QAEHH@Z			; CProgressCtrl::SetPos
PUBLIC	?SetRange@CProgressCtrl@@QAEXFF@Z		; CProgressCtrl::SetRange
PUBLIC	?SetIcon@CWnd@@QAEPAUHICON__@@PAU2@H@Z		; CWnd::SetIcon
PUBLIC	?Activate@CToolTipCtrl@@QAEXH@Z			; CToolTipCtrl::Activate
PUBLIC	?SetDelayTime@CToolTipCtrl@@QAEXI@Z		; CToolTipCtrl::SetDelayTime
PUBLIC	?SetCurSel@CComboBox@@QAEHH@Z			; CComboBox::SetCurSel
PUBLIC	?IsIconic@CWnd@@QBEHXZ				; CWnd::IsIconic
PUBLIC	?SendMessageA@CWnd@@QBEJIIJ@Z			; CWnd::SendMessageA
PUBLIC	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ		; CDC::GetSafeHdc
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z		; CWnd::GetClientRect
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
PUBLIC	?DrawIcon@CDC@@QAEHHHPAUHICON__@@@Z		; CDC::DrawIcon
PUBLIC	?ResetContent@CComboBox@@QAEXXZ			; CComboBox::ResetContent
PUBLIC	?AddString@CComboBox@@QAEHPBD@Z			; CComboBox::AddString
PUBLIC	?GetCurSel@CComboBox@@QBEHXZ			; CComboBox::GetCurSel
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
PUBLIC	?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
PUBLIC	?AddString@CListBox@@QAEHPBD@Z			; CListBox::AddString
PUBLIC	?SetCurSel@CListBox@@QAEHH@Z			; CListBox::SetCurSel
PUBLIC	?GetCount@CListBox@@QBEHXZ			; CListBox::GetCount
PUBLIC	?UpdateWindow@CWnd@@QAEXXZ			; CWnd::UpdateWindow
PUBLIC	?OnDropFiles@CWnd@@IAEXPAUHDROP__@@@Z		; CWnd::OnDropFiles
PUBLIC	?RelayEvent@CToolTipCtrl@@QAEXPAUtagMSG@@@Z	; CToolTipCtrl::RelayEvent
PUBLIC	_sscanf_s
PUBLIC	_vsscanf_s
PUBLIC	__vsscanf_s_l
PUBLIC	___local_stdio_scanf_options
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
PUBLIC	?Create@CDialog@@UAEHIPAVCWnd@@@Z		; CDialog::Create
PUBLIC	??0?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Func_base@_NHH@std@@QAE@XZ		; std::_Func_base<bool,int,int>::_Func_base<bool,int,int>
PUBLIC	??0?$_Func_base@_NH@std@@QAE@XZ			; std::_Func_base<bool,int>::_Func_base<bool,int>
PUBLIC	??$_Deallocate@$03$0A@@std@@YAXPAXI@Z		; std::_Deallocate<4,0>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??$move@AAV?$_Func_class@_NH@std@@@std@@YA$$QAV?$_Func_class@_NH@0@AAV10@@Z ; std::move<std::_Func_class<bool,int> &>
PUBLIC	??$move@AAV?$_Func_class@_NHH@std@@@std@@YA$$QAV?$_Func_class@_NHH@0@AAV10@@Z ; std::move<std::_Func_class<bool,int,int> &>
PUBLIC	??$move@AAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ; std::move<std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Reset_move@?$_Func_class@_NH@std@@IAEX$$QAV12@@Z ; std::_Func_class<bool,int>::_Reset_move
PUBLIC	?_Reset_move@?$_Func_class@_NHH@std@@IAEX$$QAV12@@Z ; std::_Func_class<bool,int,int>::_Reset_move
PUBLIC	?_Reset_move@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV12@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Reset_move
PUBLIC	?_Swap@?$_Func_class@_NH@std@@IAEXAAV12@@Z	; std::_Func_class<bool,int>::_Swap
PUBLIC	?_Swap@?$_Func_class@_NHH@std@@IAEXAAV12@@Z	; std::_Func_class<bool,int,int>::_Swap
PUBLIC	?_Swap@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXAAV12@@Z ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Swap
PUBLIC	?swap@?$function@$$A6A_NH@Z@std@@QAEXAAV12@@Z	; std::function<bool __cdecl(int)>::swap
PUBLIC	?swap@?$function@$$A6A_NHH@Z@std@@QAEXAAV12@@Z	; std::function<bool __cdecl(int,int)>::swap
PUBLIC	?swap@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEXAAV12@@Z ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::swap
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
PUBLIC	?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::updateFilePath
PUBLIC	?PreTranslateMessage@CThatboyEncryptFileEncoderDlg@@UAEHPAUtagMSG@@@Z ; CThatboyEncryptFileEncoderDlg::PreTranslateMessage
PUBLIC	?OnDropFiles@CThatboyEncryptFileEncoderDlg@@QAEXPAUHDROP__@@@Z ; CThatboyEncryptFileEncoderDlg::OnDropFiles
PUBLIC	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
PUBLIC	?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ ; CThatboyEncryptFileEncoderDlg::OnBnClickedDecrypt
PUBLIC	?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ ; CThatboyEncryptFileEncoderDlg::OnBnClickedEncrypt
PUBLIC	?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedDeviceBind
PUBLIC	?OnBnClickedNeedPassword@CThatboyEncryptFileEncoderDlg@@QAEXXZ ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedPassword
PUBLIC	?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ ; CThatboyEncryptFileEncoderDlg::OnBnClickedBrower
PUBLIC	?OnQueryDragIcon@CThatboyEncryptFileEncoderDlg@@IAEPAUHICON__@@XZ ; CThatboyEncryptFileEncoderDlg::OnQueryDragIcon
PUBLIC	?OnPaint@CThatboyEncryptFileEncoderDlg@@IAEXXZ	; CThatboyEncryptFileEncoderDlg::OnPaint
PUBLIC	?OnInitDialog@CThatboyEncryptFileEncoderDlg@@MAEHXZ ; CThatboyEncryptFileEncoderDlg::OnInitDialog
PUBLIC	?GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ ; CThatboyEncryptFileEncoderDlg::GetThisMessageMap
PUBLIC	?GetMessageMap@CThatboyEncryptFileEncoderDlg@@MBEPBUAFX_MSGMAP@@XZ ; CThatboyEncryptFileEncoderDlg::GetMessageMap
PUBLIC	?DoDataExchange@CThatboyEncryptFileEncoderDlg@@MAEXPAVCDataExchange@@@Z ; CThatboyEncryptFileEncoderDlg::DoDataExchange
PUBLIC	??_GCThatboyEncryptFileEncoderDlg@@UAEPAXI@Z	; CThatboyEncryptFileEncoderDlg::`scalar deleting destructor'
PUBLIC	??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z ; CThatboyEncryptFileEncoderDlg::CThatboyEncryptFileEncoderDlg
EXTRN	??_ECThatboyEncryptFileEncoderDlg@@UAEPAXI@Z:PROC ; CThatboyEncryptFileEncoderDlg::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 019930522H
	DD	01bH
	DD	FLAT:__unwindtable$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 013H
	DD	018H
	DD	019H
	DD	01H
	DD	FLAT:__catchsym$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$33
__unwindtable$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$8
	DD	06H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$9
	DD	07H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$10
	DD	08H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$11
	DD	09H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$12
	DD	0aH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$16
	DD	0dH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$17
	DD	0eH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$18
	DD	0fH
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$19
	DD	010H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$20
	DD	011H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$21
	DD	012H
	DD	00H
	DD	013H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$22
	DD	014H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$23
	DD	015H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$24
	DD	016H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$25
	DD	013H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$24
	DD	012H
	DD	00H
	DD	012H
	DD	FLAT:__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$28
__catchsym$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$33 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 019930522H
	DD	020H
	DD	FLAT:__unwindtable$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	02H
	DD	FLAT:__tryblocktable$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$8
	DD	04H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$9
	DD	05H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$10
	DD	06H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$11
	DD	07H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$12
	DD	08H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$13
	DD	09H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$14
	DD	0aH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$15
	DD	0bH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$18
	DD	0dH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$19
	DD	0eH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$20
	DD	0fH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$21
	DD	010H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$22
	DD	011H
	DD	00H
	DD	012H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$23
	DD	013H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$24
	DD	011H
	DD	00H
	DD	011H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$30
	DD	011H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$31
	DD	017H
	DD	00H
	DD	018H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$32
	DD	019H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$33
	DD	01aH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$34
	DD	01bH
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$35
	DD	018H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$34
	DD	017H
	DD	00H
	DD	017H
	DD	FLAT:__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$38
__tryblocktable$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ DD 012H
	DD	014H
	DD	015H
	DD	01H
	DD	FLAT:__catchsym$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$45
	DD	018H
	DD	01dH
	DD	01eH
	DD	01H
	DD	FLAT:__catchsym$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$46
__catchsym$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$45 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0
__catchsym$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z$0
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pParent$dead$ = 8					; size = 4
??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z PROC	; CThatboyEncryptFileEncoderDlg::CThatboyEncryptFileEncoderDlg, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 21   : 	: CDialogEx(IDDTEF_THATBOYENCRYPTFILEENCODER_DIALOG, pParent)

	push	0
	push	102					; 00000066H
	call	DWORD PTR __imp_??0CDialogEx@@QAE@IPAVCWnd@@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 22   : {

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi], OFFSET ??_7CThatboyEncryptFileEncoderDlg@@6B@
	call	DWORD PTR __imp_??0CToolTipCtrl@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 19   : 	{ return afxCurrentWinApp; }

	call	DWORD PTR __imp_?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 1054 : 	{ return ::LoadIconW(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),

	push	128					; 00000080H
	push	14					; 0000000eH
	push	128					; 00000080H
	call	DWORD PTR __imp_?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 23   : 	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	mov	DWORD PTR [esi+208], eax

; 24   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CDialogEx@@UAE@XZ
__unwindfunclet$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	jmp	DWORD PTR __imp_??1CToolTipCtrl@@UAE@XZ
__ehhandler$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CThatboyEncryptFileEncoderDlg@@QAE@PAVCWnd@@@Z ENDP	; CThatboyEncryptFileEncoderDlg::CThatboyEncryptFileEncoderDlg
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afx.inl
;	COMDAT ??_GCThatboyEncryptFileEncoderDlg@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCThatboyEncryptFileEncoderDlg@@UAEPAXI@Z PROC	; CThatboyEncryptFileEncoderDlg::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 130  : 	{ }

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+216]
	call	DWORD PTR __imp_??1CToolTipCtrl@@UAE@XZ
	lea	ecx, DWORD PTR [esi+192]
	call	DWORD PTR __imp_??1CDialogImpl@@MAE@XZ
	lea	ecx, DWORD PTR [esi+180]
	mov	DWORD PTR [ecx], OFFSET ??_7CBrush@@6B@
	call	??1CGdiObject@@UAE@XZ			; CGdiObject::~CGdiObject
	mov	ecx, esi
	call	DWORD PTR __imp_??1CDialog@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	test	al, 1
	je	SHORT $LN18@scalar
	test	al, 4
	jne	SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN3@scalar:
	push	376					; 00000178H
	push	esi
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN18@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCThatboyEncryptFileEncoderDlg@@UAEPAXI@Z ENDP	; CThatboyEncryptFileEncoderDlg::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?DoDataExchange@CThatboyEncryptFileEncoderDlg@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_pDX$ = 8						; size = 4
?DoDataExchange@CThatboyEncryptFileEncoderDlg@@MAEXPAVCDataExchange@@@Z PROC ; CThatboyEncryptFileEncoderDlg::DoDataExchange, COMDAT
; _this$ = ecx

; 28   : 	CDialogEx::DoDataExchange(pDX);
; 29   : }

	ret	4
?DoDataExchange@CThatboyEncryptFileEncoderDlg@@MAEXPAVCDataExchange@@@Z ENDP ; CThatboyEncryptFileEncoderDlg::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?GetMessageMap@CThatboyEncryptFileEncoderDlg@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetMessageMap@CThatboyEncryptFileEncoderDlg@@MBEPBUAFX_MSGMAP@@XZ PROC ; CThatboyEncryptFileEncoderDlg::GetMessageMap, COMDAT
; _this$ = ecx

; 31   : BEGIN_MESSAGE_MAP(CThatboyEncryptFileEncoderDlg, CDialogEx)

	mov	eax, OFFSET ?messageMap@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4U3@B
	ret	0
?GetMessageMap@CThatboyEncryptFileEncoderDlg@@MBEPBUAFX_MSGMAP@@XZ ENDP ; CThatboyEncryptFileEncoderDlg::GetMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ PROC ; CThatboyEncryptFileEncoderDlg::GetThisMessageMap, COMDAT

; 32   : 	ON_WM_PAINT()
; 33   : 	ON_WM_QUERYDRAGICON()
; 34   : 	ON_BN_CLICKED(IDCTEF_BROWER, &CThatboyEncryptFileEncoderDlg::OnBnClickedBrower)
; 35   : 	ON_BN_CLICKED(IDCTEF_NEEDPASSWORD, &CThatboyEncryptFileEncoderDlg::OnBnClickedNeedPassword)
; 36   : 	ON_BN_CLICKED(IDCTEF_NEEDDEVICEBIND, &CThatboyEncryptFileEncoderDlg::OnBnClickedNeedDeviceBind)
; 37   : 	ON_BN_CLICKED(IDCTEF_ENCRYPT, &CThatboyEncryptFileEncoderDlg::OnBnClickedEncrypt)
; 38   : 	ON_BN_CLICKED(IDCTEF_DECRYPT, &CThatboyEncryptFileEncoderDlg::OnBnClickedDecrypt)
; 39   : 	ON_WM_DROPFILES()
; 40   : END_MESSAGE_MAP()

	mov	eax, OFFSET ?messageMap@?1??GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ@4U3@B
	ret	0
?GetThisMessageMap@CThatboyEncryptFileEncoderDlg@@KGPBUAFX_MSGMAP@@XZ ENDP ; CThatboyEncryptFileEncoderDlg::GetThisMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnInitDialog@CThatboyEncryptFileEncoderDlg@@MAEHXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -92					; size = 4
$T44 = -88						; size = 40
$T23 = -88						; size = 40
$T2 = -88						; size = 40
__Temp$66 = -48						; size = 40
__Temp$67 = -48						; size = 40
__Temp$68 = -48						; size = 40
__$ArrayPad$ = -4					; size = 4
?OnInitDialog@CThatboyEncryptFileEncoderDlg@@MAEHXZ PROC ; CThatboyEncryptFileEncoderDlg::OnInitDialog, COMDAT
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$GSCopy$1$[esp+104], esi

; 47   : 	CDialogEx::OnInitDialog();

	call	DWORD PTR __imp_?OnInitDialog@CDialog@@UAEHXZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 262  : 	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }

	push	DWORD PTR [esi+208]
	mov	ebx, DWORD PTR __imp__SendMessageA@16
	push	1
	push	128					; 00000080H
	push	DWORD PTR [esi+32]
	call	ebx
	push	DWORD PTR [esi+208]
	push	0
	push	128					; 00000080H
	push	DWORD PTR [esi+32]
	call	ebx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 55   : 	EnableToolTips();

	push	1
	mov	ecx, esi
	call	DWORD PTR __imp_?EnableToolTips@CWnd@@QAEHH@Z

; 56   : 	toolTip.Create(this);

	mov	eax, DWORD PTR [esi+216]
	lea	edi, DWORD PTR [esi+216]
	push	0
	push	esi
	mov	ecx, edi
	call	DWORD PTR [eax+364]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 425  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L); }

	push	0
	push	1
	push	1025					; 00000401H
	push	DWORD PTR [esi+248]
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 278  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay); }

	push	150					; 00000096H
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [esi+248]
	call	ebx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 60   : 	toolTip.AddTool(GetDlgItem(IDCTEF_FILEPATH), "");

	push	0
	push	0
	push	OFFSET ??_C@_08DBHNDAEH@?N?D?$LM?$PO?B?$LH?$LO?$LG@
	mov	ecx, esi
	mov	esi, DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	push	1000					; 000003e8H
	call	esi
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?AddTool@CToolTipCtrl@@QAEHPAVCWnd@@PBDPBUtagRECT@@I@Z

; 61   : 	// 960
; 62   : 	((CComboBox*)GetDlgItem(IDCTEF_CHUNKDATASIZE))->SetCurSel(3);

	mov	edi, DWORD PTR _this$GSCopy$1$[esp+104]
	mov	ecx, edi
	push	1009					; 000003f1H
	call	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 767  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }

	push	0
	push	3
	push	334					; 0000014eH
	push	DWORD PTR [eax+32]
	call	ebx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 64   : 	((CComboBox*)GetDlgItem(IDCTEF_CRC32TYPE))->SetCurSel(10);

	push	1011					; 000003f3H
	mov	ecx, edi
	call	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 767  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }

	push	0
	push	10					; 0000000aH
	push	334					; 0000014eH
	push	DWORD PTR [eax+32]
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T2[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T2[esp+104], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR $T2[esp+140], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T2[esp+104]
	lea	eax, DWORD PTR __Temp$68[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T2[esp+108], edi

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	push	eax

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$68[esp+144], 0

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	call	?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T2[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$68[esp+140], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN52@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T2[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$68[esp+140]
	xor	ecx, ecx
	mov	DWORD PTR $T2[esp+140], ecx
$LN52@OnInitDial:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN61@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN60@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T2[esp+104]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T2[esp+140], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN306@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]
	cmp	esi, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T2[esp+140]
	mov	edx, DWORD PTR __Temp$68[esp+140]
	jmp	SHORT $LN312@OnInitDial
$LN306@OnInitDial:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$68[esp+140]
	jmp	SHORT $LN61@OnInitDial
$LN60@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T2[esp+140], ecx
$LN312@OnInitDial:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
$LN61@OnInitDial:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN93@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$68[esp+104]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN76@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$68[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN307@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$68[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN307@OnInitDial:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T2[esp+140]
	jmp	SHORT $LN93@OnInitDial
$LN76@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, edx
$LN93@OnInitDial:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN105@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T2[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN105@OnInitDial:

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T23[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T23[esp+104], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR $T23[esp+140], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T23[esp+104]
	lea	eax, DWORD PTR __Temp$67[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T23[esp+108], edi

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	push	eax

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$67[esp+144], 0

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	call	?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T23[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$67[esp+140], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN147@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T23[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$67[esp+140]
	xor	ecx, ecx
	mov	DWORD PTR $T23[esp+140], ecx
$LN147@OnInitDial:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN156@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN155@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T23[esp+104]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T23[esp+140], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN308@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]
	cmp	esi, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T23[esp+140]
	mov	edx, DWORD PTR __Temp$67[esp+140]
	jmp	SHORT $LN313@OnInitDial
$LN308@OnInitDial:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$67[esp+140]
	jmp	SHORT $LN156@OnInitDial
$LN155@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T23[esp+140], ecx
$LN313@OnInitDial:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
$LN156@OnInitDial:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN188@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$67[esp+104]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN171@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$67[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN309@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$67[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN309@OnInitDial:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T23[esp+140]
	jmp	SHORT $LN188@OnInitDial
$LN171@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, edx
$LN188@OnInitDial:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN200@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T23[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN200@OnInitDial:

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T44[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T44[esp+104], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR $T44[esp+140], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T44[esp+104]
	lea	eax, DWORD PTR __Temp$66[esp+104]

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T44[esp+108], edi

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	push	eax

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$66[esp+144], 0

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	call	?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T44[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$66[esp+140], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN242@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T44[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$66[esp+140]
	xor	ecx, ecx
	mov	DWORD PTR $T44[esp+140], ecx
$LN242@OnInitDial:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN251@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN250@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T44[esp+104]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T44[esp+140], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN310@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]
	cmp	esi, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T44[esp+140]
	mov	edx, DWORD PTR __Temp$66[esp+140]
	jmp	SHORT $LN314@OnInitDial
$LN310@OnInitDial:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$66[esp+140]
	jmp	SHORT $LN251@OnInitDial
$LN250@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T44[esp+140], ecx
$LN314@OnInitDial:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
$LN251@OnInitDial:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN283@OnInitDial

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$66[esp+104]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN266@OnInitDial

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$66[esp+140]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN311@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$66[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN311@OnInitDial:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T44[esp+140]
	jmp	SHORT $LN283@OnInitDial
$LN266@OnInitDial:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, edx
$LN283@OnInitDial:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN295@OnInitDial

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T44[esp+104]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN295@OnInitDial:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 19   : 	{ return afxCurrentWinApp; }

	call	DWORD PTR __imp_?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 83   : 	updateFilePath(AfxGetApp()->m_lpCmdLine);	

	push	ecx
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 19   : 	{ return afxCurrentWinApp; }

	mov	eax, DWORD PTR [eax+4]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 83   : 	updateFilePath(AfxGetApp()->m_lpCmdLine);	

	push	DWORD PTR [eax+72]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, edi
	call	?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::updateFilePath

; 84   : 
; 85   : 	//HMODULE hSkinBase = GetModuleHandle("SkinH.dll");
; 86   : 	//unsigned char* pPatchByte = NULL;
; 87   : 	//DWORD dwOldProtect = 0;
; 88   : 	//if (hSkinBase == NULL)
; 89   : 	//{
; 90   : 	//	return TRUE;
; 91   : 	//}
; 92   : 	////10021632       55                   push    ebp
; 93   : 	//pPatchByte = (unsigned char*)((DWORD)hSkinBase + 0x00021632);
; 94   : 	//VirtualProtectEx(GetCurrentProcess(), pPatchByte, 4, PAGE_EXECUTE_READWRITE, &dwOldProtect);
; 95   : 	//*pPatchByte = 0x50;
; 96   : 
; 97   : 	////1000F37F       52                   push    edx
; 98   : 	//pPatchByte = (unsigned char*)((DWORD)hSkinBase + 0x0000F37F);
; 99   : 	//VirtualProtectEx(GetCurrentProcess(), pPatchByte, 4, PAGE_EXECUTE_READWRITE, &dwOldProtect);
; 100  : 	//*pPatchByte = 0x50;
; 101  : 
; 102  : 	SkinH_AttachEx(TEXT(R"(Wood.she)"), nullptr);

	push	0
	push	OFFSET ??_C@_08LBKAJPNE@Wood?4she@
	call	DWORD PTR __imp__SkinH_AttachEx@8

; 103  : 
; 104  : 
; 105  : 
; 106  : 
; 107  : 	return TRUE;  //  TRUE
; 108  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?OnInitDialog@CThatboyEncryptFileEncoderDlg@@MAEHXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnInitDialog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??R<lambda_f74fcfde5f7b784984846d3120ae874c>@@QBE_NH@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??R<lambda_f74fcfde5f7b784984846d3120ae874c>@@QBE_NH@Z PROC ; <lambda_f74fcfde5f7b784984846d3120ae874c>::operator(), COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	mov	ecx, DWORD PTR [ecx]
	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	0
	push	DWORD PTR _pos$[ebp]
	push	1026					; 00000402H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 69   : 		return true;

	mov	al, 1

; 70   : 	};

	pop	ebp
	ret	4
??R<lambda_f74fcfde5f7b784984846d3120ae874c>@@QBE_NH@Z ENDP ; <lambda_f74fcfde5f7b784984846d3120ae874c>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0<lambda_f74fcfde5f7b784984846d3120ae874c>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_f74fcfde5f7b784984846d3120ae874c>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z PROC ; <lambda_f74fcfde5f7b784984846d3120ae874c>::<lambda_f74fcfde5f7b784984846d3120ae874c>, COMDAT
; _this$ = ecx

; 70   : 	};

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_f74fcfde5f7b784984846d3120ae874c>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z ENDP ; <lambda_f74fcfde5f7b784984846d3120ae874c>::<lambda_f74fcfde5f7b784984846d3120ae874c>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??R<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QBE_NHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
??R<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QBE_NHH@Z PROC ; <lambda_1fa47c227cca097ed6ab7fabc557d9e4>::operator(), COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	mov	ecx, DWORD PTR [ecx]
	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	movzx	edx, WORD PTR _max$[ebp]
	movzx	ecx, WORD PTR _min$[ebp]
	shl	edx, 16					; 00000010H
	or	edx, ecx
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 74   : 		return true;

	mov	al, 1

; 75   : 	};

	pop	ebp
	ret	8
??R<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QBE_NHH@Z ENDP ; <lambda_1fa47c227cca097ed6ab7fabc557d9e4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z PROC ; <lambda_1fa47c227cca097ed6ab7fabc557d9e4>::<lambda_1fa47c227cca097ed6ab7fabc557d9e4>, COMDAT
; _this$ = ecx

; 75   : 	};

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z ENDP ; <lambda_1fa47c227cca097ed6ab7fabc557d9e4>::<lambda_1fa47c227cca097ed6ab7fabc557d9e4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??R<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QBE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??R<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QBE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; <lambda_880880f1ed3b8a16ebddcbf735e0f1c5>::operator(), COMDAT
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _str$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 77   : 	{

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [eax]
$LN7@operator:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 78   : 		pushInfo(str.c_str());

	push	ecx
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 79   : 		return true;

	mov	al, 1

; 80   : 	};

	pop	esi
	pop	ebp
	ret	4
??R<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QBE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; <lambda_880880f1ed3b8a16ebddcbf735e0f1c5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z PROC ; <lambda_880880f1ed3b8a16ebddcbf735e0f1c5>::<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>, COMDAT
; _this$ = ecx

; 80   : 	};

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@QAE@QAVCThatboyEncryptFileEncoderDlg@@@Z ENDP ; <lambda_880880f1ed3b8a16ebddcbf735e0f1c5>::<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnPaint@CThatboyEncryptFileEncoderDlg@@IAEXXZ
_TEXT	SEGMENT
_rect$2 = -112						; size = 16
_dc$3 = -96						; size = 84
__$ArrayPad$ = -4					; size = 4
?OnPaint@CThatboyEncryptFileEncoderDlg@@IAEXXZ PROC	; CThatboyEncryptFileEncoderDlg::OnPaint, COMDAT
; _this$ = ecx

; 115  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+116], eax
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 69   : 	{ ASSERT(::IsWindow(m_hWnd)); return ::IsIconic(m_hWnd); }

	push	DWORD PTR [ebx+32]
	call	DWORD PTR __imp__IsIconic@4
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 116  : 	if (IsIconic())

	test	eax, eax
	je	$LN2@OnPaint

; 117  : 	{
; 118  : 		CPaintDC dc(this); // 

	push	ebx
	lea	ecx, DWORD PTR _dc$3[esp+132]
	call	DWORD PTR __imp_??0CPaintDC@@QAE@PAVCWnd@@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 32   : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, message, wParam, lParam); }

	push	0
	push	DWORD PTR _dc$3[esp+136]
	push	39					; 00000027H
	push	DWORD PTR [ebx+32]
	call	DWORD PTR __imp__SendMessageA@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 123  : 		int cxIcon = GetSystemMetrics(SM_CXICON);

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	11					; 0000000bH
	call	esi

; 124  : 		int cyIcon = GetSystemMetrics(SM_CYICON);

	push	12					; 0000000cH
	mov	edi, eax
	call	esi
	mov	esi, eax
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 86   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

	lea	eax, DWORD PTR _rect$2[esp+128]
	push	eax
	push	DWORD PTR [ebx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltypes.h

; 528  : 	left = 0;

	movups	XMMWORD PTR _rect$2[esp+136], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 86   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

	call	DWORD PTR __imp__GetClientRect@8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 482  : 	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }

	mov	eax, DWORD PTR _rect$2[esp+140]
	sub	eax, DWORD PTR _rect$2[esp+132]
	push	DWORD PTR [ebx+208]
	sub	eax, esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 128  : 		int y = (rect.Height() - cyIcon + 1) / 2;

	inc	eax
	cdq
	sub	eax, edx
	sar	eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 482  : 	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }

	push	eax
	mov	eax, DWORD PTR _rect$2[esp+144]
	sub	eax, DWORD PTR _rect$2[esp+136]
	sub	eax, edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 127  : 		int x = (rect.Width() - cxIcon + 1) / 2;

	inc	eax
	cdq
	sub	eax, edx
	sar	eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl

; 482  : 	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }

	push	eax
	push	DWORD PTR _dc$3[esp+144]
	call	DWORD PTR __imp__DrawIcon@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 132  : 	}

	lea	ecx, DWORD PTR _dc$3[esp+128]
	call	DWORD PTR __imp_??1CPaintDC@@UAE@XZ

; 136  : 	}
; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@OnPaint:

; 133  : 	else
; 134  : 	{
; 135  : 		CDialogEx::OnPaint();

	mov	ecx, ebx
	call	DWORD PTR __imp_?OnPaint@CDialog@@IAEXXZ

; 136  : 	}
; 137  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?OnPaint@CThatboyEncryptFileEncoderDlg@@IAEXXZ ENDP	; CThatboyEncryptFileEncoderDlg::OnPaint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnQueryDragIcon@CThatboyEncryptFileEncoderDlg@@IAEPAUHICON__@@XZ
_TEXT	SEGMENT
?OnQueryDragIcon@CThatboyEncryptFileEncoderDlg@@IAEPAUHICON__@@XZ PROC ; CThatboyEncryptFileEncoderDlg::OnQueryDragIcon, COMDAT
; _this$ = ecx

; 143  : 	return static_cast<HCURSOR>(m_hIcon);

	mov	eax, DWORD PTR [ecx+208]

; 144  : }

	ret	0
?OnQueryDragIcon@CThatboyEncryptFileEncoderDlg@@IAEPAUHICON__@@XZ ENDP ; CThatboyEncryptFileEncoderDlg::OnQueryDragIcon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ
_TEXT	SEGMENT
_fileDlg$ = -752					; size = 736
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ PROC ; CThatboyEncryptFileEncoderDlg::OnBnClickedBrower, COMDAT
; _this$ = ecx

; 149  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 744				; 000002e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 150  : 	UpdateData(TRUE);

	push	1
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z

; 151  : 	CFileDialog fileDlg(TRUE, nullptr, nullptr, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 0, this);

	push	1
	push	0
	push	edi
	push	0
	push	6
	push	0
	push	0
	push	1
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_??0CFileDialog@@QAE@HPBD0K0PAVCWnd@@KH@Z

; 152  : 	fileDlg.m_ofn.lpstrTitle = "";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?GetOFN@CFileDialog@@QAEAAUtagOFNA@@XZ

; 153  : 	fileDlg.m_ofn.lpstrFilter = "TEF(*.tef)\0*.tef\0(*.*)\0*.*\0\0";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+48], OFFSET ??_C@_08DGPLIAJK@?$LE?r?$LP?$KK?N?D?$LM?$PO@
	call	DWORD PTR __imp_?GetOFN@CFileDialog@@QAEAAUtagOFNA@@XZ

; 154  : 	if (IDOK == fileDlg.DoModal())

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+12], OFFSET ??_C@_0CN@BIAAHMID@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?K?y?S?P?N?D@
	call	DWORD PTR __imp_?DoModal@CFileDialog@@UAEHXZ
	cmp	eax, 1
	jne	SHORT $LN2@OnBnClicke

; 155  : 	{
; 156  : 		updateFilePath(fileDlg.GetPathName());

	push	ecx
	push	esp
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_?GetPathName@CFileDialog@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
	mov	ecx, edi
	call	?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::updateFilePath

; 157  : 		UpdateData(FALSE);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z
$LN2@OnBnClicke:

; 158  : 	}
; 159  : }

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0:
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	jmp	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
__ehhandler$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-752]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnBnClickedBrower@CThatboyEncryptFileEncoderDlg@@QAEXXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnBnClickedBrower
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnBnClickedNeedPassword@CThatboyEncryptFileEncoderDlg@@QAEXXZ
_TEXT	SEGMENT
?OnBnClickedNeedPassword@CThatboyEncryptFileEncoderDlg@@QAEXXZ PROC ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedPassword, COMDAT
; _this$ = ecx

; 163  : {

	push	esi

; 164  : 	UpdateData(TRUE);

	push	1
	mov	esi, ecx
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z

; 165  : 	GetDlgItem(IDCTEF_PASSWORD)->EnableWindow(IsDlgButtonChecked(IDCTEF_NEEDPASSWORD) == BST_CHECKED);

	push	1005					; 000003edH
	mov	ecx, esi
	call	DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	dec	eax
	mov	ecx, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	push	eax
	push	1004					; 000003ecH
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?EnableWindow@CWnd@@QAEHH@Z
	pop	esi

; 166  : }

	ret	0
?OnBnClickedNeedPassword@CThatboyEncryptFileEncoderDlg@@QAEXXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedPassword
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ
_TEXT	SEGMENT
_deviceSerialStringList$3 = -32				; size = 12
_this$1$ = -20						; size = 4
_deviceSerialComboBox$1$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ PROC ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedDeviceBind, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 171  : 	UpdateData(TRUE);

	push	1
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z

; 172  : 	GetDlgItem(IDCTEF_DEVICESERIAL)->EnableWindow(IsDlgButtonChecked(IDCTEF_NEEDDEVICEBIND) == BST_CHECKED);

	mov	esi, DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	mov	ecx, ebx
	push	1006					; 000003eeH
	call	esi
	mov	edi, DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	dec	eax
	neg	eax
	mov	ecx, ebx
	sbb	eax, eax
	inc	eax
	push	eax
	push	1007					; 000003efH
	call	edi
	mov	ecx, eax
	call	DWORD PTR __imp_?EnableWindow@CWnd@@QAEHH@Z

; 173  : 	if (IsDlgButtonChecked(IDCTEF_NEEDDEVICEBIND) == BST_CHECKED)

	push	1006					; 000003eeH
	mov	ecx, ebx
	call	esi
	cmp	eax, 1
	jne	$LN28@OnBnClicke
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _deviceSerialStringList$3[ebp], 0
	mov	DWORD PTR _deviceSerialStringList$3[ebp+4], 0
	mov	DWORD PTR _deviceSerialStringList$3[ebp+8], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 176  : 		thatboy::USBMassStorageDeviceSerial::getUSBMassStorageDeviceList(deviceSerialStringList);

	lea	ecx, DWORD PTR _deviceSerialStringList$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; thatboy::USBMassStorageDeviceSerial::getUSBMassStorageDeviceList

; 177  : 		CComboBox& deviceSerialComboBox = *(CComboBox*)GetDlgItem(IDCTEF_DEVICESERIAL);

	push	1007					; 000003efH
	mov	ecx, ebx
	call	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 801  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }

	push	0
	push	0
	push	331					; 0000014bH
	push	DWORD PTR [eax+32]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 177  : 		CComboBox& deviceSerialComboBox = *(CComboBox*)GetDlgItem(IDCTEF_DEVICESERIAL);

	mov	DWORD PTR _deviceSerialComboBox$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 801  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }

	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	edi, DWORD PTR _deviceSerialStringList$3[ebp]
	mov	esi, edi
	mov	ebx, DWORD PTR _deviceSerialStringList$3[ebp+4]
	cmp	esi, ebx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 179  : 		for (auto& serial : deviceSerialStringList)

	je	SHORT $LN3@OnBnClicke
	mov	edi, DWORD PTR _deviceSerialComboBox$1$[ebp]
$LL4@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN19@OnBnClicke

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN19@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 795  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }

	push	eax
	push	0
	push	323					; 00000143H
	push	DWORD PTR [edi+32]
	call	DWORD PTR __imp__SendMessageA@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 179  : 		for (auto& serial : deviceSerialStringList)

	add	esi, 24					; 00000018H
	cmp	esi, ebx
	jne	SHORT $LL4@OnBnClicke
	mov	edi, DWORD PTR _deviceSerialStringList$3[ebp]
$LN3@OnBnClicke:

; 180  : 			deviceSerialComboBox.AddString(serial.c_str());
; 181  : 		UpdateData(FALSE);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	test	edi, edi
	je	SHORT $LN28@OnBnClicke

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	push	ecx
	mov	edx, ebx
	mov	ecx, edi
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR _deviceSerialStringList$3[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edi

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, edi
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN46@OnBnClicke

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edi, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H
	sub	eax, edi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN46@OnBnClicke
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN46@OnBnClicke:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN28@OnBnClicke:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 183  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@OnBnClicke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0:
	lea	ecx, DWORD PTR _deviceSerialStringList$3[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnBnClickedNeedDeviceBind@CThatboyEncryptFileEncoderDlg@@QAEXXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnBnClickedNeedDeviceBind
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
_TEXT	SEGMENT
$T15 = -860						; size = 4
$T10 = -856						; size = 4
$T8 = -852						; size = 4
_this$GSCopy$ = -848					; size = 4
_chunkDataSize$1$ = -844				; size = 4
$T21 = -836						; size = 4
$T12 = -836						; size = 4
_password$25 = -832					; size = 4
_deviceSerial$26 = -828					; size = 4
_chunkSize$27 = -824					; size = 4
_filePath$ = -820					; size = 4
tv966 = -813						; size = 1
_fileDlg$ = -812					; size = 736
_EncryptErrorCodeString$ = -76				; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ PROC ; CThatboyEncryptFileEncoderDlg::OnBnClickedEncrypt, COMDAT
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 848				; 00000350H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 188  : 	const CString EncryptErrorCodeString[]
; 189  : 	{
; 190  : 		""

	push	OFFSET ??_C@_04FHCNAFFK@?$LD?I?$LJ?$KG@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp]
	mov	DWORD PTR _this$GSCopy$[ebp], edi
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 191  : 		,""

	push	OFFSET ??_C@_08KNJFAAFE@?$LC?Y?W?w?V?P?$LG?O@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+4]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 192  : 		,""

	push	OFFSET ??_C@_0N@LMLCADBC@?N?D?$LM?$PO?$LE?r?$LP?$KK?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+8]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 193  : 		,""

	push	OFFSET ??_C@_0N@EHGMKEHD@?N?D?$LM?$PO?$MA?$OA?P?M?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+12]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 194  : 		,""

	push	OFFSET ??_C@_0L@BLBNHGNN@?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+16]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 195  : 		,""

	push	OFFSET ??_C@_0L@NHOEFCGM@?C?$NM?B?k?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+20]
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 196  : 		,""

	push	OFFSET ??_C@_0L@EGNECDJP@?I?h?$LB?$LI?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+24]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 197  : 		,""

	push	OFFSET ??_C@_08DEIJEIHL@?P?h?R?$KK?C?$NM?B?k@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+28]
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 198  : 		,""

	push	OFFSET ??_C@_08MGFBOHLC@?P?h?R?$KK?I?h?$LB?$LI@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+32]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 199  : 		,"CRC"

	push	OFFSET ??_C@_0M@BHIMCPO@CRC?P?$KD?Q?i?J?$KH?$LA?$NM@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+36]
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 200  : 		,"Base64"

	push	OFFSET ??_C@_0P@HHKGKONE@Base64?$LN?b?B?k?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+40]
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 201  : 		,""

	push	OFFSET ??_C@_08ECNGDOBK@?$LE?m?N?s?G?x?$LP?i@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+44]
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 202  : 		,""

	push	OFFSET ??_C@_08BCICBECK@?N?$LE?V?$KK?G?x?$LP?i@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+48]
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 203  : 		,""

	push	OFFSET ??_C@_08COCJNBCE@?N?$LE?V?$KK?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+52]
	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 204  : 	};
; 205  : 	thatboy::EncryptFileDoModal::EncryptErrorCode code;
; 206  : 	CString filePath;

	lea	ecx, DWORD PTR _filePath$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 13		; 0000000dH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 207  : 	GetDlgItemText(IDCTEF_FILEPATH, filePath);

	lea	eax, DWORD PTR _filePath$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 14		; 0000000eH
	mov	ebx, DWORD PTR __imp_?GetDlgItemTextA@CWnd@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	mov	ecx, edi
	push	eax
	push	1000					; 000003e8H
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _filePath$[ebp]

; 533  : 		return( GetLength() == 0 );

	cmp	DWORD PTR [eax-12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 208  : 	if (filePath.IsEmpty())

	jne	SHORT $LN4@OnBnClicke

; 209  : 	{
; 210  : 		MessageBox("", "", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET ??_C@_04FMCPDGOH@?$LE?m?N?s@
	push	OFFSET ??_C@_0BH@BECGLPEJ@?N?$LE?Q?$KB?T?q?N?D?$LM?$PO?$KD?$KM?$LC?Y?W?w?J?$KH?$LA?$NM?$KD?$KB@
	mov	ecx, edi
	call	DWORD PTR __imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z

; 211  : 		return;

	jmp	$LN126@OnBnClicke
$LN4@OnBnClicke:

; 212  : 	}
; 213  : 	CFileDialog fileDlg(FALSE, ".ext", nullptr, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 0, this);

	push	1
	push	0
	push	edi
	push	0
	push	6
	push	0
	push	OFFSET ??_C@_04FKGFBLKM@?4ext@
	push	0
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_??0CFileDialog@@QAE@HPBD0K0PAVCWnd@@KH@Z
	mov	BYTE PTR __$EHRec$[ebp+12], 15		; 0000000fH

; 214  : 	fileDlg.m_ofn.lpstrTitle = "";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	esi, DWORD PTR __imp_?GetOFN@CFileDialog@@QAEAAUtagOFNA@@XZ
	call	esi

; 215  : 	fileDlg.m_ofn.lpstrFilter = "TEF(*.tef)\0*.tef\0\0";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+48], OFFSET ??_C@_08JPHNKIGA@?$LB?$KD?$LE?f?N?D?$LM?$PO@
	call	esi

; 216  : 	if (IDOK == fileDlg.DoModal())

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+12], OFFSET ??_C@_0BL@OKGJOACA@TEF?$LM?S?C?$NM?N?D?$LM?$PO?$CI?$CK?4tef?$CJ?$AA?$CK?4tef?$AA?$AA@
	call	DWORD PTR __imp_?DoModal@CFileDialog@@UAEHXZ
	cmp	eax, 1
	jne	$LN5@OnBnClicke

; 217  : 	{
; 218  : 		CString password;

	lea	ecx, DWORD PTR _password$25[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 219  : 		CString deviceSerial;

	lea	ecx, DWORD PTR _deviceSerial$26[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 220  : 		CString chunkSize;

	lea	ecx, DWORD PTR _chunkSize$27[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 221  : 		GetDlgItemText(IDCTEF_PASSWORD, password);

	lea	eax, DWORD PTR _password$25[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	push	eax
	push	1004					; 000003ecH
	mov	ecx, edi
	call	ebx

; 222  : 		GetDlgItemText(IDCTEF_DEVICESERIAL, deviceSerial);

	lea	eax, DWORD PTR _deviceSerial$26[ebp]
	mov	ecx, edi
	push	eax
	push	1007					; 000003efH
	call	ebx

; 223  : 		GetDlgItemText(IDCTEF_CHUNKDATASIZE, chunkSize);

	lea	eax, DWORD PTR _chunkSize$27[ebp]
	mov	ecx, edi
	push	eax
	push	1009					; 000003f1H
	call	ebx

; 224  : 		size_t chunkDataSize = atoi(chunkSize.GetString());

	push	DWORD PTR _chunkSize$27[ebp]
	call	DWORD PTR __imp__atoi
	add	esp, 4

; 225  : 		if (chunkDataSize == 0)
; 226  : 			chunkDataSize = thatboy::EncryptFileDoModal::defaultChunkDataSize;
; 227  : 
; 228  : 		try

	mov	BYTE PTR __$EHRec$[ebp+12], 19		; 00000013H
	test	eax, eax
	mov	ecx, 3072				; 00000c00H
	cmove	eax, ecx

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	mov	ecx, edi
	push	1006					; 000003eeH
	mov	DWORD PTR _chunkDataSize$1$[ebp], eax
	call	DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	eax, 1
	mov	ebx, esi
	mov	ecx, edi
	cmove	ebx, DWORD PTR _deviceSerial$26[ebp]
	push	1005					; 000003edH
	call	DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	cmp	eax, 1
	mov	ecx, edi
	push	1
	cmove	esi, DWORD PTR _password$25[ebp]
	push	1011					; 000003f3H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

	push	0
	push	0
	push	327					; 00000147H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR tv966[ebp], al
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	ebx

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 20		; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T10[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	esi

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	lea	eax, DWORD PTR $T12[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 21		; 00000015H
	mov	esi, DWORD PTR __imp_?GetPathName@CFileDialog@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	push	eax
	call	esi
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 22		; 00000016H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	mov	ecx, esp
	mov	DWORD PTR $T15[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 23		; 00000017H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 230  : 			code = thatboy::EncryptFileDoModal::Encrypt(

	mov	dl, BYTE PTR tv966[ebp]
	mov	ecx, DWORD PTR _chunkDataSize$1$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 24		; 00000018H
	call	?Encrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000IW4CRC32_TYPE@CRC32@2@_N@Z ; thatboy::EncryptFileDoModal::Encrypt
	add	esp, 100				; 00000064H
	lea	ecx, DWORD PTR $T12[ebp]
	mov	ebx, eax
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], 18		; 00000012H
	test	ebx, ebx
	je	SHORT $LN8@OnBnClicke

; 242  : 		}
; 243  : 		switch (code)

	lea	eax, DWORD PTR [ebx-2]
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN10@OnBnClicke

; 247  : 			break;
; 248  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILEOPENERROR:
; 249  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILETYPEERROR:
; 250  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_VERSIONNOTMATCH:
; 251  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_PASSWORDNOTMATCH:
; 252  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_DEVICENOTMATCH:
; 253  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDPASSWORD:
; 254  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDDEVICE:
; 255  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_CRCCHECKFAILURE:
; 256  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_BASE64ERROR:
; 257  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_ERRORCHUNK:
; 258  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWCHUNK:
; 259  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWERROR:
; 260  : 			pushInfo("" + EncryptErrorCodeString[static_cast<BYTE>(code)]);

	movzx	eax, bl
	lea	edx, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, OFFSET ??_C@_0BJ@MIKHDLPC@?N?D?$LM?$PO?$LM?S?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
	push	eax
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
	jmp	SHORT $LN10@OnBnClicke
$LN8@OnBnClicke:

; 244  : 		{
; 245  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_SUCCESS:
; 246  : 			pushInfo("" + fileDlg.GetPathName());

	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	esi
	push	ecx
	mov	ecx, esp
	mov	BYTE PTR __$EHRec$[ebp+12], 26		; 0000001aH
	push	eax
	mov	edx, OFFSET ??_C@_0BL@FKMFFNGJ@?$LM?S?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
	lea	ecx, DWORD PTR $T21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN10@OnBnClicke:

; 261  : 		default:
; 262  : 			break;
; 263  : 		}
; 264  : 		UpdateData(FALSE);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z
$LN48@OnBnClicke:

; 265  : 	}
; 266  : }

	lea	ecx, DWORD PTR _chunkSize$27[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _deviceSerial$26[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _password$25[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN5@OnBnClicke:
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
$LN126@OnBnClicke:
	lea	ecx, DWORD PTR _filePath$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	eax, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	push	14					; 0000000eH
	push	4
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0:

; 231  : 				filePath.GetString()
; 232  : 				, fileDlg.GetPathName().GetString()
; 233  : 				, IsDlgButtonChecked(IDCTEF_NEEDPASSWORD) == BST_CHECKED ? password.GetString() : ""
; 234  : 				, IsDlgButtonChecked(IDCTEF_NEEDDEVICEBIND) == BST_CHECKED ? deviceSerial.GetString() : ""
; 235  : 				, chunkDataSize
; 236  : 				, thatboy::CRC32::CRC32_TYPE(((CComboBox*)GetDlgItem(IDCTEF_CRC32TYPE))->GetCurSel()));
; 237  : 		}
; 238  : 		catch (...)
; 239  : 		{
; 240  : 			pushInfo("");

	push	ecx
	mov	ecx, esp
	push	OFFSET ??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 241  : 			return;

	mov	eax, $LN48@OnBnClicke
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$2:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$3:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+4]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$4:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+8]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$5:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+12]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$6:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+16]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$7:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+20]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$8:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+24]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$9:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+28]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$10:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+32]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$11:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+36]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$12:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+40]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$13:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+44]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$14:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+48]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$16:
	mov	eax, DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	push	eax
	push	14					; 0000000eH
	push	4
	lea	eax, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$17:
	lea	ecx, DWORD PTR _filePath$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$18:
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	jmp	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$19:
	lea	ecx, DWORD PTR _password$25[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$20:
	lea	ecx, DWORD PTR _deviceSerial$26[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$21:
	lea	ecx, DWORD PTR _chunkSize$27[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$22:
	mov	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$23:
	mov	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$24:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$25:
	mov	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$28:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-864]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnBnClickedEncrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnBnClickedEncrypt
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
_TEXT	SEGMENT
$T31 = -880						; size = 4
$T7 = -880						; size = 4
_this$GSCopy$ = -876					; size = 4
$T29 = -868						; size = 4
$T46 = -864						; size = 4
$T33 = -864						; size = 4
$T9 = -864						; size = 4
tv1630 = -860						; size = 4
$T47 = -860						; size = 4
$T42 = -860						; size = 4
$T36 = -860						; size = 4
_originalFileName$ = -856				; size = 4
tv1619 = -849						; size = 1
_password$ = -848					; size = 4
_deviceSerial$ = -844					; size = 4
_filePath$ = -840					; size = 4
_fileDlg$ = -836					; size = 736
$T20 = -100						; size = 24
_EncryptErrorCodeString$ = -76				; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ PROC ; CThatboyEncryptFileEncoderDlg::OnBnClickedDecrypt, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 868				; 00000364H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 271  : 	const CString EncryptErrorCodeString[]
; 272  : 	{
; 273  : 		""

	push	OFFSET ??_C@_04FHCNAFFK@?$LD?I?$LJ?$KG@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp]
	mov	DWORD PTR _this$GSCopy$[ebp], edi
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 274  : 		,""

	push	OFFSET ??_C@_08KNJFAAFE@?$LC?Y?W?w?V?P?$LG?O@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+4]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 275  : 		,""

	push	OFFSET ??_C@_0N@LMLCADBC@?N?D?$LM?$PO?$LE?r?$LP?$KK?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+8]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 276  : 		,""

	push	OFFSET ??_C@_0N@EHGMKEHD@?N?D?$LM?$PO?$MA?$OA?P?M?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+12]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 277  : 		,""

	push	OFFSET ??_C@_0L@BLBNHGNN@?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+16]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 278  : 		,""

	push	OFFSET ??_C@_0L@NHOEFCGM@?C?$NM?B?k?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+20]
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 279  : 		,""

	push	OFFSET ??_C@_0L@EGNECDJP@?I?h?$LB?$LI?$LC?$LL?F?$KF?E?d@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+24]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 280  : 		,""

	push	OFFSET ??_C@_08DEIJEIHL@?P?h?R?$KK?C?$NM?B?k@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+28]
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 281  : 		,""

	push	OFFSET ??_C@_08MGFBOHLC@?P?h?R?$KK?I?h?$LB?$LI@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+32]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 282  : 		,"CRC"

	push	OFFSET ??_C@_0M@BHIMCPO@CRC?P?$KD?Q?i?J?$KH?$LA?$NM@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+36]
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 283  : 		,"Base64"

	push	OFFSET ??_C@_0P@HHKGKONE@Base64?$LN?b?B?k?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+40]
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 284  : 		,""

	push	OFFSET ??_C@_08ECNGDOBK@?$LE?m?N?s?G?x?$LP?i@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+44]
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 285  : 		,""

	push	OFFSET ??_C@_08BCICBECK@?N?$LE?V?$KK?G?x?$LP?i@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+48]
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 286  : 		,""

	push	OFFSET ??_C@_08COCJNBCE@?N?$LE?V?$KK?$LE?m?N?s@
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+52]
	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 287  : 	};
; 288  : 	CString filePath;

	lea	ecx, DWORD PTR _filePath$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 13		; 0000000dH
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 289  : 	CString originalFileName;

	lea	ecx, DWORD PTR _originalFileName$[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 290  : 	CString password;

	lea	ecx, DWORD PTR _password$[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 291  : 	CString deviceSerial;

	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 292  : 	thatboy::EncryptFileDoModal::EncryptErrorCode code;
; 293  : 
; 294  : 	GetDlgItemText(IDCTEF_PASSWORD, password);

	lea	eax, DWORD PTR _password$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 17		; 00000011H
	mov	esi, DWORD PTR __imp_?GetDlgItemTextA@CWnd@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	mov	ecx, edi
	push	eax
	push	1004					; 000003ecH
	call	esi

; 295  : 	GetDlgItemText(IDCTEF_DEVICESERIAL, deviceSerial);

	lea	eax, DWORD PTR _deviceSerial$[ebp]
	mov	ecx, edi
	push	eax
	push	1007					; 000003efH
	call	esi

; 296  : 	GetDlgItemText(IDCTEF_FILEPATH, filePath);

	lea	eax, DWORD PTR _filePath$[ebp]
	mov	ecx, edi
	push	eax
	push	1000					; 000003e8H
	call	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 298  : 	if (filePath.IsEmpty())

	mov	ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

	cmp	DWORD PTR [eax-12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 298  : 	if (filePath.IsEmpty())

	jne	SHORT $LN6@OnBnClicke

; 299  : 	{
; 300  : 		MessageBox("", "", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET ??_C@_04FMCPDGOH@?$LE?m?N?s@
	push	OFFSET ??_C@_0BH@BECGLPEJ@?N?$LE?Q?$KB?T?q?N?D?$LM?$PO?$KD?$KM?$LC?Y?W?w?J?$KH?$LA?$NM?$KD?$KB@
	call	DWORD PTR __imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z
$LN67@OnBnClicke:

; 380  : 	}
; 381  : }

	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _password$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _originalFileName$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _filePath$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	eax, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	push	14					; 0000000eH
	push	4
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OnBnClicke:

; 301  : 		return;
; 302  : 	}
; 303  : 	try {

	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H

; 305  : 		code = thatboy::EncryptFileDoModal::Verify(

	mov	esi, DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	push	1006					; 000003eeH
	call	esi
	mov	ecx, eax
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@@
	test	ecx, ecx
	mov	eax, ebx
	push	1005					; 000003edH
	cmovne	eax, DWORD PTR _deviceSerial$[ebp]
	mov	ecx, edi
	mov	DWORD PTR $T46[ebp], eax
	call	esi
	cmp	eax, 1
	mov	esi, ebx
	cmove	esi, DWORD PTR _password$[ebp]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	DWORD PTR $T46[ebp]

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 305  : 		code = thatboy::EncryptFileDoModal::Verify(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 19		; 00000013H
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	esi

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 305  : 		code = thatboy::EncryptFileDoModal::Verify(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 20		; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 305  : 		code = thatboy::EncryptFileDoModal::Verify(

	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 305  : 		code = thatboy::EncryptFileDoModal::Verify(

	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	call	?Verify@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z ; thatboy::EncryptFileDoModal::Verify
	add	esp, 72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+12], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN8@OnBnClicke

; 314  : 	}
; 315  : 	switch (code)

	lea	ecx, DWORD PTR [eax-2]
	cmp	ecx, 11					; 0000000bH
	ja	SHORT $LN10@OnBnClicke

; 319  : 		break;
; 320  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILEOPENERROR:
; 321  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILETYPEERROR:
; 322  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_VERSIONNOTMATCH:
; 323  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_PASSWORDNOTMATCH:
; 324  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_DEVICENOTMATCH:
; 325  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDPASSWORD:
; 326  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDDEVICE:
; 327  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_CRCCHECKFAILURE:
; 328  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_BASE64ERROR:
; 329  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_ERRORCHUNK:
; 330  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWCHUNK:
; 331  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWERROR:
; 332  : 		pushInfo("" + EncryptErrorCodeString[static_cast<BYTE>(code)]);

	movzx	eax, al
	lea	edx, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, OFFSET ??_C@_0BJ@FNIBAKGM@?N?D?$LM?$PO?Q?i?V?$KE?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
	push	eax
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 333  : 		return;

	jmp	$LN67@OnBnClicke
$LN8@OnBnClicke:

; 316  : 	{
; 317  : 	case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_SUCCESS:
; 318  : 		pushInfo("");

	push	ecx
	mov	ecx, esp
	push	OFFSET ??_C@_0P@HIODCMAD@?N?D?$LM?$PO?Q?i?V?$KE?$LD?I?$LJ?$KG?$KD?$KB@
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
$LN10@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 337  : 	originalFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(filePath.GetString()).c_str();

	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 337  : 	originalFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(filePath.GetString()).c_str();

	lea	ecx, DWORD PTR $T20[ebp]
	call	?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ; thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 22		; 00000016H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN132@OnBnClicke

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [eax]
$LN132@OnBnClicke:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 337  : 	originalFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(filePath.GetString()).c_str();

	push	eax
	lea	ecx, DWORD PTR _originalFileName$[ebp]
	call	DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+12], 17		; 00000011H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T20[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN148@OnBnClicke
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T20[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN158@OnBnClicke

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN158@OnBnClicke
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN158@OnBnClicke:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN148@OnBnClicke:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 339  : 	CFileDialog fileDlg(FALSE, nullptr, originalFileName, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 0, this);

	push	1
	push	0
	push	edi
	push	0
	push	6
	push	DWORD PTR _originalFileName$[ebp]
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	push	0
	push	0
	call	DWORD PTR __imp_??0CFileDialog@@QAE@HPBD0K0PAVCWnd@@KH@Z
	mov	BYTE PTR __$EHRec$[ebp+12], 23		; 00000017H

; 340  : 	fileDlg.m_ofn.lpstrTitle = "";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	esi, DWORD PTR __imp_?GetOFN@CFileDialog@@QAEAAUtagOFNA@@XZ
	call	esi

; 341  : 	fileDlg.m_ofn.lpstrFilter = "(*.*)\0*.*\0\0";

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+48], OFFSET ??_C@_08JPHNKIGA@?$LB?$KD?$LE?f?N?D?$LM?$PO@
	call	esi

; 342  : 	if (IDOK == fileDlg.DoModal())

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	mov	DWORD PTR [eax+12], OFFSET ??_C@_0BE@PDIJHHDA@?K?y?S?P?N?D?$LM?$PO?$CI?$CK?4?$CK?$CJ?$AA?$CK?4?$CK?$AA?$AA@
	call	DWORD PTR __imp_?DoModal@CFileDialog@@UAEHXZ
	cmp	eax, 1
	jne	$LN69@OnBnClicke

; 343  : 	{
; 344  : 		try

	mov	BYTE PTR __$EHRec$[ebp+12], 24		; 00000018H

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	mov	ecx, edi
	mov	esi, DWORD PTR __imp_?IsDlgButtonChecked@CWnd@@QBEIH@Z
	push	1006					; 000003eeH
	call	esi
	mov	ecx, eax
	mov	eax, ebx
	cmp	ecx, 1
	mov	ecx, edi
	push	1005					; 000003edH
	cmove	eax, DWORD PTR _deviceSerial$[ebp]
	mov	DWORD PTR $T47[ebp], eax
	call	esi
	cmp	eax, 1
	mov	BYTE PTR tv1619[ebp], 1
	cmove	ebx, DWORD PTR _password$[ebp]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T29[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	DWORD PTR $T47[ebp]

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 25		; 00000019H
	mov	ecx, esp
	mov	DWORD PTR $T31[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	ebx

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	lea	eax, DWORD PTR $T33[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 26		; 0000001aH
	mov	esi, DWORD PTR __imp_?GetPathName@CFileDialog@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	push	eax
	call	esi
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 27		; 0000001bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	mov	ecx, esp
	mov	DWORD PTR $T36[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 28		; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 529  : 		return( m_pszData );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 346  : 			code = thatboy::EncryptFileDoModal::Decrypt(

	mov	cl, BYTE PTR tv1619[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 29		; 0000001dH
	call	?Decrypt@EncryptFileDoModal@thatboy@@YA?AW4EncryptErrorCode@12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000_N@Z ; thatboy::EncryptFileDoModal::Decrypt
	add	esp, 96					; 00000060H
	lea	ecx, DWORD PTR $T33[ebp]
	mov	ebx, eax
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], 23		; 00000017H
	test	ebx, ebx
	je	SHORT $LN13@OnBnClicke

; 356  : 		}
; 357  : 
; 358  : 		switch (code)

	lea	eax, DWORD PTR [ebx-2]
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN15@OnBnClicke

; 362  : 			break;
; 363  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILEOPENERROR:
; 364  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_FILETYPEERROR:
; 365  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_VERSIONNOTMATCH:
; 366  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_PASSWORDNOTMATCH:
; 367  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_DEVICENOTMATCH:
; 368  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDPASSWORD:
; 369  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_NEEDDEVICE:
; 370  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_CRCCHECKFAILURE:
; 371  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_BASE64ERROR:
; 372  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_ERRORCHUNK:
; 373  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWCHUNK:
; 374  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_UNKNOWERROR:
; 375  : 			pushInfo("" + EncryptErrorCodeString[static_cast<BYTE>(code)]);

	movzx	eax, bl
	lea	edx, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, OFFSET ??_C@_0BJ@MICAHIAE@?N?D?$LM?$PO?$LN?b?C?$NM?J?$KH?$LA?$NM?$KD?$KM?$LE?m?N?s?T?$KN?R?r?$KD?$LK@
	push	eax
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
	jmp	SHORT $LN15@OnBnClicke
$LN13@OnBnClicke:

; 359  : 		{
; 360  : 		case thatboy::EncryptFileDoModal::EncryptErrorCode::ENCRYPT_SUCCESS:
; 361  : 			pushInfo("" + fileDlg.GetPathName());

	lea	eax, DWORD PTR $T42[ebp]
	push	eax
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	esi
	push	ecx
	mov	ecx, esp
	mov	BYTE PTR __$EHRec$[ebp+12], 31		; 0000001fH
	push	eax
	mov	edx, OFFSET ??_C@_0BL@PGNDALHG@?$LN?b?C?$NM?$LJ?$KE?W?w?M?j?$LD?I?$KD?$KB?N?D?$LM?$PO?R?Q?$LB?$KD?$LE?f?V?A@
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, edi
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
	lea	ecx, DWORD PTR $T42[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 23		; 00000017H
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN15@OnBnClicke:

; 376  : 		default:
; 377  : 			break;
; 378  : 		}
; 379  : 		UpdateData(FALSE);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z
$LN69@OnBnClicke:

; 380  : 	}
; 381  : }

	lea	ecx, DWORD PTR _fileDlg$[ebp]
	call	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
	jmp	$LN67@OnBnClicke
__catch$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$2:

; 347  : 				filePath.GetString()
; 348  : 				, fileDlg.GetPathName().GetString()
; 349  : 				, IsDlgButtonChecked(IDCTEF_NEEDPASSWORD) == BST_CHECKED ? password.GetString() : ""
; 350  : 				, IsDlgButtonChecked(IDCTEF_NEEDDEVICEBIND) == BST_CHECKED ? deviceSerial.GetString() : "");
; 351  : 		}
; 352  : 		catch (...)
; 353  : 		{
; 354  : 			pushInfo("");

	push	ecx
	mov	ecx, esp
	push	OFFSET ??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 355  : 			return;

	mov	eax, $LN69@OnBnClicke
	ret	0
__catch$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$0:

; 306  : 			filePath.GetString()
; 307  : 			, IsDlgButtonChecked(IDCTEF_NEEDPASSWORD) == BST_CHECKED ? password.GetString() : ""
; 308  : 			, IsDlgButtonChecked(IDCTEF_NEEDDEVICEBIND) ? deviceSerial.GetString() : "");
; 309  : 	}
; 310  : 	catch (...)
; 311  : 	{
; 312  : 		pushInfo("");

	push	ecx
	mov	ecx, esp
	push	OFFSET ??_C@_0P@FLNPCMNA@?$LD?v?O?V?N?$LE?V?$KK?$LE?m?N?s?$KD?$KB@
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 313  : 		return;

	mov	eax, $LN67@OnBnClicke
	ret	0
$LN233@OnBnClicke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$4:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$5:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+4]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$6:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+8]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$7:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+12]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$8:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+16]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$9:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+20]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$10:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+24]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$11:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+28]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$12:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+32]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$13:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+36]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$14:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+40]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$15:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+44]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$16:
	lea	ecx, DWORD PTR _EncryptErrorCodeString$[ebp+48]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$18:
	mov	eax, DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	push	eax
	push	14					; 0000000eH
	push	4
	lea	eax, DWORD PTR _EncryptErrorCodeString$[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$19:
	lea	ecx, DWORD PTR _filePath$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$20:
	lea	ecx, DWORD PTR _originalFileName$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$21:
	lea	ecx, DWORD PTR _password$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$22:
	lea	ecx, DWORD PTR _deviceSerial$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$23:
	mov	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$24:
	mov	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$30:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$31:
	lea	ecx, DWORD PTR _fileDlg$[ebp]
	jmp	DWORD PTR __imp_??1CFileDialog@@UAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$32:
	mov	ecx, DWORD PTR $T29[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$33:
	mov	ecx, DWORD PTR $T31[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$34:
	lea	ecx, DWORD PTR $T33[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$35:
	mov	ecx, DWORD PTR $T36[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ$38:
	lea	ecx, DWORD PTR $T42[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-884]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnBnClickedDecrypt@CThatboyEncryptFileEncoderDlg@@QAEXXZ ENDP ; CThatboyEncryptFileEncoderDlg::OnBnClickedDecrypt
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_now$ = -200						; size = 8
$T2 = -192						; size = 4
_this$GSCopy$1$ = -188					; size = 4
_ptmTemp$11 = -184					; size = 36
_szBuffer$12 = -148					; size = 128
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_info$ = 8						; size = 4
?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CThatboyEncryptFileEncoderDlg::pushInfo, COMDAT
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 386  : 	CTime now = CTime::GetCurrentTime();

	lea	ecx, DWORD PTR _now$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?GetTickCount@CTime@ATL@@SG?AV12@XZ	; ATL::CTime::GetTickCount
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h

; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

	lea	eax, DWORD PTR _now$[ebp]
	push	eax
	lea	eax, DWORD PTR _ptmTemp$11[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64_s
	add	esp, 8
	test	eax, eax
	jne	$LN36@pushInfo

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

	lea	eax, DWORD PTR _ptmTemp$11[ebp]
	push	eax
	push	OFFSET ??_C@_08OAHPJFNN@?$CFH?3?$CFM?3?$CFS@
	lea	eax, DWORD PTR _szBuffer$12[ebp]
	push	128					; 00000080H
	push	eax
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';
; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

	lea	ecx, DWORD PTR $T2[ebp]
	neg	eax
	sbb	al, al
	and	BYTE PTR _szBuffer$12[ebp], al
	lea	eax, DWORD PTR _szBuffer$12[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 387  : 	info.Format("[%s]%s", now.Format("%H:%M:%S").GetString(), info.GetString());

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR _info$[ebp]
	push	DWORD PTR _info$[ebp]
	push	DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_06KJKBOKBH@?$FL?$CFs?$FN?$CFs@
	push	eax
	call	DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	esi, DWORD PTR _info$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 388  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->AddString(info);

	mov	ecx, ebx
	mov	ebx, DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	push	1008					; 000003f0H
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

	mov	edi, DWORD PTR __imp__SendMessageA@16
	push	esi
	push	0
	push	384					; 00000180H
	push	DWORD PTR [eax+32]
	call	edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 389  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->SetCurSel(((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->GetCount() - 1);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1008					; 000003f0H
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

	push	0
	push	0
	push	395					; 0000018bH
	push	DWORD PTR [eax+32]
	call	edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 389  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->SetCurSel(((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->GetCount() - 1);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

	mov	esi, eax
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 389  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->SetCurSel(((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->GetCount() - 1);

	push	1008					; 000003f0H
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

	push	0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 389  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->SetCurSel(((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->GetCount() - 1);

	lea	edx, DWORD PTR [esi-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

	push	edx
	push	390					; 00000186H
	push	DWORD PTR [eax+32]
	call	edi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 390  : 	((CListBox*)GetDlgItem(IDCTEF_INFOBOX))->UpdateWindow();

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1008					; 000003f0H
	call	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 106  : 	{ ASSERT(::IsWindow(m_hWnd)); ::UpdateWindow(m_hWnd); }

	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__UpdateWindow@4
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 391  : }

	lea	ecx, DWORD PTR _info$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN36@pushInfo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h

; 1068 : 		AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN34@pushInfo:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
	lea	ecx, DWORD PTR _info$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CThatboyEncryptFileEncoderDlg::pushInfo
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?OnDropFiles@CThatboyEncryptFileEncoderDlg@@QAEXPAUHDROP__@@@Z
_TEXT	SEGMENT
_szFilePathName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hDropInfo$ = 8						; size = 4
?OnDropFiles@CThatboyEncryptFileEncoderDlg@@QAEXPAUHDROP__@@@Z PROC ; CThatboyEncryptFileEncoderDlg::OnDropFiles, COMDAT
; _this$ = ecx

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _hDropInfo$[ebp]

; 396  : 	char szFilePathName[MAX_PATH] = { 0 };

	lea	eax, DWORD PTR _szFilePathName$[ebp]
	push	edi
	push	260					; 00000104H
	push	0
	push	eax
	mov	edi, ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 397  : 
; 398  : 	//      
; 399  : 	DragQueryFile(hDropInfo, 0, szFilePathName, MAX_PATH);

	lea	eax, DWORD PTR _szFilePathName$[ebp]
	push	260					; 00000104H
	push	eax
	push	0
	push	esi
	call	DWORD PTR __imp__DragQueryFileA@16

; 400  : 	updateFilePath(szFilePathName);

	push	ecx
	lea	eax, DWORD PTR _szFilePathName$[ebp]
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, edi
	call	?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::updateFilePath

; 401  : 	UpdateData(FALSE);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?UpdateData@CWnd@@QAEHH@Z

; 402  : 	DragFinish(hDropInfo);

	push	esi
	call	DWORD PTR __imp__DragFinish@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl

; 340  : 	{ Default(); }

	mov	ecx, edi
	call	DWORD PTR __imp_?Default@CWnd@@IAEJXZ
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 404  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?OnDropFiles@CThatboyEncryptFileEncoderDlg@@QAEXPAUHDROP__@@@Z ENDP ; CThatboyEncryptFileEncoderDlg::OnDropFiles
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?PreTranslateMessage@CThatboyEncryptFileEncoderDlg@@UAEHPAUtagMSG@@@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
?PreTranslateMessage@CThatboyEncryptFileEncoderDlg@@UAEHPAUtagMSG@@@Z PROC ; CThatboyEncryptFileEncoderDlg::PreTranslateMessage, COMDAT
; _this$ = ecx

; 408  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 409  : 	if (toolTip.m_hWnd != NULL)

	mov	eax, DWORD PTR [edi+248]
	test	eax, eax
	je	SHORT $LN2@PreTransla
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 429  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); }

	push	DWORD PTR _pMsg$[ebp]
	push	0
	push	1031					; 00000407H
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@PreTransla:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 411  : 	return CDialogEx::PreTranslateMessage(pMsg);

	push	DWORD PTR _pMsg$[ebp]
	mov	ecx, edi
	call	DWORD PTR __imp_?PreTranslateMessage@CDialogEx@@UAEHPAUtagMSG@@@Z
	pop	edi

; 412  : }

	pop	ebp
	ret	4
?PreTranslateMessage@CThatboyEncryptFileEncoderDlg@@UAEHPAUtagMSG@@@Z ENDP ; CThatboyEncryptFileEncoderDlg::PreTranslateMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_title$15 = -844					; size = 4
_oriFileName$16 = -840					; size = 4
$T8 = -836						; size = 24
_fileName$17 = -812					; size = 260
_fileExt$18 = -548					; size = 260
_fileFullPath$ = -284					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_filePath$ = 8						; size = 4
?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CThatboyEncryptFileEncoderDlg::updateFilePath, COMDAT
; _this$ = ecx

; 416  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 840				; 00000348H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 417  : 	char fileFullPath[MAX_PATH] = { NULL };

	push	260					; 00000104H
	lea	eax, DWORD PTR _fileFullPath$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	push	eax
	call	_memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _filePath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 417  : 	char fileFullPath[MAX_PATH] = { NULL };

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

	cmp	DWORD PTR [eax-12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 419  : 	if (filePath.IsEmpty())

	jne	SHORT $LN2@updateFile

; 420  : 	{
; 421  : 		SetDlgItemText(IDCTEF_FILEPATH, "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	1000					; 000003e8H
	mov	ecx, ebx
	call	DWORD PTR __imp_?SetDlgItemTextA@CWnd@@QAEXHPBD@Z

; 422  : 		toolTip.AddTool(GetDlgItem(IDCTEF_FILEPATH));

	mov	edi, DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	mov	ecx, ebx
	push	0
	push	0
	push	-1
	push	1000					; 000003e8H
	call	edi
	push	eax
	lea	ecx, DWORD PTR [ebx+216]
	call	DWORD PTR __imp_?AddTool@CToolTipCtrl@@QAEHPAVCWnd@@PBDPBUtagRECT@@I@Z

; 423  : 		SetWindowText("Thatboy Encrypt File Encoder");

	push	OFFSET ??_C@_0BN@FEBDKGNG@Thatboy?5Encrypt?5File?5Encoder@
	mov	ecx, ebx
	call	DWORD PTR __imp_?SetWindowTextA@CWnd@@QAEXPBD@Z

; 424  : 		GetDlgItem(IDCTEF_DECRYPT)->EnableWindow(FALSE);

	push	0
	push	1003					; 000003ebH
	mov	ecx, ebx
	call	edi
	mov	esi, DWORD PTR __imp_?EnableWindow@CWnd@@QAEHH@Z
	mov	ecx, eax
	call	esi

; 425  : 		GetDlgItem(IDCTEF_ENCRYPT)->EnableWindow(FALSE);

	push	0
	push	1002					; 000003eaH
	mov	ecx, ebx
	call	edi
	mov	ecx, eax
	call	esi

; 426  : 	}

	jmp	$LN3@updateFile
$LN2@updateFile:

; 427  : 	else
; 428  : 	{
; 429  : 		if (filePath[0] == '\"')

	push	0
	lea	ecx, DWORD PTR _filePath$[ebp]
	call	DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
	cmp	al, 34					; 00000022H
	lea	eax, DWORD PTR _fileFullPath$[ebp]
	push	260					; 00000104H
	push	eax
	jne	SHORT $LN4@updateFile

; 430  : 			sscanf_s(filePath.GetString(), "\"%[^\"]", fileFullPath, MAX_PATH);

	push	OFFSET ??_C@_06DNBNKLGN@?$CC?$CF?$FL?$FO?$CC?$FN@
	jmp	SHORT $LN91@updateFile
$LN4@updateFile:

; 431  : 		else
; 432  : 			sscanf_s(filePath.GetString(), "%[^\n]", fileFullPath, MAX_PATH);

	push	OFFSET ??_C@_05HPMPOKFN@?$CF?$FL?$FO?6?$FN@
$LN91@updateFile:

; 433  : 
; 434  : 		SetDlgItemText(IDCTEF_FILEPATH, fileFullPath);

	push	DWORD PTR _filePath$[ebp]
	call	_sscanf_s
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _fileFullPath$[ebp]
	mov	ecx, ebx
	push	eax
	push	1000					; 000003e8H
	call	DWORD PTR __imp_?SetDlgItemTextA@CWnd@@QAEXHPBD@Z

; 435  : 		toolTip.AddTool(GetDlgItem(IDCTEF_FILEPATH), fileFullPath);

	mov	edi, DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
	lea	eax, DWORD PTR _fileFullPath$[ebp]
	push	0
	push	0
	push	eax
	push	1000					; 000003e8H
	mov	ecx, ebx
	call	edi
	push	eax
	lea	ecx, DWORD PTR [ebx+216]
	call	DWORD PTR __imp_?AddTool@CToolTipCtrl@@QAEHPAVCWnd@@PBDPBUtagRECT@@I@Z

; 436  : 		char fileName[MAX_PATH];
; 437  : 		char fileExt[MAX_PATH];
; 438  : 		CString title;

	lea	ecx, DWORD PTR _title$15[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 439  : 		_splitpath_s(fileFullPath, nullptr, 0, nullptr, 0, fileName, MAX_PATH, fileExt, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _fileExt$18[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	push	260					; 00000104H
	lea	eax, DWORD PTR _fileName$17[ebp]
	push	eax
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _fileFullPath$[ebp]
	push	0
	push	eax
	call	DWORD PTR __imp___splitpath_s
	add	esp, 36					; 00000024H

; 440  : 		title.Format("Thatboy Encrypt File Encoder - %s%s", fileName, fileExt);

	lea	eax, DWORD PTR _fileExt$18[ebp]
	push	eax
	lea	eax, DWORD PTR _fileName$17[ebp]
	push	eax
	lea	eax, DWORD PTR _title$15[ebp]
	push	OFFSET ??_C@_0CE@HOPGIPCP@Thatboy?5Encrypt?5File?5Encoder?5?9?5@
	push	eax
	call	DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
	add	esp, 16					; 00000010H

; 441  : 		SetWindowText(title);

	mov	ecx, ebx
	push	DWORD PTR _title$15[ebp]
	call	DWORD PTR __imp_?SetWindowTextA@CWnd@@QAEXPBD@Z

; 443  : 		CString oriFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(fileFullPath).c_str();

	sub	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	lea	eax, DWORD PTR _fileFullPath$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 443  : 		CString oriFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(fileFullPath).c_str();

	mov	ecx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	eax

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 443  : 		CString oriFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(fileFullPath).c_str();

	lea	ecx, DWORD PTR $T8[ebp]
	call	?getEncryptFileOriginalFilename@EncryptFileDoModal@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@@Z ; thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN38@updateFile

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [eax]
$LN38@updateFile:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 443  : 		CString oriFileName = thatboy::EncryptFileDoModal::getEncryptFileOriginalFilename(fileFullPath).c_str();

	push	eax
	lea	ecx, DWORD PTR _oriFileName$16[ebp]
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T8[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN54@updateFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN64@updateFile

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN64@updateFile
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN64@updateFile:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN54@updateFile:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

	mov	eax, DWORD PTR _oriFileName$16[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T8[ebp+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T8[ebp+20], 15		; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T8[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

	cmp	DWORD PTR [eax-12], 0
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 444  : 		if (!oriFileName.IsEmpty()) {

	je	SHORT $LN6@updateFile

; 445  : 			pushInfo("" + oriFileName);

	push	ecx
	lea	eax, DWORD PTR _oriFileName$16[ebp]
	mov	ecx, esp
	push	eax
	mov	edx, OFFSET ??_C@_0P@HGIHICBA@?N?D?$LM?$PO?T?$KN?J?$LM?C?$PL?N?$KK?$KD?$LK@
	call	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ; ATL::operator+
	add	esp, 4
	mov	ecx, ebx
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo

; 446  : 			GetDlgItem(IDCTEF_DECRYPT)->EnableWindow();

	push	1

; 447  : 		}

	jmp	SHORT $LN92@updateFile
$LN6@updateFile:

; 448  : 		else
; 449  : 		{
; 450  : 			GetDlgItem(IDCTEF_DECRYPT)->EnableWindow(FALSE);

	push	0
$LN92@updateFile:

; 451  : 		}
; 452  : 		GetDlgItem(IDCTEF_ENCRYPT)->EnableWindow();

	push	1003					; 000003ebH
	mov	ecx, ebx
	call	edi
	mov	esi, DWORD PTR __imp_?EnableWindow@CWnd@@QAEHH@Z
	mov	ecx, eax
	call	esi
	push	1
	push	1002					; 000003eaH
	mov	ecx, ebx
	call	edi
	mov	ecx, eax
	call	esi

; 453  : 	}

	lea	ecx, DWORD PTR _oriFileName$16[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _title$15[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN3@updateFile:

; 454  : }

	lea	ecx, DWORD PTR _filePath$[ebp]
	call	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN90@updateFile:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
	lea	ecx, DWORD PTR _filePath$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
	lea	ecx, DWORD PTR _title$15[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$4:
	lea	ecx, DWORD PTR _oriFileName$16[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-856]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateFilePath@CThatboyEncryptFileEncoderDlg@@IAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CThatboyEncryptFileEncoderDlg::updateFilePath
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1471 :         return _Mypair._Myval2._Mylast;

	mov	eax, DWORD PTR [ecx+4]

; 1472 :     }

	ret	0
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1463 :         return _Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR [ecx]

; 1464 :     }

	ret	0
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 673  :     ~vector() noexcept {

	push	edi
	mov	edi, ecx

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR [edi+4]
	push	esi
	push	ecx
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	esi, DWORD PTR [edi]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	ecx, esi
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN22@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [edi], 0

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
	pop	esi
$LN4@vector:
	pop	edi

; 679  :     }

	ret	0
$LN19@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@vector:
	int	3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

	mov	eax, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1689 :     void _Tidy() noexcept { // free all storage

	push	edi
	mov	edi, ecx

; 1690 :         auto& _My_data    = _Mypair._Myval2;
; 1691 :         pointer& _Myfirst = _My_data._Myfirst;
; 1692 :         pointer& _Mylast  = _My_data._Mylast;
; 1693 :         pointer& _Myend   = _My_data._Myend;
; 1694 : 
; 1695 :         _My_data._Orphan_all();
; 1696 : 
; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR [edi+4]
	push	esi
	push	ecx
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	esi, DWORD PTR [edi]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	ecx, esi
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN20@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [edi], 0

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
	pop	esi
$LN2@Tidy:

; 1705 :     }

	pop	edi
	ret	0
$LN17@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy:
	int	3
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1737 :     }

	ret	0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1614 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4

; 1616 :     }

	pop	ebp
	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$[ebp]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 781  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

	mov	eax, ecx

; 1337 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?4V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAEAAV01@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
__Temp$21 = -92						; size = 40
$T1 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Func$ = 8						; size = 4
??$?4V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAEAAV01@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::function<bool __cdecl(int)>::operator=<<lambda_f74fcfde5f7b784984846d3120ae874c>,void>, COMDAT
; _this$dead$ = ecx

; 1176 :     function& operator=(_Fx&& _Func) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T1[ebp]

; 1176 :     function& operator=(_Fx&& _Func) {

	push	esi

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T1[ebp], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$21[ebp+36], 0

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp+4], eax

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp+36], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	eax, DWORD PTR __Temp$21[ebp]
	push	eax
	call	?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$21[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN35@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	xor	ecx, ecx
	mov	DWORD PTR $T1[ebp+36], ecx
$LN35@operator:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN44@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN43@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T1[ebp+36], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN96@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T1[ebp+36]
	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN98@operator
$LN96@operator:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN44@operator
$LN43@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T1[ebp+36], ecx
$LN98@operator:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
$LN44@operator:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN76@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN59@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$21[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN97@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN97@operator:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]
	jmp	SHORT $LN76@operator
$LN59@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, edx
$LN76@operator:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN95@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN95@operator:

; 1177 :         function(_STD forward<_Fx>(_Func)).swap(*this);
; 1178 :         return *this;
; 1179 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??$?4V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAEAAV01@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::function<bool __cdecl(int)>::operator=<<lambda_f74fcfde5f7b784984846d3120ae874c>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?4V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAEAAV01@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
__Temp$21 = -92						; size = 40
$T1 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Func$ = 8						; size = 4
??$?4V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAEAAV01@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::function<bool __cdecl(int,int)>::operator=<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>, COMDAT
; _this$dead$ = ecx

; 1176 :     function& operator=(_Fx&& _Func) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T1[ebp]

; 1176 :     function& operator=(_Fx&& _Func) {

	push	esi

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T1[ebp], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$21[ebp+36], 0

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp+4], eax

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp+36], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	eax, DWORD PTR __Temp$21[ebp]
	push	eax
	call	?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$21[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN35@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	xor	ecx, ecx
	mov	DWORD PTR $T1[ebp+36], ecx
$LN35@operator:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN44@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN43@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T1[ebp+36], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN96@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T1[ebp+36]
	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN98@operator
$LN96@operator:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN44@operator
$LN43@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T1[ebp+36], ecx
$LN98@operator:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
$LN44@operator:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN76@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN59@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$21[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN97@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN97@operator:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]
	jmp	SHORT $LN76@operator
$LN59@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, edx
$LN76@operator:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN95@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN95@operator:

; 1177 :         function(_STD forward<_Fx>(_Func)).swap(*this);
; 1178 :         return *this;
; 1179 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??$?4V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAEAAV01@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::function<bool __cdecl(int,int)>::operator=<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?4V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEAAV01@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
__Temp$21 = -92						; size = 40
$T1 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Func$ = 8						; size = 4
??$?4V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEAAV01@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::operator=<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>, COMDAT
; _this$dead$ = ecx

; 1176 :     function& operator=(_Fx&& _Func) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	ecx, DWORD PTR $T1[ebp]

; 1176 :     function& operator=(_Fx&& _Func) {

	push	esi

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR $T1[ebp], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@

; 961  :         _Set(nullptr);

	mov	DWORD PTR __Temp$21[ebp+36], 0

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp+4], eax

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp+36], eax

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	lea	eax, DWORD PTR __Temp$21[ebp]
	push	eax
	call	?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Move

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$21[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN35@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1051 :             _Set(nullptr);

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	xor	ecx, ecx
	mov	DWORD PTR $T1[ebp+36], ecx
$LN35@operator:

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	esi, esi

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN44@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN43@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	ecx, eax
	mov	DWORD PTR $T1[ebp+36], ecx

; 982  :         return !_Getimpl();

	test	esi, esi

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN96@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [esi]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	esi, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	ecx, esi
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	ecx, DWORD PTR $T1[ebp+36]
	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN98@operator
$LN96@operator:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$21[ebp+36]
	jmp	SHORT $LN44@operator
$LN43@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	ecx, esi
	mov	DWORD PTR $T1[ebp+36], ecx
$LN98@operator:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
$LN44@operator:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN76@operator

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN59@operator

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$21[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN97@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$21[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN97@operator:

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR $T1[ebp+36]
	jmp	SHORT $LN76@operator
$LN59@operator:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, edx
$LN76@operator:

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN95@operator

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
$LN95@operator:

; 1177 :         function(_STD forward<_Fx>(_Func)).swap(*this);
; 1178 :         return *this;
; 1179 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??$?4V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEAAV01@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::operator=<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 950  :         for (; _First != _Last; ++_First) {

	cmp	esi, edi
	je	SHORT $LN45@Destroy_ra
	npad	6
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN23@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN33@Destroy_ra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN30@Destroy_ra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN33@Destroy_ra:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 950  :         for (; _First != _Last; ++_First) {

	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL4@Destroy_ra
$LN45@Destroy_ra:
	pop	edi

; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

	pop	esi
	ret	0
$LN30@Destroy_ra:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN46@Destroy_ra:
	int	3
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?swap@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?swap@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEXAAV12@@Z PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::swap, COMDAT
; _this$ = ecx

; 1200 :     void swap(function& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	cmp	eax, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, ecx

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN17@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN16@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN17@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN73@swap
$LN16@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN73@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN17@swap:
	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN33@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN32@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN72@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN74@swap
$LN72@swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN33@swap
$LN32@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN74@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
$LN33@swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN65@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN48@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN65@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN48@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, edx
$LN65@swap:

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?swap@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAEXAAV12@@Z ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?swap@?$function@$$A6A_NHH@Z@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?swap@?$function@$$A6A_NHH@Z@std@@QAEXAAV12@@Z PROC	; std::function<bool __cdecl(int,int)>::swap, COMDAT
; _this$ = ecx

; 1200 :     void swap(function& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	cmp	eax, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, ecx

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN17@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN16@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN17@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN73@swap
$LN16@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN73@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN17@swap:
	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN33@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN32@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN72@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN74@swap
$LN72@swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN33@swap
$LN32@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN74@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
$LN33@swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN65@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN48@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN65@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN48@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, edx
$LN65@swap:

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?swap@?$function@$$A6A_NHH@Z@std@@QAEXAAV12@@Z ENDP	; std::function<bool __cdecl(int,int)>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?swap@?$function@$$A6A_NH@Z@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?swap@?$function@$$A6A_NH@Z@std@@QAEXAAV12@@Z PROC	; std::function<bool __cdecl(int)>::swap, COMDAT
; _this$ = ecx

; 1200 :     void swap(function& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	cmp	eax, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN4@swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, ecx

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN17@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN16@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN17@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN73@swap
$LN16@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN73@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN17@swap:
	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN33@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN32@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN72@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN74@swap
$LN72@swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN33@swap
$LN32@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN74@swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
$LN33@swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN65@swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN48@swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN65@swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN48@swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, edx
$LN65@swap:

; 1201 :         this->_Swap(_Right);
; 1202 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?swap@?$function@$$A6A_NH@Z@std@@QAEXAAV12@@Z ENDP	; std::function<bool __cdecl(int)>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Swap@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?_Swap@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXAAV12@@Z PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Swap, COMDAT
; _this$ = ecx

; 1055 :     void _Swap(_Func_class& _Right) noexcept { // swap contents with contents of _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	cmp	eax, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, ecx

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN14@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN13@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN14@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN70@Swap
$LN13@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN70@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN14@Swap:
	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN30@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN29@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN69@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN71@Swap
$LN69@Swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN30@Swap
$LN29@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN71@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, 0
$LN30@Swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN62@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN45@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A ; thatboy::EncryptFileDoModal::callBackStatusUpdate
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN62@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN45@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackStatusUpdate@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@A+36, edx
$LN62@Swap:

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEXAAV12@@Z ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Swap@?$_Func_class@_NHH@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?_Swap@?$_Func_class@_NHH@std@@IAEXAAV12@@Z PROC	; std::_Func_class<bool,int,int>::_Swap, COMDAT
; _this$ = ecx

; 1055 :     void _Swap(_Func_class& _Right) noexcept { // swap contents with contents of _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	cmp	eax, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, ecx

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN14@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN13@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN14@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN70@Swap
$LN13@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN70@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN14@Swap:
	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN30@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN29@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN69@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN71@Swap
$LN69@Swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN30@Swap
$LN29@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN71@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, 0
$LN30@Swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN62@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN45@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarRange
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN62@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN45@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarRange@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NHH@Z@std@@A+36, edx
$LN62@Swap:

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap@?$_Func_class@_NHH@std@@IAEXAAV12@@Z ENDP	; std::_Func_class<bool,int,int>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Swap@?$_Func_class@_NH@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
__Temp$17 = -52						; size = 40
__$ArrayPad$ = -8					; size = 4
__Right$dead$ = 8					; size = 4
?_Swap@?$_Func_class@_NH@std@@IAEXAAV12@@Z PROC		; std::_Func_class<bool,int>::_Swap, COMDAT
; _this$ = ecx

; 1055 :     void _Swap(_Func_class& _Right) noexcept { // swap contents with contents of _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	ecx, DWORD PTR [esi+36]
	cmp	ecx, esi

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	eax, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	cmp	eax, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 1056 :         if (!_Local() && !_Right._Local()) { // just swap pointers

	je	SHORT $LN2@Swap

; 1057 :             _Ptrt* _Temp = _Getimpl();
; 1058 :             _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], eax

; 1059 :             _Right._Set(_Temp);

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, ecx

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Swap:

; 961  :         _Set(nullptr);

	xor	edx, edx
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN14@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN13@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Temp$17[ebp]
	push	edx
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	edx, eax
	mov	DWORD PTR __Temp$17[ebp+36], edx

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN14@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN70@Swap
$LN13@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	edx, ecx
	mov	DWORD PTR __Temp$17[ebp+36], edx
$LN70@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR [esi+36], 0
$LN14@Swap:
	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN30@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN29@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [esi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN69@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 996  :             } else { // steal from _Right

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN71@Swap
$LN69@Swap:

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	edx, DWORD PTR __Temp$17[ebp+36]
	jmp	SHORT $LN30@Swap
$LN29@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [esi+36], ecx
$LN71@Swap:

; 982  :         return !_Getimpl();

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, 0
$LN30@Swap:
	test	edx, edx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN62@Swap

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	edx, eax

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN45@Swap

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	OFFSET ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A ; thatboy::EncryptFileDoModal::callBackSetProcessBarPos
	call	DWORD PTR [eax+4]

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR __Temp$17[ebp+36]

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, eax

; 982  :         return !_Getimpl();

	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN62@Swap

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Temp$17[ebp]
	cmp	ecx, eax
	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN45@Swap:

; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR ?callBackSetProcessBarPos@EncryptFileDoModal@thatboy@@3V?$function@$$A6A_NH@Z@std@@A+36, edx
$LN62@Swap:

; 1060 :         } else { // do three-way move
; 1061 :             _Func_class _Temp;
; 1062 :             _Temp._Reset_move(_STD move(*this));
; 1063 :             _Reset_move(_STD move(_Right));
; 1064 :             _Right._Reset_move(_STD move(_Temp));
; 1065 :         }
; 1066 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap@?$_Func_class@_NH@std@@IAEXAAV12@@Z ENDP		; std::_Func_class<bool,int>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Reset_move@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Reset_move@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV12@@Z PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Reset_move, COMDAT
; _this$ = ecx

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	ebp
	mov	ebp, esp
	push	esi

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR __Right$[ebp]

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	edi
	mov	edi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN4@Reset_move

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN3@Reset_move

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [edi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Reset_move

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
	pop	edi

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebp
	ret	4
$LN3@Reset_move:

; 995  :                 _Right._Tidy();
; 996  :             } else { // steal from _Right
; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [edi+36], ecx

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
$LN4@Reset_move:
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?_Reset_move@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV12@@Z ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Reset_move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Reset_move@?$_Func_class@_NHH@std@@IAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Reset_move@?$_Func_class@_NHH@std@@IAEX$$QAV12@@Z PROC ; std::_Func_class<bool,int,int>::_Reset_move, COMDAT
; _this$ = ecx

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	ebp
	mov	ebp, esp
	push	esi

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR __Right$[ebp]

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	edi
	mov	edi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN4@Reset_move

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN3@Reset_move

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [edi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Reset_move

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
	pop	edi

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebp
	ret	4
$LN3@Reset_move:

; 995  :                 _Right._Tidy();
; 996  :             } else { // steal from _Right
; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [edi+36], ecx

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
$LN4@Reset_move:
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?_Reset_move@?$_Func_class@_NHH@std@@IAEX$$QAV12@@Z ENDP ; std::_Func_class<bool,int,int>::_Reset_move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Reset_move@?$_Func_class@_NH@std@@IAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Reset_move@?$_Func_class@_NH@std@@IAEX$$QAV12@@Z PROC	; std::_Func_class<bool,int>::_Reset_move, COMDAT
; _this$ = ecx

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	ebp
	mov	ebp, esp
	push	esi

; 982  :         return !_Getimpl();

	mov	esi, DWORD PTR __Right$[ebp]

; 991  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

	push	edi
	mov	edi, ecx

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 992  :         if (!_Right._Empty()) {

	je	SHORT $LN4@Reset_move

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 993  :             if (_Right._Local()) { // move and tidy

	jne	SHORT $LN3@Reset_move

; 994  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	eax, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [edi+36], eax

; 982  :         return !_Getimpl();

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx

; 1049 :         if (!_Empty()) { // destroy callable object and maybe delete it

	je	SHORT $LN4@Reset_move

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	mov	edx, DWORD PTR [ecx]

; 1080 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	cmp	ecx, esi

; 1050 :             _Getimpl()->_Delete_this(!_Local());

	setne	al
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+16]
	pop	edi

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebp
	ret	4
$LN3@Reset_move:

; 995  :                 _Right._Tidy();
; 996  :             } else { // steal from _Right
; 997  :                 _Set(_Right._Getimpl());

	mov	DWORD PTR [edi+36], ecx

; 998  :                 _Right._Set(nullptr);
; 999  :             }
; 1000 :         }
; 1001 :     }

	mov	DWORD PTR [esi+36], 0
$LN4@Reset_move:
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?_Reset_move@?$_Func_class@_NH@std@@IAEX$$QAV12@@Z ENDP	; std::_Func_class<bool,int>::_Reset_move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAE@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAE@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::function<bool __cdecl(int)>::function<bool __cdecl(int)><<lambda_f74fcfde5f7b784984846d3120ae874c>,void>, COMDAT
; _this$ = ecx

; 1129 :     function(_Fx _Func) {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	mov	eax, ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	pop	ebp
	ret	4
??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$function@$$A6A_NH@Z@std@@QAE@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::function<bool __cdecl(int)>::function<bool __cdecl(int)><<lambda_f74fcfde5f7b784984846d3120ae874c>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAE@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAE@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::function<bool __cdecl(int,int)>::function<bool __cdecl(int,int)><<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>, COMDAT
; _this$ = ecx

; 1129 :     function(_Fx _Func) {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	mov	eax, ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	pop	ebp
	ret	4
??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$function@$$A6A_NHH@Z@std@@QAE@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::function<bool __cdecl(int,int)>::function<bool __cdecl(int,int)><<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>, COMDAT
; _this$ = ecx

; 1129 :     function(_Fx _Func) {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	mov	eax, ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@

; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1130 :         this->_Reset(_STD move(_Func));
; 1131 :     }

	pop	ebp
	ret	4
??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$function@$$A6A_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@std@@QAE@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)>::function<bool __cdecl(std::basic_string<char,std::char_traits<char>,std::allocator<char> >)><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z PROC ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z ENDP ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z PROC ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z ENDP ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z PROC ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z ENDP ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

	mov	eax, ecx

; 290  : }

	ret	0
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

	push	esi
	mov	esi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN18@destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN28@destroy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN25@destroy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN28@destroy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@destroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 677  :     }

	ret	0
$LN25@destroy:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN35@destroy:
	int	3
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z PROC ; std::move<std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$_Func_class@_NHH@std@@@std@@YA$$QAV?$_Func_class@_NHH@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_Func_class@_NHH@std@@@std@@YA$$QAV?$_Func_class@_NHH@0@AAV10@@Z PROC ; std::move<std::_Func_class<bool,int,int> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV?$_Func_class@_NHH@std@@@std@@YA$$QAV?$_Func_class@_NHH@0@AAV10@@Z ENDP ; std::move<std::_Func_class<bool,int,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$_Func_class@_NH@std@@@std@@YA$$QAV?$_Func_class@_NH@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_Func_class@_NH@std@@@std@@YA$$QAV?$_Func_class@_NH@0@AAV10@@Z PROC ; std::move<std::_Func_class<bool,int> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV?$_Func_class@_NH@std@@@std@@YA$$QAV?$_Func_class@_NH@0@AAV10@@Z ENDP ; std::move<std::_Func_class<bool,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN16@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN26@scalar

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN23@scalar

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN26@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
	mov	eax, esi

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi
	ret	4
$LN23@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN32@scalar:
	int	3
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z PROC ; std::move<<lambda_f74fcfde5f7b784984846d3120ae874c> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z ENDP ; std::move<<lambda_f74fcfde5f7b784984846d3120ae874c> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Reset@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@?$_Func_class@_NH@std@@IAEX$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Reset@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@?$_Func_class@_NH@std@@IAEX$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::_Func_class<bool,int>::_Reset<<lambda_f74fcfde5f7b784984846d3120ae874c> >, COMDAT
; _this$ = ecx

; 1004 :     void _Reset(_Fx&& _Val) { // store copy of _Val

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 1005 :         if (!_Test_callable(_Val)) { // null member pointer/function pointer/std::function
; 1006 :             return; // already empty
; 1007 :         }
; 1008 : 
; 1009 :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 1010 :         if
; 1011 :             _CONSTEXPR_IF(_Is_large<_Impl>) {
; 1012 :                 // dynamically allocate _Val
; 1013 :                 _Set(_Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 1014 :             }
; 1015 :         else {
; 1016 :             // store _Val in-situ
; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1018 :         }
; 1019 :     }

	pop	ebp
	ret	4
??$_Reset@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@?$_Func_class@_NH@std@@IAEX$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::_Func_class<bool,int>::_Reset<<lambda_f74fcfde5f7b784984846d3120ae874c> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z PROC ; std::move<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z ENDP ; std::move<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Reset@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@?$_Func_class@_NHH@std@@IAEX$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Reset@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@?$_Func_class@_NHH@std@@IAEX$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::_Func_class<bool,int,int>::_Reset<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >, COMDAT
; _this$ = ecx

; 1004 :     void _Reset(_Fx&& _Val) { // store copy of _Val

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 1005 :         if (!_Test_callable(_Val)) { // null member pointer/function pointer/std::function
; 1006 :             return; // already empty
; 1007 :         }
; 1008 : 
; 1009 :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 1010 :         if
; 1011 :             _CONSTEXPR_IF(_Is_large<_Impl>) {
; 1012 :                 // dynamically allocate _Val
; 1013 :                 _Set(_Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 1014 :             }
; 1015 :         else {
; 1016 :             // store _Val in-situ
; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1018 :         }
; 1019 :     }

	pop	ebp
	ret	4
??$_Reset@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@?$_Func_class@_NHH@std@@IAEX$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::_Func_class<bool,int,int>::_Reset<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z PROC ; std::move<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z ENDP ; std::move<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Reset@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Reset@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Reset<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >, COMDAT
; _this$ = ecx

; 1004 :     void _Reset(_Fx&& _Val) { // store copy of _Val

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 1005 :         if (!_Test_callable(_Val)) { // null member pointer/function pointer/std::function
; 1006 :             return; // already empty
; 1007 :         }
; 1008 : 
; 1009 :         using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
; 1010 :         if
; 1011 :             _CONSTEXPR_IF(_Is_large<_Impl>) {
; 1012 :                 // dynamically allocate _Val
; 1013 :                 _Set(_Global_new<_Impl>(_STD forward<_Fx>(_Val)));
; 1014 :             }
; 1015 :         else {
; 1016 :             // store _Val in-situ
; 1017 :             _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(_STD forward<_Fx>(_Val)));

	mov	DWORD PTR [ecx+36], ecx

; 1018 :         }
; 1019 :     }

	pop	ebp
	ret	4
??$_Reset@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@?$_Func_class@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@IAEX$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::_Func_class<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Reset<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEX_N@Z
_TEXT	SEGMENT
__Dealloc$ = 8						; size = 1
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Delete_this, COMDAT
; _this$ = ecx

; 941  :     virtual void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	push	ebp
	mov	ebp, esp

; 942  :         this->~_Func_impl_no_alloc();
; 943  :         if (_Dealloc) {

	cmp	BYTE PTR __Dealloc$[ebp], 0
	je	SHORT $LN6@Delete_thi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	8
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@Delete_thi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 946  :     }

	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Get@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPBXXZ
_TEXT	SEGMENT
?_Get@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT
; _this$ = ecx

; 938  :         return _STD addressof(_Callee);

	lea	eax, DWORD PTR [ecx+4]

; 939  :     }

	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Target_type@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEABVtype_info@@XZ
_TEXT	SEGMENT
?_Target_type@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEABVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Target_type, COMDAT
; _this$ = ecx

; 930  : #if _HAS_STATIC_RTTI
; 931  :         return typeid(_Callable);

	mov	eax, OFFSET ??_R0?AV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@8

; 932  : #else // _HAS_STATIC_RTTI
; 933  :         return typeid(void);
; 934  : #endif // _HAS_STATIC_RTTI
; 935  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEABVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Target_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Do_call@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAE_N$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
?_Do_call@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAE_N$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_call, COMDAT
; _this$ = ecx

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@Do_call

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [eax]
$LN15@Do_call:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 78   : 		pushInfo(str.c_str());

	push	ecx
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi+4]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 926  :         return _Invoker_ret<_Rx>::_Call(_Callee, _STD forward<_Types>(_Args)...);

	mov	al, 1

; 927  :     }

	pop	esi
	pop	ebp
	ret	4
?_Do_call@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAE_N$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_call
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Move, COMDAT
; _this$ = ecx

; 914  :     virtual _Mybase* _Move(void* _Where) noexcept override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 915  :         if
; 916  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 917  :                 (void) _Where;
; 918  :                 return nullptr;
; 919  :             }
; 920  :         else {
; 921  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));
; 922  :         }
; 923  :     }

	pop	ebp
	ret	4
?_Move@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EAEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Copy@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Copy, COMDAT
; _this$ = ecx

; 903  :     virtual _Mybase* _Copy(void* _Where) const override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 904  :         if
; 905  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 906  :                 (void) _Where;
; 907  :                 return _Global_new<_Func_impl_no_alloc>(_Callee);
; 908  :             }
; 909  :         else {
; 910  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);
; 911  :         }
; 912  :     }

	pop	ebp
	ret	4
?_Copy@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@EBEPAV?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEX_N@Z
_TEXT	SEGMENT
__Dealloc$ = 8						; size = 1
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Delete_this, COMDAT
; _this$ = ecx

; 941  :     virtual void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	push	ebp
	mov	ebp, esp

; 942  :         this->~_Func_impl_no_alloc();
; 943  :         if (_Dealloc) {

	cmp	BYTE PTR __Dealloc$[ebp], 0
	je	SHORT $LN6@Delete_thi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	8
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@Delete_thi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 946  :     }

	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Get@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPBXXZ
_TEXT	SEGMENT
?_Get@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Get, COMDAT
; _this$ = ecx

; 938  :         return _STD addressof(_Callee);

	lea	eax, DWORD PTR [ecx+4]

; 939  :     }

	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Target_type@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEABVtype_info@@XZ
_TEXT	SEGMENT
?_Target_type@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEABVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Target_type, COMDAT
; _this$ = ecx

; 930  : #if _HAS_STATIC_RTTI
; 931  :         return typeid(_Callable);

	mov	eax, OFFSET ??_R0?AV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@8

; 932  : #else // _HAS_STATIC_RTTI
; 933  :         return typeid(void);
; 934  : #endif // _HAS_STATIC_RTTI
; 935  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEABVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Target_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Do_call@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAE_N$$QAH0@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
_<_Args_1>$ = 12					; size = 4
?_Do_call@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAE_N$$QAH0@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Do_call, COMDAT
; _this$ = ecx

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	mov	ecx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	push	1010					; 000003f2H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	edi, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	movzx	edx, si
	shl	edx, 16					; 00000010H
	movzx	ecx, di
	or	edx, ecx
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 926  :         return _Invoker_ret<_Rx>::_Call(_Callee, _STD forward<_Types>(_Args)...);

	pop	edi
	mov	al, 1
	pop	esi

; 927  :     }

	pop	ebp
	ret	8
?_Do_call@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAE_N$$QAH0@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Do_call
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Move, COMDAT
; _this$ = ecx

; 914  :     virtual _Mybase* _Move(void* _Where) noexcept override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 915  :         if
; 916  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 917  :                 (void) _Where;
; 918  :                 return nullptr;
; 919  :             }
; 920  :         else {
; 921  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));
; 922  :         }
; 923  :     }

	pop	ebp
	ret	4
?_Move@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EAEPAV?$_Func_base@_NHH@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Copy@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPAV?$_Func_base@_NHH@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPAV?$_Func_base@_NHH@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Copy, COMDAT
; _this$ = ecx

; 903  :     virtual _Mybase* _Copy(void* _Where) const override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 904  :         if
; 905  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 906  :                 (void) _Where;
; 907  :                 return _Global_new<_Func_impl_no_alloc>(_Callee);
; 908  :             }
; 909  :         else {
; 910  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);
; 911  :         }
; 912  :     }

	pop	ebp
	ret	4
?_Copy@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@EBEPAV?$_Func_base@_NHH@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEX_N@Z
_TEXT	SEGMENT
__Dealloc$ = 8						; size = 1
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEX_N@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Delete_this, COMDAT
; _this$ = ecx

; 941  :     virtual void _Delete_this(bool _Dealloc) noexcept override { // destroy self

	push	ebp
	mov	ebp, esp

; 942  :         this->~_Func_impl_no_alloc();
; 943  :         if (_Dealloc) {

	cmp	BYTE PTR __Dealloc$[ebp], 0
	je	SHORT $LN6@Delete_thi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	8
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@Delete_thi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 946  :     }

	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEX_N@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Get@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPBXXZ
_TEXT	SEGMENT
?_Get@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPBXXZ PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Get, COMDAT
; _this$ = ecx

; 938  :         return _STD addressof(_Callee);

	lea	eax, DWORD PTR [ecx+4]

; 939  :     }

	ret	0
?_Get@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPBXXZ ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Target_type@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEABVtype_info@@XZ
_TEXT	SEGMENT
?_Target_type@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEABVtype_info@@XZ PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Target_type, COMDAT
; _this$ = ecx

; 930  : #if _HAS_STATIC_RTTI
; 931  :         return typeid(_Callable);

	mov	eax, OFFSET ??_R0?AV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@8

; 932  : #else // _HAS_STATIC_RTTI
; 933  :         return typeid(void);
; 934  : #endif // _HAS_STATIC_RTTI
; 935  :     }

	ret	0
?_Target_type@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEABVtype_info@@XZ ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Target_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Do_call@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAE_N$$QAH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
?_Do_call@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAE_N$$QAH@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Do_call, COMDAT
; _this$ = ecx

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	mov	ecx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 925  :     virtual _Rx _Do_call(_Types&&... _Args) override { // call wrapped function

	push	esi
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	push	1010					; 000003f2H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	esi, DWORD PTR [eax]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	0
	push	esi
	push	1026					; 00000402H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional

; 926  :         return _Invoker_ret<_Rx>::_Call(_Callee, _STD forward<_Types>(_Args)...);

	mov	al, 1
	pop	esi

; 927  :     }

	pop	ebp
	ret	4
?_Do_call@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAE_N$$QAH@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Do_call
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Move, COMDAT
; _this$ = ecx

; 914  :     virtual _Mybase* _Move(void* _Where) noexcept override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 915  :         if
; 916  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 917  :                 (void) _Where;
; 918  :                 return nullptr;
; 919  :             }
; 920  :         else {
; 921  :             return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee));
; 922  :         }
; 923  :     }

	pop	ebp
	ret	4
?_Move@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EAEPAV?$_Func_base@_NH@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ?_Copy@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPAV?$_Func_base@_NH@2@PAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPAV?$_Func_base@_NH@2@PAX@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Copy, COMDAT
; _this$ = ecx

; 903  :     virtual _Mybase* _Copy(void* _Where) const override {

	push	ebp
	mov	ebp, esp

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 904  :         if
; 905  :             _CONSTEXPR_IF(_Is_large<_Func_impl_no_alloc>) {
; 906  :                 (void) _Where;
; 907  :                 return _Global_new<_Func_impl_no_alloc>(_Callee);
; 908  :             }
; 909  :         else {
; 910  :             return ::new (_Where) _Func_impl_no_alloc(_Callee);
; 911  :         }
; 912  :     }

	pop	ebp
	ret	4
?_Copy@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@EBEPAV?$_Func_base@_NH@2@PAX@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Test_callable@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA_NABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
??$_Test_callable@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA_NABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::_Test_callable<<lambda_f74fcfde5f7b784984846d3120ae874c> >, COMDAT
; __Arg$dead$ = ecx

; 750  :     if constexpr (_Testable_callable_v<_Ty>) {
; 751  :         return !!_Arg;
; 752  :     } else {
; 753  :         (void) _Arg;
; 754  :         return true;

	mov	al, 1

; 755  :     }
; 756  : }

	ret	0
??$_Test_callable@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YA_NABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::_Test_callable<<lambda_f74fcfde5f7b784984846d3120ae874c> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int><<lambda_f74fcfde5f7b784984846d3120ae874c>,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0V<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@$$QAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int><<lambda_f74fcfde5f7b784984846d3120ae874c>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Test_callable@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA_NABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
??$_Test_callable@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA_NABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::_Test_callable<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >, COMDAT
; __Arg$dead$ = ecx

; 750  :     if constexpr (_Testable_callable_v<_Ty>) {
; 751  :         return !!_Arg;
; 752  :     } else {
; 753  :         (void) _Arg;
; 754  :         return true;

	mov	al, 1

; 755  :     }
; 756  : }

	ret	0
??$_Test_callable@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YA_NABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::_Test_callable<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int><<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@$$QAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int><<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$_Test_callable@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA_NABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
??$_Test_callable@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA_NABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::_Test_callable<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >, COMDAT
; __Arg$dead$ = ecx

; 750  :     if constexpr (_Testable_callable_v<_Ty>) {
; 751  :         return !!_Arg;
; 752  :     } else {
; 753  :         (void) _Arg;
; 754  :         return true;

	mov	al, 1

; 755  :     }
; 756  : }

	ret	0
??$_Test_callable@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YA_NABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::_Test_callable<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate@$03$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
??$_Deallocate@$03$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<4,0>, COMDAT
; __Ptr$ = ecx
; __Bytes$dead$ = edx

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	push	8
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 196  : }

	ret	0
??$_Deallocate@$03$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAPBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z
_TEXT	SEGMENT
??$addressof@$$CBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAPBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z PROC ; std::addressof<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAPBV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z ENDP ; std::addressof<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Invoker_ret<bool,0>::_Call<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _<_Vals_0>$ = ecx
; _<_Vals_1>$ = edx

; 1604 :     static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx

	push	ebp
	mov	ebp, esp
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1604 :     static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@Call

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [edx]
$LN13@Call:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 78   : 		pushInfo(str.c_str());

	push	ecx
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1605 :         return _STD invoke(_STD forward<_Valtys>(_Vals)...);

	mov	al, 1

; 1606 :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Invoker_ret<bool,0>::_Call<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const &,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@X@?$_Func_impl_no_alloc@V<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_impl_no_alloc<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>,bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAPBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z
_TEXT	SEGMENT
??$addressof@$$CBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAPBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z PROC ; std::addressof<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAPBV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z ENDP ; std::addressof<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z
_TEXT	SEGMENT
_<_Vals_2>$ = 8						; size = 4
??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z PROC ; std::_Invoker_ret<bool,0>::_Call<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>, COMDAT
; _<_Vals_0>$ = ecx
; _<_Vals_1>$ = edx

; 1604 :     static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx

	push	ebp
	mov	ebp, esp

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR _<_Vals_2>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1604 :     static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx

	push	esi
	push	edi

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	movzx	edx, si
	shl	edx, 16					; 00000010H
	movzx	ecx, di
	or	edx, ecx
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1605 :         return _STD invoke(_STD forward<_Valtys>(_Vals)...);

	pop	edi
	mov	al, 1
	pop	esi

; 1606 :     }

	pop	ebp
	ret	0
??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z ENDP ; std::_Invoker_ret<bool,0>::_Call<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int><<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const &,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@X@?$_Func_impl_no_alloc@V<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@_NHH@std@@QAE@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int>::_Func_impl_no_alloc<<lambda_1fa47c227cca097ed6ab7fabc557d9e4>,bool,int,int><<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAPBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z
_TEXT	SEGMENT
??$addressof@$$CBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAPBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z PROC ; std::addressof<<lambda_f74fcfde5f7b784984846d3120ae874c> const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAPBV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z ENDP ; std::addressof<<lambda_f74fcfde5f7b784984846d3120ae874c> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z
_TEXT	SEGMENT
??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z PROC ; std::_Invoker_ret<bool,0>::_Call<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>, COMDAT
; _<_Vals_0>$ = ecx
; _<_Vals_1>$ = edx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1604 :     static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx

	push	esi

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	esi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	0
	push	esi
	push	1026					; 00000402H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1605 :         return _STD invoke(_STD forward<_Valtys>(_Vals)...);

	mov	al, 1
	pop	esi

; 1606 :     }

	ret	0
??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@?$_Invoker_ret@_N$0A@@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z ENDP ; std::_Invoker_ret<bool,0>::_Call<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\functional
;	COMDAT ??$?0ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z PROC ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int><<lambda_f74fcfde5f7b784984846d3120ae874c> const &,void>, COMDAT
; _this$ = ecx

; 898  :     explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(_STD forward<_Other>(_Val)) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@6B@
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??$?0ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@X@?$_Func_impl_no_alloc@V<lambda_f74fcfde5f7b784984846d3120ae874c>@@_NH@std@@QAE@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@Z ENDP ; std::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int>::_Func_impl_no_alloc<<lambda_f74fcfde5f7b784984846d3120ae874c>,bool,int><<lambda_f74fcfde5f7b784984846d3120ae874c> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0?$_Func_base@_NH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_base@_NH@std@@QAE@XZ PROC			; std::_Func_base<bool,int>::_Func_base<bool,int>, COMDAT
; _this$ = ecx

	mov	eax, ecx
	ret	0
??0?$_Func_base@_NH@std@@QAE@XZ ENDP			; std::_Func_base<bool,int>::_Func_base<bool,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0?$_Func_base@_NHH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_base@_NHH@std@@QAE@XZ PROC			; std::_Func_base<bool,int,int>::_Func_base<bool,int,int>, COMDAT
; _this$ = ecx

	mov	eax, ecx
	ret	0
??0?$_Func_base@_NHH@std@@QAE@XZ ENDP			; std::_Func_base<bool,int,int>::_Func_base<bool,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
;	COMDAT ??0?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

	mov	eax, ecx
	ret	0
??0?$_Func_base@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Func_base<bool,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z PROC ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@AAV1@@Z ENDP ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$invoke@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@std@@YA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z
_TEXT	SEGMENT
??$invoke@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@std@@YA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z PROC ; std::invoke<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	mov	esi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	0
	push	esi
	push	1026					; 00000402H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	al, 1
	pop	esi
	ret	0
??$invoke@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@std@@YA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z ENDP ; std::invoke<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z PROC ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@AAV1@@Z ENDP ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$invoke@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@std@@YA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z
_TEXT	SEGMENT
_<_Args_1>$ = 8						; size = 4
??$invoke@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@std@@YA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z PROC ; std::invoke<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	push	edi
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	movzx	edx, si
	shl	edx, 16					; 00000010H
	movzx	ecx, di
	or	edx, ecx
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	pop	edi
	mov	al, 1
	pop	esi
	pop	ebp
	ret	0
??$invoke@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@std@@YA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z ENDP ; std::invoke<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z PROC ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@AAV1@@Z ENDP ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$invoke@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$invoke@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::invoke<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@invoke

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [edx]
$LN11@invoke:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 78   : 		pushInfo(str.c_str());

	push	ecx
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	al, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$invoke@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::invoke<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z PROC ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@@std@@YAABV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@ABV1@@Z ENDP ; std::forward<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z PROC ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@@std@@YAABV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@ABV1@@Z ENDP ; std::forward<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z PROC ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@@std@@YAABV<lambda_f74fcfde5f7b784984846d3120ae874c>@@ABV1@@Z ENDP ; std::forward<<lambda_f74fcfde5f7b784984846d3120ae874c> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@_Invoker_functor@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z
_TEXT	SEGMENT
??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@_Invoker_functor@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z PROC ; std::_Invoker_functor::_Call<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	mov	esi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 68   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetPos(pos);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	0
	push	esi
	push	1026					; 00000402H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	al, 1
	pop	esi
	ret	0
??$_Call@AAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@H@_Invoker_functor@std@@SA_NAAV<lambda_f74fcfde5f7b784984846d3120ae874c>@@$$QAH@Z ENDP ; std::_Invoker_functor::_Call<<lambda_f74fcfde5f7b784984846d3120ae874c> &,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@_Invoker_functor@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z
_TEXT	SEGMENT
_<_Args_1>$ = 8						; size = 4
??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@_Invoker_functor@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z PROC ; std::_Invoker_functor::_Call<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	push	edi
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 73   : 		((CProgressCtrl*)GetDlgItem(IDCTEF_PROGRESSBAR))->SetRange(min, max);

	push	1010					; 000003f2H
	call	DWORD PTR __imp_?GetDlgItem@CWnd@@QBEPAV1@H@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	movzx	edx, si
	shl	edx, 16					; 00000010H
	movzx	ecx, di
	or	edx, ecx
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [eax+32]
	call	DWORD PTR __imp__SendMessageA@16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	pop	edi
	mov	al, 1
	pop	esi
	pop	ebp
	ret	0
??$_Call@AAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@HH@_Invoker_functor@std@@SA_NAAV<lambda_1fa47c227cca097ed6ab7fabc557d9e4>@@$$QAH1@Z ENDP ; std::_Invoker_functor::_Call<<lambda_1fa47c227cca097ed6ab7fabc557d9e4> &,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@_Invoker_functor@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@_Invoker_functor@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Invoker_functor::_Call<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@Call

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [edx]
$LN9@Call:
; File E:\Visual Studio Application\\ThatboyEncryptFileEncoder\ThatboyEncryptFileEncoderDlg.cpp

; 78   : 		pushInfo(str.c_str());

	push	ecx
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi]
	call	?pushInfo@CThatboyEncryptFileEncoderDlg@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CThatboyEncryptFileEncoderDlg::pushInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits

; 1579 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	al, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Call@AAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@_Invoker_functor@std@@SA_NAAV<lambda_880880f1ed3b8a16ebddcbf735e0f1c5>@@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Invoker_functor::_Call<<lambda_880880f1ed3b8a16ebddcbf735e0f1c5> &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?Create@CDialog@@UAEHIPAVCWnd@@@Z
_TEXT	SEGMENT
_nIDTemplate$ = 8					; size = 4
_pParentWnd$ = 12					; size = 4
?Create@CDialog@@UAEHIPAVCWnd@@@Z PROC			; CDialog::Create, COMDAT
; _this$ = ecx

; 585  : 	{ return CDialog::Create(ATL_MAKEINTRESOURCE(nIDTemplate), pParentWnd); }

	push	ebp
	mov	ebp, esp
	movzx	eax, WORD PTR _nIDTemplate$[ebp]
	mov	DWORD PTR _nIDTemplate$[ebp], eax
	pop	ebp
	jmp	DWORD PTR __imp_?Create@CDialog@@UAEHPBDPAVCWnd@@@Z
?Create@CDialog@@UAEHIPAVCWnd@@@Z ENDP			; CDialog::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?EndModalState@CWnd@@UAEXXZ PROC			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 567  : 	{ ::EnableWindow(m_hWnd, TRUE); }

	push	1
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__EnableWindow@8
	ret	0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?BeginModalState@CWnd@@UAEXXZ PROC			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 565  : 	{ ::EnableWindow(m_hWnd, FALSE); }

	push	0
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__EnableWindow@8
	ret	0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsscanf_s_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsscanf_s_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 2206 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 2207 :         return __stdio_common_vsscanf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_scanf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2208 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
; 2209 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2210 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsscanf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsscanf_s
_TEXT	SEGMENT
__ArgList$ = 8						; size = 4
_vsscanf_s PROC						; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 2227 :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2228 :             return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	ecx
	call	__vsscanf_s_l
	add	esp, 8

; 2229 :         }

	pop	ecx
	pop	ebp
	ret	0
_vsscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sscanf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf_s PROC						; COMDAT

; 2309 :         {

	push	ebp
	mov	ebp, esp

; 2228 :             return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);

	mov	edx, DWORD PTR __Format$[ebp]
	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Buffer$[ebp]
	call	__vsscanf_s_l
	add	esp, 8

; 2310 :             int _Result;
; 2311 :             va_list _ArgList;
; 2312 :             __crt_va_start(_ArgList, _Format);
; 2313 : 
; 2314 :             #pragma warning(push)
; 2315 :             #pragma warning(disable: 4996) // Deprecation
; 2316 :             _Result = vsscanf_s(_Buffer, _Format, _ArgList);
; 2317 :             #pragma warning(pop)
; 2318 : 
; 2319 :             __crt_va_end(_ArgList);
; 2320 :             return _Result;
; 2321 :         }

	pop	ebp
	ret	0
_sscanf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
;	COMDAT ?RelayEvent@CToolTipCtrl@@QAEXPAUtagMSG@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?RelayEvent@CToolTipCtrl@@QAEXPAUtagMSG@@@Z PROC	; CToolTipCtrl::RelayEvent, COMDAT
; _this$ = ecx

; 429  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _lpMsg$[ebp]
	push	0
	push	1031					; 00000407H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?RelayEvent@CToolTipCtrl@@QAEXPAUtagMSG@@@Z ENDP	; CToolTipCtrl::RelayEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?OnDropFiles@CWnd@@IAEXPAUHDROP__@@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?OnDropFiles@CWnd@@IAEXPAUHDROP__@@@Z PROC		; CWnd::OnDropFiles, COMDAT
; _this$ = ecx

; 340  : 	{ Default(); }

	call	DWORD PTR __imp_?Default@CWnd@@IAEJXZ
	ret	4
?OnDropFiles@CWnd@@IAEXPAUHDROP__@@@Z ENDP		; CWnd::OnDropFiles
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?UpdateWindow@CWnd@@QAEXXZ
_TEXT	SEGMENT
?UpdateWindow@CWnd@@QAEXXZ PROC				; CWnd::UpdateWindow, COMDAT
; _this$ = ecx

; 106  : 	{ ASSERT(::IsWindow(m_hWnd)); ::UpdateWindow(m_hWnd); }

	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__UpdateWindow@4
	ret	0
?UpdateWindow@CWnd@@QAEXXZ ENDP				; CWnd::UpdateWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?GetCount@CListBox@@QBEHXZ
_TEXT	SEGMENT
?GetCount@CListBox@@QBEHXZ PROC				; CListBox::GetCount, COMDAT
; _this$ = ecx

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

	push	0
	push	0
	push	395					; 0000018bH
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	ret	0
?GetCount@CListBox@@QBEHXZ ENDP				; CListBox::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?SetCurSel@CListBox@@QAEHH@Z
_TEXT	SEGMENT
_nSelect$ = 8						; size = 4
?SetCurSel@CListBox@@QAEHH@Z PROC			; CListBox::SetCurSel, COMDAT
; _this$ = ecx

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

	push	ebp
	mov	ebp, esp
	push	0
	push	DWORD PTR _nSelect$[ebp]
	push	390					; 00000186H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?SetCurSel@CListBox@@QAEHH@Z ENDP			; CListBox::SetCurSel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?AddString@CListBox@@QAEHPBD@Z
_TEXT	SEGMENT
_lpszItem$ = 8						; size = 4
?AddString@CListBox@@QAEHPBD@Z PROC			; CListBox::AddString, COMDAT
; _this$ = ecx

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _lpszItem$[ebp]
	push	0
	push	384					; 00000180H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?AddString@CListBox@@QAEHPBD@Z ENDP			; CListBox::AddString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -172				; size = 4
_ptmTemp$ = -168					; size = 36
_szBuffer$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_pFormat$dead$ = 12					; size = 4
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z PROC ; ATL::CTime::Format, COMDAT
; _this$ = ecx

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1058 : 	if(pFormat == NULL)
; 1059 : 	{
; 1060 : 		return pFormat;
; 1061 : 	}
; 1062 : 
; 1063 : 	TCHAR szBuffer[maxTimeBufferSize];
; 1064 : 	struct tm ptmTemp;
; 1065 : 
; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

	lea	eax, DWORD PTR _ptmTemp$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	call	DWORD PTR __imp___localtime64_s
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@Format

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

	lea	eax, DWORD PTR _ptmTemp$[ebp]
	push	eax
	push	OFFSET ??_C@_08OAHPJFNN@?$CFH?3?$CFM?3?$CFS@
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	128					; 00000080H
	push	eax
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';
; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

	mov	ecx, esi
	neg	eax
	sbb	al, al
	and	BYTE PTR _szBuffer$[ebp], al
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 1077 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN12@Format:

; 1067 : 	{
; 1068 : 		AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN10@Format:
	int	3
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ENDP ; ATL::CTime::Format
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp

; 417  : 	m_time( time )

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 419  : }

	mov	eax, ecx
	pop	ebp
	ret	8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltime.h
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC		; ATL::CTime::GetTickCount, COMDAT
; ___$ReturnUdt$ = ecx

; 373  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 374  : 	return( CTime( ::_time64( NULL ) ) );

	push	0
	mov	esi, ecx
	call	DWORD PTR __imp___time64
	add	esp, 4

; 417  : 	m_time( time )

	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx

; 374  : 	return( CTime( ::_time64( NULL ) ) );

	mov	eax, esi

; 375  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\cstringt.h
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_str2$ = 8						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z PROC ; ATL::operator+, COMDAT
; ___$ReturnUdt$ = ecx
; _psz1$ = edx

; 2405 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, edx
	mov	edi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], edi

; 2406 : 		CStringT strResult( str2.GetManager() );

	mov	esi, DWORD PTR _str2$[ebp]
	mov	ecx, esi
	mov	DWORD PTR $T1[ebp], 0
	call	DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z

; 2410 : 		return( strResult );

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\cstringt.h

; 2410 : 		return( strResult );

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlsimpstr.h

; 722  : 		if( psz == NULL )

	test	ebx, ebx
	jne	SHORT $LN12@operator

; 723  : 		{
; 724  : 			return( 0 );

	xor	ecx, ecx
	jmp	SHORT $LN11@operator
$LN12@operator:

; 725  : 		}
; 726  : 		return( int( strlen( psz ) ) );

	mov	ecx, ebx
	lea	esi, DWORD PTR [ecx+1]
$LL14@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL14@operator
	sub	ecx, esi
$LN11@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\cstringt.h

; 2408 : 		CThisSimpleString::Concatenate( strResult, psz1, CThisSimpleString::StringLength( psz1 ), str2, str2.GetLength() );

	push	DWORD PTR [edx-12]
	push	edx
	push	ecx
	push	ebx
	push	edi
	call	DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
	add	esp, 20					; 00000014H

; 2410 : 		return( strResult );

	mov	eax, edi

; 2411 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@operator
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN4@operator:
	ret	0
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z ENDP ; ATL::operator+
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?GetCurSel@CComboBox@@QBEHXZ
_TEXT	SEGMENT
?GetCurSel@CComboBox@@QBEHXZ PROC			; CComboBox::GetCurSel, COMDAT
; _this$ = ecx

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

	push	0
	push	0
	push	327					; 00000147H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	ret	0
?GetCurSel@CComboBox@@QBEHXZ ENDP			; CComboBox::GetCurSel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?AddString@CComboBox@@QAEHPBD@Z
_TEXT	SEGMENT
_lpszString$ = 8					; size = 4
?AddString@CComboBox@@QAEHPBD@Z PROC			; CComboBox::AddString, COMDAT
; _this$ = ecx

; 795  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _lpszString$[ebp]
	push	0
	push	323					; 00000143H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?AddString@CComboBox@@QAEHPBD@Z ENDP			; CComboBox::AddString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?ResetContent@CComboBox@@QAEXXZ
_TEXT	SEGMENT
?ResetContent@CComboBox@@QAEXXZ PROC			; CComboBox::ResetContent, COMDAT
; _this$ = ecx

; 801  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }

	push	0
	push	0
	push	331					; 0000014bH
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	ret	0
?ResetContent@CComboBox@@QAEXXZ ENDP			; CComboBox::ResetContent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
;	COMDAT ?DrawIcon@CDC@@QAEHHHPAUHICON__@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_hIcon$ = 16						; size = 4
?DrawIcon@CDC@@QAEHHHPAUHICON__@@@Z PROC		; CDC::DrawIcon, COMDAT
; _this$ = ecx

; 482  : 	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _hIcon$[ebp]
	push	DWORD PTR _y$[ebp]
	push	DWORD PTR _x$[ebp]
	push	DWORD PTR [ecx+4]
	call	DWORD PTR __imp__DrawIcon@16
	pop	ebp
	ret	12					; 0000000cH
?DrawIcon@CDC@@QAEHHHPAUHICON__@@@Z ENDP		; CDC::DrawIcon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltypes.h
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
?Height@CRect@@QBEHXZ PROC				; CRect::Height, COMDAT
; _this$ = ecx

; 581  : 	return bottom - top;

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [ecx+4]

; 582  : }

	ret	0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltypes.h
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
?Width@CRect@@QBEHXZ PROC				; CRect::Width, COMDAT
; _this$ = ecx

; 576  : 	return right - left;

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 577  : }

	ret	0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_lpRect$ = 8						; size = 4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z PROC		; CWnd::GetClientRect, COMDAT
; _this$ = ecx

; 86   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _lpRect$[ebp]
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__GetClientRect@8
	pop	ebp
	ret	4
?GetClientRect@CWnd@@QBEXPAUtagRECT@@@Z ENDP		; CWnd::GetClientRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atltypes.h
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
??0CRect@@QAE@XZ PROC					; CRect::CRect, COMDAT
; _this$ = ecx

; 528  : 	left = 0;

	mov	DWORD PTR [ecx], 0

; 529  : 	top = 0;
; 530  : 	right = 0;
; 531  : 	bottom = 0;
; 532  : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ PROC			; CDC::GetSafeHdc, COMDAT
; _this$ = ecx

; 316  : 	{ return this == NULL ? NULL : m_hDC; }

	test	ecx, ecx
	jne	SHORT $LN3@GetSafeHdc
	xor	eax, eax
	ret	0
$LN3@GetSafeHdc:
	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ENDP			; CDC::GetSafeHdc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?SendMessageA@CWnd@@QBEJIIJ@Z
_TEXT	SEGMENT
_message$dead$ = 8					; size = 4
_wParam$ = 12						; size = 4
_lParam$dead$ = 16					; size = 4
?SendMessageA@CWnd@@QBEJIIJ@Z PROC			; CWnd::SendMessageA, COMDAT
; _this$ = ecx

; 32   : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, message, wParam, lParam); }

	push	ebp
	mov	ebp, esp
	push	0
	push	DWORD PTR _wParam$[ebp]
	push	39					; 00000027H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	12					; 0000000cH
?SendMessageA@CWnd@@QBEJIIJ@Z ENDP			; CWnd::SendMessageA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?IsIconic@CWnd@@QBEHXZ
_TEXT	SEGMENT
?IsIconic@CWnd@@QBEHXZ PROC				; CWnd::IsIconic, COMDAT
; _this$ = ecx

; 69   : 	{ ASSERT(::IsWindow(m_hWnd)); return ::IsIconic(m_hWnd); }

	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__IsIconic@4
	ret	0
?IsIconic@CWnd@@QBEHXZ ENDP				; CWnd::IsIconic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?SetCurSel@CComboBox@@QAEHH@Z
_TEXT	SEGMENT
_nSelect$ = 8						; size = 4
?SetCurSel@CComboBox@@QAEHH@Z PROC			; CComboBox::SetCurSel, COMDAT
; _this$ = ecx

; 767  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }

	push	ebp
	mov	ebp, esp
	push	0
	push	DWORD PTR _nSelect$[ebp]
	push	334					; 0000014eH
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?SetCurSel@CComboBox@@QAEHH@Z ENDP			; CComboBox::SetCurSel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
;	COMDAT ?SetDelayTime@CToolTipCtrl@@QAEXI@Z
_TEXT	SEGMENT
_nDelay$dead$ = 8					; size = 4
?SetDelayTime@CToolTipCtrl@@QAEXI@Z PROC		; CToolTipCtrl::SetDelayTime, COMDAT
; _this$ = ecx

; 278  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay); }

	push	150					; 00000096H
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	ret	4
?SetDelayTime@CToolTipCtrl@@QAEXI@Z ENDP		; CToolTipCtrl::SetDelayTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
;	COMDAT ?Activate@CToolTipCtrl@@QAEXH@Z
_TEXT	SEGMENT
_bActivate$dead$ = 8					; size = 4
?Activate@CToolTipCtrl@@QAEXH@Z PROC			; CToolTipCtrl::Activate, COMDAT
; _this$ = ecx

; 425  : 	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L); }

	push	0
	push	1
	push	1025					; 00000401H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	ret	4
?Activate@CToolTipCtrl@@QAEXH@Z ENDP			; CToolTipCtrl::Activate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?SetIcon@CWnd@@QAEPAUHICON__@@PAU2@H@Z
_TEXT	SEGMENT
_hIcon$ = 8						; size = 4
_bBigIcon$ = 12						; size = 4
?SetIcon@CWnd@@QAEPAUHICON__@@PAU2@H@Z PROC		; CWnd::SetIcon, COMDAT
; _this$ = ecx

; 262  : 	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }

	push	ebp
	mov	ebp, esp
	push	DWORD PTR _hIcon$[ebp]
	push	DWORD PTR _bBigIcon$[ebp]
	push	128					; 00000080H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	8
?SetIcon@CWnd@@QAEPAUHICON__@@PAU2@H@Z ENDP		; CWnd::SetIcon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn.inl
;	COMDAT ?SetRange@CProgressCtrl@@QAEXFF@Z
_TEXT	SEGMENT
_nLower$ = 8						; size = 2
_nUpper$ = 12						; size = 2
?SetRange@CProgressCtrl@@QAEXFF@Z PROC			; CProgressCtrl::SetRange, COMDAT
; _this$ = ecx

; 524  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }

	push	ebp
	mov	ebp, esp
	movzx	edx, WORD PTR _nUpper$[ebp]
	movzx	eax, WORD PTR _nLower$[ebp]
	shl	edx, 16					; 00000010H
	or	edx, eax
	push	edx
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	8
?SetRange@CProgressCtrl@@QAEXFF@Z ENDP			; CProgressCtrl::SetRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxcmn2.inl
;	COMDAT ?SetPos@CProgressCtrl@@QAEHH@Z
_TEXT	SEGMENT
_nPos$ = 8						; size = 4
?SetPos@CProgressCtrl@@QAEHH@Z PROC			; CProgressCtrl::SetPos, COMDAT
; _this$ = ecx

; 359  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

	push	ebp
	mov	ebp, esp
	push	0
	push	DWORD PTR _nPos$[ebp]
	push	1026					; 00000402H
	push	DWORD PTR [ecx+32]
	call	DWORD PTR __imp__SendMessageA@16
	pop	ebp
	ret	4
?SetPos@CProgressCtrl@@QAEHH@Z ENDP			; CProgressCtrl::SetPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC	; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 561  : 	{ } // default does nothing

	ret	4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

	mov	eax, DWORD PTR _hr$[ebp]
	cmp	eax, -2147024882			; 8007000eH
	jne	SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

	call	DWORD PTR __imp_?AfxThrowMemoryException@@YGXXZ
$LN2@AtlThrowIm:

; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

	push	eax
	call	DWORD PTR __imp_?AfxThrowOleException@@YGXJ@Z
$LN5@AtlThrowIm:
	int	3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT
?AfxGetApp@@YGPAVCWinApp@@XZ PROC			; AfxGetApp, COMDAT

; 19   : 	{ return afxCurrentWinApp; }

	call	DWORD PTR __imp_?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ
	mov	eax, DWORD PTR [eax+4]
	ret	0
?AfxGetApp@@YGPAVCWinApp@@XZ ENDP			; AfxGetApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\atlmfc\include\afxwin2.inl
;	COMDAT ?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z
_TEXT	SEGMENT
_nIDResource$dead$ = 8					; size = 4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z PROC		; CWinApp::LoadIconA, COMDAT
; _this$dead$ = ecx

; 1054 : 	{ return ::LoadIconW(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),

	push	128					; 00000080H
	push	14					; 0000000eH
	push	128					; 00000080H
	call	DWORD PTR __imp_?AfxFindResourceHandle@@YGPAUHINSTANCE__@@PBD0@Z
	push	eax
	call	DWORD PTR __imp__LoadIconW@8

; 1055 : 		ATL_RT_GROUP_ICON), ATL_MAKEINTRESOURCEW(nIDResource)); }

	ret	4
?LoadIconA@CWinApp@@QBEPAUHICON__@@I@Z ENDP		; CWinApp::LoadIconA
_TEXT	ENDS
END
