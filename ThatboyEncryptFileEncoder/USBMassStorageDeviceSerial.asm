; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\usbmassstoragedeviceserial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@IKHMKGAB@?$CF?$CK?$FL?$FO?$CD?$FN?$CDvid_?$CF?$FL?$FO?$CG?$FN@ ; `string'
PUBLIC	??_C@_09JNKONLJP@pid_?$CF?$FL?$FO?$CD?$FN@	; `string'
PUBLIC	??_C@_06JKKIMKOO@?$CD?$CF?$FL?$FO?$CD?$FN@	; `string'
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__SetupDiDestroyDeviceInfoList@4:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__SetupDiGetDeviceInterfaceDetailA@24:PROC
EXTRN	__imp__SetupDiEnumDeviceInterfaces@20:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__SetupDiGetClassDevsA@16:PROC
;	COMDAT ??_C@_06JKKIMKOO@?$CD?$CF?$FL?$FO?$CD?$FN@
CONST	SEGMENT
??_C@_06JKKIMKOO@?$CD?$CF?$FL?$FO?$CD?$FN@ DB '#%[^#]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JNKONLJP@pid_?$CF?$FL?$FO?$CD?$FN@
CONST	SEGMENT
??_C@_09JNKONLJP@pid_?$CF?$FL?$FO?$CD?$FN@ DB 'pid_%[^#]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IKHMKGAB@?$CF?$CK?$FL?$FO?$CD?$FN?$CDvid_?$CF?$FL?$FO?$CG?$FN@
CONST	SEGMENT
??_C@_0BB@IKHMKGAB@?$CF?$CK?$FL?$FO?$CD?$FN?$CDvid_?$CF?$FL?$FO?$CG?$FN@ DB '%'
	DB	'*[^#]#vid_%[^&]', 00H			; `string'
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Get_unwrapped@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YAII@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; getDevicePath
PUBLIC	?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; thatboy::USBMassStorageDeviceSerial::getUSBMassStorageDeviceList
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
;	COMDAT ?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_junk$13 = -1344					; size = 4
_usbMSDSerialVector$GSCopy$1$ = -1340			; size = 4
_devicePathList$ = -1336				; size = 12
$T6 = -1324						; size = 24
_pdg$14 = -1300						; size = 1024
_serial$15 = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; thatboy::USBMassStorageDeviceSerial::getUSBMassStorageDeviceList, COMDAT
; _usbMSDSerialVector$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1332				; 00000534H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _usbMSDSerialVector$GSCopy$1$[ebp], ecx

; 43   :     // 存放设备属性
; 44   :     PSTORAGE_DEVICE_DESCRIPTOR DeviceDesc;
; 45   :     DeviceDesc = (PSTORAGE_DEVICE_DESCRIPTOR)new BYTE[sizeof(STORAGE_DEVICE_DESCRIPTOR) + 512 - 1];

	push	551					; 00000227H
	call	DWORD PTR __imp_??_U@YAPAXI@Z
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _devicePathList$[ebp], 0
	mov	DWORD PTR _devicePathList$[ebp+4], 0
	mov	DWORD PTR _devicePathList$[ebp+8], 0
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 46   :     DeviceDesc->Size = sizeof(STORAGE_DEVICE_DESCRIPTOR) + 512 - 1;

	mov	DWORD PTR [eax+4], 551			; 00000227H

; 47   :     // 取设备路径
; 48   :     std::vector<std::string> devicePathList;
; 49   :     ::getDevicePath((LPGUID)&UsbClassGuid, devicePathList);

	lea	edx, DWORD PTR _devicePathList$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; getDevicePath

; 50   :     for (auto& devicePath : devicePathList)

	mov	edi, DWORD PTR _devicePathList$[ebp]
	mov	esi, edi
	mov	eax, DWORD PTR _devicePathList$[ebp+4]
	cmp	esi, eax
	je	$LN138@getUSBMass
	npad	2
$LL4@getUSBMass:

; 51   :     {
; 52   :         char pdg[1024];
; 53   :         char serial[MAX_PATH] = { NULL };

	push	260					; 00000104H
	lea	eax, DWORD PTR _serial$15[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN135@getUSBMass

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN135@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 56   :         HANDLE hDevice = CreateFile(devicePath.c_str(), GENERIC_READ && GENERIC_WRITE, FILE_SHARE_READ && FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

	push	0
	push	0
	push	3
	push	0
	push	1
	push	1
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	edi, eax

; 57   :         // 跳过无效设备
; 58   :         if (hDevice == INVALID_HANDLE_VALUE || !::DeviceIoControl(hDevice, IOCTL_STORAGE_GET_MEDIA_TYPES, NULL, 0, pdg, 1024, &junk, NULL))

	cmp	edi, -1
	je	$LN2@getUSBMass
	push	0
	lea	eax, DWORD PTR _junk$13[ebp]
	push	eax
	push	1024					; 00000400H
	lea	eax, DWORD PTR _pdg$14[ebp]
	push	eax
	push	0
	push	0
	push	2952192					; 002d0c00H
	push	edi
	call	DWORD PTR __imp__DeviceIoControl@32
	test	eax, eax
	je	$LN2@getUSBMass
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN136@getUSBMass

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN136@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 61   :         sscanf_s(devicePath.c_str(), "%*[^#]#vid_%[^&]", serial, MAX_PATH);

	push	260					; 00000104H
	lea	ecx, DWORD PTR _serial$15[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@IKHMKGAB@?$CF?$CK?$FL?$FO?$CD?$FN?$CDvid_?$CF?$FL?$FO?$CG?$FN@
	push	eax
	call	_sscanf_s
	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN137@getUSBMass

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN137@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 62   :         sscanf_s(devicePath.c_str() + 17, "pid_%[^#]", serial + 4, MAX_PATH - 4);

	push	256					; 00000100H
	lea	ecx, DWORD PTR _serial$15[ebp+4]
	add	eax, 17					; 00000011H
	push	ecx
	push	OFFSET ??_C@_09JNKONLJP@pid_?$CF?$FL?$FO?$CD?$FN@
	push	eax
	call	_sscanf_s
	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN40@getUSBMass

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN40@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 63   :         sscanf_s(devicePath.c_str() + 25, "#%[^#]", serial + 8, MAX_PATH - 8);

	push	252					; 000000fcH
	lea	ecx, DWORD PTR _serial$15[ebp+8]
	add	eax, 25					; 00000019H
	push	ecx
	push	OFFSET ??_C@_06JKKIMKOO@?$CD?$CF?$FL?$FO?$CD?$FN@
	push	eax
	call	_sscanf_s
	add	esp, 16					; 00000010H

; 64   :         ::CloseHandle(hDevice);

	push	edi
	call	DWORD PTR __imp__CloseHandle@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	lea	eax, DWORD PTR _serial$15[ebp]

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T6[ebp+16], 0

; 2337 :         assign(_Ptr);

	push	eax
	lea	ecx, DWORD PTR $T6[ebp]

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 15		; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T6[ebp], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 705  :         if (_Mylast != _My_data._Myend) {

	mov	edi, DWORD PTR _usbMSDSerialVector$GSCopy$1$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 66   :         usbMSDSerialVector.push_back(serial);

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 705  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN55@getUSBMass
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T6[ebp]

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	edx, 15					; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T6[ebp], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR $T6[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 691  :         ++_Mylast;

	add	DWORD PTR [edi+4], 24			; 00000018H

; 706  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN54@getUSBMass
$LN55@getUSBMass:

; 707  :         }
; 708  : 
; 709  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	edx, DWORD PTR $T6[ebp+20]
$LN54@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 66   :         usbMSDSerialVector.push_back(serial);

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN2@getUSBMass
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN96@getUSBMass

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN93@getUSBMass
$LN96@getUSBMass:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 50   :     for (auto& devicePath : devicePathList)

	mov	eax, DWORD PTR _devicePathList$[ebp+4]
	add	esi, 24					; 00000018H
	cmp	esi, eax
	jne	$LL4@getUSBMass
	mov	edi, DWORD PTR _devicePathList$[ebp]
$LN138@getUSBMass:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	test	edi, edi
	je	SHORT $LN105@getUSBMass

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	push	ecx
	mov	edx, eax
	mov	ecx, edi
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR _devicePathList$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edi

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, edi
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN123@getUSBMass

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edi, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H
	sub	eax, edi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN123@getUSBMass
$LN93@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 68   : }

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN123@getUSBMass:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN105@getUSBMass:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 68   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN141@getUSBMass:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _devicePathList$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getUSBMassStorageDeviceList@USBMassStorageDeviceSerial@thatboy@@YAXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; thatboy::USBMassStorageDeviceSerial::getUSBMassStorageDeviceList
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp
;	COMDAT ?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_hDevInfoSet$1$ = -72					; size = 4
_ifdata$ = -68						; size = 28
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; getDevicePath, COMDAT
; _lpGuid$dead$ = ecx
; _devicePathVector$ = edx

; 6    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1391 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [esi]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1391 :         _Mylast = _Myfirst;

	mov	DWORD PTR [esi+4], eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 15   :     hDevInfoSet = ::SetupDiGetClassDevs((LPGUID)&UsbClassGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);    // 目前存在的设备

	push	18					; 00000012H
	push	0
	push	0
	push	OFFSET _UsbClassGuid
	call	DWORD PTR __imp__SetupDiGetClassDevsA@16
	mov	DWORD PTR _hDevInfoSet$1$[ebp], eax

; 16   :     if (hDevInfoSet == INVALID_HANDLE_VALUE)

	cmp	eax, -1
	je	$LN1@getDeviceP

; 17   :         return;
; 18   :     // 申请设备接口数据空间
; 19   :     pDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)::GlobalAlloc(LMEM_ZEROINIT, 1024);

	push	1024					; 00000400H
	push	64					; 00000040H
	call	DWORD PTR __imp__GlobalAlloc@8
	mov	edi, eax

; 20   :     if (pDetail == NULL)

	test	edi, edi
	je	$LN1@getDeviceP

; 21   :         return;
; 22   :     pDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

	mov	DWORD PTR [edi], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	imul	ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	lea	ecx, DWORD PTR _ifdata$[ebp]
	mov	DWORD PTR _ifdata$[ebp], 28		; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
	mov	eax, edx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	shr	eax, 31					; 0000001fH
	add	eax, edx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	push	eax
	push	OFFSET _UsbClassGuid
	push	0
	push	DWORD PTR _hDevInfoSet$1$[ebp]
	call	DWORD PTR __imp__SetupDiEnumDeviceInterfaces@20
	test	eax, eax
	je	$LN79@getDeviceP
$LL2@getDeviceP:
	push	0
	push	0
	push	1024					; 00000400H
	push	edi
	lea	eax, DWORD PTR _ifdata$[ebp]
	push	eax
	push	DWORD PTR _hDevInfoSet$1$[ebp]
	call	DWORD PTR __imp__SetupDiGetDeviceInterfaceDetailA@24
	test	eax, eax
	je	$LN79@getDeviceP

; 33   :         devicePathVector.push_back(pDetail->DevicePath);

	lea	eax, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T2[ebp+16], 0

; 2337 :         assign(_Ptr);

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0

; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 33   :         devicePathVector.push_back(pDetail->DevicePath);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 705  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN27@getDeviceP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T2[ebp]

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	edx, 15					; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR $T2[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 691  :         ++_Mylast;

	add	DWORD PTR [esi+4], 24			; 00000018H

; 706  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN26@getDeviceP
$LN27@getDeviceP:

; 707  :         }
; 708  : 
; 709  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	edx, DWORD PTR $T2[ebp+20]
$LN26@getDeviceP:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 33   :         devicePathVector.push_back(pDetail->DevicePath);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN58@getDeviceP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN68@getDeviceP

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN65@getDeviceP
$LN68@getDeviceP:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN58@getDeviceP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [esi]
	imul	ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	lea	ecx, DWORD PTR _ifdata$[ebp]
	mov	DWORD PTR _ifdata$[ebp], 28		; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
	mov	eax, edx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	shr	eax, 31					; 0000001fH
	add	eax, edx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\USBMassStorageDeviceSerial.cpp

; 30   :             || !SetupDiGetInterfaceDeviceDetail(hDevInfoSet, &ifdata, pDetail, 1024, NULL, NULL))

	push	eax
	push	OFFSET _UsbClassGuid
	push	0
	push	DWORD PTR _hDevInfoSet$1$[ebp]
	call	DWORD PTR __imp__SetupDiEnumDeviceInterfaces@20
	test	eax, eax
	jne	$LL2@getDeviceP
$LN79@getDeviceP:

; 34   :     }
; 35   :     // 释放设备接口数据空间
; 36   :     // 关闭设备信息集句柄
; 37   :     ::GlobalFree(pDetail);

	push	edi
	call	DWORD PTR __imp__GlobalFree@4

; 38   :     ::SetupDiDestroyDeviceInfoList(hDevInfoSet);

	push	DWORD PTR _hDevInfoSet$1$[ebp]
	call	DWORD PTR __imp__SetupDiDestroyDeviceInfoList@4
$LN1@getDeviceP:

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@getDeviceP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN81@getDeviceP:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getDevicePath@@YAXPAU_GUID@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; getDevicePath
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 1484 :         auto& _My_data = _Mypair._Myval2;
; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1486 :     }

	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 1384 :     void clear() noexcept { // erase all

	push	esi
	mov	esi, ecx

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	push	ecx
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1385 :         auto& _My_data    = _Mypair._Myval2;
; 1386 :         pointer& _Myfirst = _My_data._Myfirst;
; 1387 :         pointer& _Mylast  = _My_data._Mylast;
; 1388 : 
; 1389 :         _My_data._Orphan_all();
; 1390 :         _Destroy(_Myfirst, _Mylast);
; 1391 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [esi]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1385 :         auto& _My_data    = _Mypair._Myval2;
; 1386 :         pointer& _Myfirst = _My_data._Myfirst;
; 1387 :         pointer& _Mylast  = _My_data._Mylast;
; 1388 : 
; 1389 :         _My_data._Orphan_all();
; 1390 :         _Destroy(_Myfirst, _Mylast);
; 1391 :         _Mylast = _Myfirst;

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1392 :     }

	ret	0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 721  :     void push_back(_Ty&& _Val) { // insert by moving into element at end, provide strong guarantee

	push	ebp
	mov	ebp, esp

; 705  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Val$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [edx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 691  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 722  :         emplace_back(_STD move(_Val));
; 723  :     }

	pop	ebp
	ret	4
$LN4@push_back:

; 709  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[ebp]
	push	edx
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 722  :         emplace_back(_STD move(_Val));
; 723  :     }

	pop	ebp
	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 701  :     decltype(auto) emplace_back(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp

; 702  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 703  :         auto& _My_data   = _Mypair._Myval2;
; 704  :         pointer& _Mylast = _My_data._Mylast;
; 705  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [edx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 691  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 710  : #if _HAS_CXX17
; 711  :         return _Result;
; 712  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 713  :         (void) _Result;
; 714  : #endif // _HAS_CXX17
; 715  :     }

	pop	ebp
	ret	4
$LN2@emplace_ba:

; 706  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 707  :         }
; 708  : 
; 709  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 710  : #if _HAS_CXX17
; 711  :         return _Result;
; 712  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 713  :         (void) _Result;
; 714  : #endif // _HAS_CXX17
; 715  :     }

	pop	ebp
	ret	4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 683  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	edx, DWORD PTR _<_Val_0>$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [eax+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 691  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 692  : #if _HAS_CXX17
; 693  :         return _Result;
; 694  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 695  :         (void) _Result;
; 696  : #endif // _HAS_CXX17
; 697  :     }

	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1716 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1717 :         _Lockit _Lock(_LOCK_DEBUG);
; 1718 : 
; 1719 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1720 :         while (*_Pnext) {
; 1721 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1722 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1723 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1724 :             } else { // orphan the iterator
; 1725 :                 (*_Pnext)->_Myproxy = nullptr;
; 1726 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1727 :             }
; 1728 :         }
; 1729 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1730 :         (void) _First;
; 1731 :         (void) _Last;
; 1732 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1733 :     }

	ret	8
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [edx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 672  :     }

	pop	ebp
	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
__Whereoff$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 726  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 727  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 728  :         _Alty& _Al        = _Getal();
; 729  :         auto& _My_data    = _Mypair._Myval2;
; 730  :         pointer& _Myfirst = _My_data._Myfirst;
; 731  :         pointer& _Mylast  = _My_data._Mylast;
; 732  : 
; 733  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 734  : 
; 735  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR __Whereptr$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	edi, DWORD PTR [ebx]
	sub	edx, edi

; 736  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ebx+4]
	imul	edx
	sub	ecx, edi
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$1$[ebp], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 737  : 
; 738  :         if (_Oldsize == max_size()) {

	cmp	eax, 178956970				; 0aaaaaaaH
	je	$LN94@Emplace_re

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]

; 740  :         }
; 741  : 
; 742  :         const size_type _Newsize     = _Oldsize + 1;

	lea	esi, DWORD PTR [eax+1]

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 178956970				; 0aaaaaaaH

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	eax, esi
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 34   :             if (_Count > _Max_possible) {

	cmp	eax, 178956970				; 0aaaaaaaH
	ja	$LN90@Emplace_re

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	lea	edi, DWORD PTR [eax+eax*2]
	shl	edi, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	$LN90@Emplace_re

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN83@Emplace_re

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN25@Emplace_re

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 750  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [esi+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 750  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR _this$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 753  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	ecx
	push	esi
	cmp	eax, edx
	je	SHORT $LN92@Emplace_re

; 1595 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, eax
	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 754  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 755  :         } else { // provide basic guarantee
; 756  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 757  :             _Constructed_first = _Newvec;
; 758  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	eax, DWORD PTR _this$1$[ebp]

; 1595 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	add	esp, 4
	mov	edx, DWORD PTR [ebx+4]

; 754  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 755  :         } else { // provide basic guarantee
; 756  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 757  :             _Constructed_first = _Newvec;
; 758  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	add	eax, 24					; 00000018H

; 1595 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	ecx, DWORD PTR __Whereptr$[ebp]
	push	eax
$LN92@Emplace_re:

; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR [ebx]
	add	esp, 8
	test	ecx, ecx
	je	SHORT $LN76@Emplace_re

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR [ebx+4]
	push	ecx
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ebx, DWORD PTR [ebx]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, ebx
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN86@Emplace_re

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [ebx-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ebx, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ebx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN83@Emplace_re

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ebx, edx
$LN86@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	mov	ebx, DWORD PTR _this$1$[ebp]
	add	esp, 8
$LN76@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1685 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	inc	eax
	mov	DWORD PTR [ebx], esi
	lea	ecx, DWORD PTR [eax+eax*2]

; 759  :         }
; 760  :         _CATCH_ALL
; 761  :         _Destroy(_Constructed_first, _Constructed_last);
; 762  :         _Al.deallocate(_Newvec, _Newcapacity);
; 763  :         _RERAISE;
; 764  :         _CATCH_END
; 765  : 
; 766  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 767  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR _this$1$[ebp]

; 1685 :         _Mylast  = _Newvec + _Newsize;

	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR [ebx+4], ecx

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+esi]

; 759  :         }
; 760  :         _CATCH_ALL
; 761  :         _Destroy(_Constructed_first, _Constructed_last);
; 762  :         _Al.deallocate(_Newvec, _Newcapacity);
; 763  :         _RERAISE;
; 764  :         _CATCH_END
; 765  : 
; 766  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 767  :         return _Newvec + _Whereoff;

	pop	edi
	pop	esi

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	mov	DWORD PTR [ebx+8], ecx

; 759  :         }
; 760  :         _CATCH_ALL
; 761  :         _Destroy(_Constructed_first, _Constructed_last);
; 762  :         _Al.deallocate(_Newvec, _Newcapacity);
; 763  :         _RERAISE;
; 764  :         _CATCH_END
; 765  : 
; 766  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 767  :         return _Newvec + _Whereoff;

	pop	ebx

; 768  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN83@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN90@Emplace_re:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 739  :             _Xlength();

	call	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN91@Emplace_re:
	int	3
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1708 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1670 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 1671 :         // orphan all iterators, discard old array, acquire new array
; 1672 :         auto& _My_data    = _Mypair._Myval2;
; 1673 :         pointer& _Myfirst = _My_data._Myfirst;
; 1674 :         pointer& _Mylast  = _My_data._Mylast;
; 1675 :         pointer& _Myend   = _My_data._Myend;
; 1676 : 
; 1677 :         _My_data._Orphan_all();
; 1678 : 
; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN10@Change_arr

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	edx, DWORD PTR [edi+4]
	push	esi
	push	ecx
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1680 :             _Destroy(_Myfirst, _Mylast);
; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	esi, DWORD PTR [edi]

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	add	esp, 4

; 1680 :             _Destroy(_Myfirst, _Mylast);
; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	ecx, esi
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Change_arr

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN20@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	esi
$LN10@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1684 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1685 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [edi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+4], eax

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 1687 :     }

	pop	ebp
	ret	12					; 0000000cH
$LN17@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Change_arr:
	int	3
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1618 :     size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx

; 1618 :     size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1619 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1620 :         const size_type _Oldcapacity = capacity();
; 1621 : 
; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 178956970				; 0aaaaaaaH

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1619 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1620 :         const size_type _Oldcapacity = capacity();
; 1621 : 
; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	shr	esi, 1
	sub	eax, esi
	cmp	ecx, eax
	ja	SHORT $LN7@Calculate_

; 1623 :             return _Newsize; // geometric growth would overflow
; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+ecx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	jae	SHORT $LN1@Calculate_
$LN7@Calculate_:

; 1629 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, edx
$LN1@Calculate_:
	pop	esi

; 1630 :         }
; 1631 : 
; 1632 :         return _Geometric; // geometric growth is sufficient
; 1633 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1608 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebp
	mov	ebp, esp

; 1600 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 8

; 1609 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1610 :         _Umove_if_noexcept1(_First, _Last, _Dest,
; 1611 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1612 :     }

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove, COMDAT
; _this$dead$ = ecx

; 1594 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	push	ebp
	mov	ebp, esp

; 1595 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 8

; 1596 :     }

	pop	ebp
	ret	12					; 0000000cH
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$dead$ = ecx

; 1489 :         return _Min_value(

	mov	eax, 178956970				; 0aaaaaaaH

; 1490 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1491 :     }

	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 34   :             if (_Count > _Max_possible) {

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 178956970				; 0aaaaaaaH
	ja	SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN9@allocate:

; 183  :     return nullptr;

	xor	eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN28@allocate:
	int	3
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT
; _this$ = ecx

; 1740 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1741 :     }

	ret	0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1598 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebp
	mov	ebp, esp

; 1599 :         // move [_First, _Last) to raw _Dest, using allocator
; 1600 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 8

; 1601 :     }

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 1494 :         auto& _My_data = _Mypair._Myval2;
; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1496 :     }

	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 178956970				; 0aaaaaaaH

; 681  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

	mov	eax, ecx

; 1341 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	esi

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[ebp]

; 1647 :     // move [_First, _Last) to raw _Dest, using _Al
; 1648 :     // note: only called internally from elsewhere in the STL
; 1649 :     using _Ptrval     = typename _Alloc::value_type*;
; 1650 :     auto _UFirst      = _Get_unwrapped(_First);
; 1651 :     const auto _ULast = _Get_unwrapped(_Last);
; 1652 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1653 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1654 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1655 :         return _Dest + (_ULast - _UFirst);
; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edx
	je	SHORT $LN3@Uninitiali

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, esi
	sub	eax, ecx
	npad	1
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [eax+ecx+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [esi+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1499 :         ++_Last;

	add	esi, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1499 :         ++_Last;

	add	ecx, 24					; 00000018H

; 1647 :     // move [_First, _Last) to raw _Dest, using _Al
; 1648 :     // note: only called internally from elsewhere in the STL
; 1649 :     using _Ptrval     = typename _Alloc::value_type*;
; 1650 :     auto _UFirst      = _Get_unwrapped(_First);
; 1651 :     const auto _ULast = _Get_unwrapped(_Last);
; 1652 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1653 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1654 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1655 :         return _Dest + (_ULast - _UFirst);
; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1493 :         _Destroy_range(_First, _Last, _Al);

	push	ecx
	mov	edx, esi
	mov	ecx, esi
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

	mov	eax, esi
	pop	esi

; 1664 :     }
; 1665 : }

	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0BI@@std@@YAII@Z PROC		; std::_Get_size_of_n<24>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

	cmp	ecx, 178956970				; 0aaaaaaaH
	ja	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3

; 40   : }

	ret	0
??$_Get_size_of_n@$0BI@@std@@YAII@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release, COMDAT
; _this$ = ecx

; 1503 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1504 :         return _Last;
; 1505 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1493 :         _Destroy_range(_First, _Last, _Al);

	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	mov	ecx, DWORD PTR [ecx]
	call	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	pop	ecx

; 1494 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@@Z PROC ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Ptr$ = ecx

; 1140 :     return _Ptr;

	mov	eax, ecx

; 1141 : }

	ret	0
??$_Get_unwrapped@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@@Z ENDP ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1497 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	edx, DWORD PTR _<_Vals_0>$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [eax+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1499 :         ++_Last;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 1500 :     }

	pop	ebp
	ret	4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2505 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2506 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2507 :         const auto _My_data_mem =
; 2508 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2509 :         const auto _Right_data_mem =
; 2510 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2512 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2514 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

	push	ebp
	mov	ebp, esp

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2515 :         // assign by stealing _Right's buffer, memcpy optimization
; 2516 :         // pre: this != &_Right
; 2517 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2518 :         // pre: *this owns no memory, iterators orphaned (note:
; 2519 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2520 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2521 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2522 :             // take ownership of _Right's iterators along with its buffer
; 2523 :             _Swap_proxy_and_iterators(_Right);
; 2524 :         } else {
; 2525 :             _Right._Mypair._Myval2._Orphan_all();
; 2526 :         }
; 2527 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2528 : 
; 2529 :         _Memcpy_val_from(_Right);
; 2530 :         _Right._Tidy_init();
; 2531 :     }

	pop	ebp
	ret	8
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2416 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2417 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2418 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2419 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1440 : }

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
END
