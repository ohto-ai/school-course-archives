; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\md5.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EB@KPGMAIDL@?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?padding@?1??finalize@MD5@thatboy@@QAEAAV23@XZ@4PAEA
_DATA	SEGMENT
?padding@?1??finalize@MD5@thatboy@@QAEAAV23@XZ@4PAEA DB 080H ; `thatboy::MD5::finalize'::`2'::padding
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KPGMAIDL@?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02@
CONST	SEGMENT
??_C@_0EB@KPGMAIDL@?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02@ DB '%'
	DB	'02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%0'
	DB	'2X', 00H					; `string'
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	_sprintf_s
PUBLIC	__vsprintf_s_l
PUBLIC	___local_stdio_printf_options
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; thatboy::md5
PUBLIC	?hexdigest@MD5@thatboy@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; thatboy::MD5::hexdigest
PUBLIC	?finalize@MD5@thatboy@@QAEAAV12@XZ		; thatboy::MD5::finalize
PUBLIC	?update@MD5@thatboy@@QAEXPBDI@Z			; thatboy::MD5::update
PUBLIC	?update@MD5@thatboy@@QAEXPBEI@Z			; thatboy::MD5::update
PUBLIC	?transform@MD5@thatboy@@AAEXQBE@Z		; thatboy::MD5::transform
PUBLIC	?encode@MD5@thatboy@@CAXQAEQBII@Z		; thatboy::MD5::encode
PUBLIC	?decode@MD5@thatboy@@CAXQAIQBEI@Z		; thatboy::MD5::decode
PUBLIC	?init@MD5@thatboy@@AAEXXZ			; thatboy::MD5::init
PUBLIC	??0MD5@thatboy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; thatboy::MD5::MD5
PUBLIC	?II@MD5@thatboy@@CAXAAIIIIIII@Z			; thatboy::MD5::II
PUBLIC	?HH@MD5@thatboy@@CAXAAIIIIIII@Z			; thatboy::MD5::HH
PUBLIC	?GG@MD5@thatboy@@CAXAAIIIIIII@Z			; thatboy::MD5::GG
PUBLIC	?FF@MD5@thatboy@@CAXAAIIIIIII@Z			; thatboy::MD5::FF
PUBLIC	?rotate_left@MD5@thatboy@@CAIIH@Z		; thatboy::MD5::rotate_left
PUBLIC	?I@MD5@thatboy@@CAIIII@Z			; thatboy::MD5::I
PUBLIC	?H@MD5@thatboy@@CAIIII@Z			; thatboy::MD5::H
PUBLIC	?G@MD5@thatboy@@CAIIII@Z			; thatboy::MD5::G
PUBLIC	?F@MD5@thatboy@@CAIIII@Z			; thatboy::MD5::F
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?F@MD5@thatboy@@CAIIII@Z
_TEXT	SEGMENT
_z$ = 8							; size = 4
?F@MD5@thatboy@@CAIIII@Z PROC				; thatboy::MD5::F, COMDAT
; _x$ = ecx
; _y$ = edx

; 27   : inline thatboy::MD5::uint4 thatboy::MD5::F(uint4 x, uint4 y, uint4 z) {

	push	ebp
	mov	ebp, esp

; 28   : 	return x & y | ~x&z;

	mov	eax, ecx
	and	ecx, edx
	not	eax
	and	eax, DWORD PTR _z$[ebp]
	or	eax, ecx

; 29   : }

	pop	ebp
	ret	0
?F@MD5@thatboy@@CAIIII@Z ENDP				; thatboy::MD5::F
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?G@MD5@thatboy@@CAIIII@Z
_TEXT	SEGMENT
_z$ = 8							; size = 4
?G@MD5@thatboy@@CAIIII@Z PROC				; thatboy::MD5::G, COMDAT
; _x$ = ecx
; _y$ = edx

; 31   : inline thatboy::MD5::uint4 thatboy::MD5::G(uint4 x, uint4 y, uint4 z) {

	push	ebp
	mov	ebp, esp

; 32   : 	return x & z | y & ~z;

	mov	eax, DWORD PTR _z$[ebp]
	and	ecx, DWORD PTR _z$[ebp]
	not	eax
	and	eax, edx
	or	eax, ecx

; 33   : }

	pop	ebp
	ret	0
?G@MD5@thatboy@@CAIIII@Z ENDP				; thatboy::MD5::G
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?H@MD5@thatboy@@CAIIII@Z
_TEXT	SEGMENT
_z$ = 8							; size = 4
?H@MD5@thatboy@@CAIIII@Z PROC				; thatboy::MD5::H, COMDAT
; _x$ = ecx
; _y$ = edx

; 35   : inline thatboy::MD5::uint4 thatboy::MD5::H(uint4 x, uint4 y, uint4 z) {

	push	ebp
	mov	ebp, esp

; 36   : 	return x ^ y^z;

	xor	ecx, edx
	xor	ecx, DWORD PTR _z$[ebp]
	mov	eax, ecx

; 37   : }

	pop	ebp
	ret	0
?H@MD5@thatboy@@CAIIII@Z ENDP				; thatboy::MD5::H
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?I@MD5@thatboy@@CAIIII@Z
_TEXT	SEGMENT
_z$ = 8							; size = 4
?I@MD5@thatboy@@CAIIII@Z PROC				; thatboy::MD5::I, COMDAT
; _x$ = ecx
; _y$ = edx

; 39   : inline thatboy::MD5::uint4 thatboy::MD5::I(uint4 x, uint4 y, uint4 z) {

	push	ebp
	mov	ebp, esp

; 40   : 	return y ^ (x | ~z);

	mov	eax, DWORD PTR _z$[ebp]
	not	eax
	or	eax, ecx
	xor	eax, edx

; 41   : }

	pop	ebp
	ret	0
?I@MD5@thatboy@@CAIIII@Z ENDP				; thatboy::MD5::I
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?rotate_left@MD5@thatboy@@CAIIH@Z
_TEXT	SEGMENT
?rotate_left@MD5@thatboy@@CAIIH@Z PROC			; thatboy::MD5::rotate_left, COMDAT
; _x$ = ecx
; _n$ = edx

; 43   : inline thatboy::MD5::uint4 thatboy::MD5::rotate_left(uint4 x, int n) {

	mov	eax, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	mov	ecx, edx
	rol	eax, cl

; 45   : }

	ret	0
?rotate_left@MD5@thatboy@@CAIIH@Z ENDP			; thatboy::MD5::rotate_left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?FF@MD5@thatboy@@CAXAAIIIIIII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_d$ = 12						; size = 4
_x$ = 16						; size = 4
_s$ = 20						; size = 4
_ac$ = 24						; size = 4
?FF@MD5@thatboy@@CAXAAIIIIIII@Z PROC			; thatboy::MD5::FF, COMDAT
; _a$ = ecx
; _b$ = edx

; 47   : inline void thatboy::MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 28   : 	return x & y | ~x&z;

	mov	esi, edx

; 44   : 	return (x << n) | (x >> (32 - n));

	mov	ecx, DWORD PTR _s$[ebp]

; 28   : 	return x & y | ~x&z;

	not	esi
	and	esi, DWORD PTR _d$[ebp]
	mov	eax, edx
	and	eax, DWORD PTR _c$[ebp]
	or	esi, eax

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	esi, DWORD PTR [edi]
	add	esi, DWORD PTR _x$[ebp]
	add	esi, DWORD PTR _ac$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, cl

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	esi, edx
	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi

; 49   : }

	pop	ebp
	ret	0
?FF@MD5@thatboy@@CAXAAIIIIIII@Z ENDP			; thatboy::MD5::FF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?GG@MD5@thatboy@@CAXAAIIIIIII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_d$ = 12						; size = 4
_x$ = 16						; size = 4
_s$ = 20						; size = 4
_ac$ = 24						; size = 4
?GG@MD5@thatboy@@CAXAAIIIIIII@Z PROC			; thatboy::MD5::GG, COMDAT
; _a$ = ecx
; _b$ = edx

; 51   : inline void thatboy::MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi

; 32   : 	return x & z | y & ~z;

	mov	edi, DWORD PTR _d$[ebp]

; 51   : inline void thatboy::MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	mov	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	mov	ecx, DWORD PTR _s$[ebp]

; 32   : 	return x & z | y & ~z;

	not	edi
	and	edi, DWORD PTR _c$[ebp]
	mov	eax, edx
	and	eax, DWORD PTR _d$[ebp]
	or	edi, eax

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, DWORD PTR [ebx]
	add	edi, DWORD PTR _x$[ebp]
	add	edi, DWORD PTR _ac$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, cl

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, edx
	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	ebx

; 53   : }

	pop	ebp
	ret	0
?GG@MD5@thatboy@@CAXAAIIIIIII@Z ENDP			; thatboy::MD5::GG
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?HH@MD5@thatboy@@CAXAAIIIIIII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_d$ = 12						; size = 4
_x$ = 16						; size = 4
_s$ = 20						; size = 4
_ac$ = 24						; size = 4
?HH@MD5@thatboy@@CAXAAIIIIIII@Z PROC			; thatboy::MD5::HH, COMDAT
; _a$ = ecx
; _b$ = edx

; 55   : inline void thatboy::MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 36   : 	return x ^ y^z;

	mov	eax, edx
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	mov	ecx, DWORD PTR _s$[ebp]

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	eax, DWORD PTR [esi]
	add	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _ac$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	eax, cl

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	eax, edx
	mov	DWORD PTR [esi], eax
	pop	esi

; 57   : }

	pop	ebp
	ret	0
?HH@MD5@thatboy@@CAXAAIIIIIII@Z ENDP			; thatboy::MD5::HH
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?II@MD5@thatboy@@CAXAAIIIIIII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_d$ = 12						; size = 4
_x$ = 16						; size = 4
_s$ = 20						; size = 4
_ac$ = 24						; size = 4
?II@MD5@thatboy@@CAXAAIIIIIII@Z PROC			; thatboy::MD5::II, COMDAT
; _a$ = ecx
; _b$ = edx

; 59   : inline void thatboy::MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	push	ebp
	mov	ebp, esp

; 40   : 	return y ^ (x | ~z);

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, edx
	xor	eax, DWORD PTR _c$[ebp]

; 59   : inline void thatboy::MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {

	push	esi
	mov	esi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	mov	ecx, DWORD PTR _s$[ebp]

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, DWORD PTR [esi]
	add	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _ac$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	eax, cl

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, edx
	mov	DWORD PTR [esi], eax
	pop	esi

; 61   : }

	pop	ebp
	ret	0
?II@MD5@thatboy@@CAXAAIIIIIII@Z ENDP			; thatboy::MD5::II
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ??0MD5@thatboy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_bits$2 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
??0MD5@thatboy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; thatboy::MD5::MD5, COMDAT
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _text$[ebp]
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	ecx, eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp

; 84   : 	finalized = false;

	mov	BYTE PTR [esi], 0

; 85   : 
; 86   : 	count[0] = 0;

	mov	DWORD PTR [esi+68], 0

; 87   : 	count[1] = 0;

	mov	DWORD PTR [esi+72], 0

; 88   : 
; 89   : 	// load magic initialization constants.  
; 90   : 	state[0] = 0x67452301;

	mov	DWORD PTR [esi+76], 1732584193		; 67452301H

; 91   : 	state[1] = 0xefcdab89;

	mov	DWORD PTR [esi+80], -271733879		; efcdab89H

; 92   : 	state[2] = 0x98badcfe;

	mov	DWORD PTR [esi+84], -1732584194		; 98badcfeH

; 93   : 	state[3] = 0x10325476;

	mov	DWORD PTR [esi+88], 271733878		; 10325476H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@MD5

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [eax]
$LN8@MD5:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp

; 247  : 	update((const unsigned char*)input, length);

	push	DWORD PTR [eax+16]
	push	ecx
	mov	ecx, esi
	call	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update

; 259  : 	if (!finalized) {

	cmp	BYTE PTR [esi], 0
	jne	$LN37@MD5

; 260  : 		// 保存位数 
; 261  : 		unsigned char bits[8];
; 262  : 		encode(bits, count, 8);

	xor	edx, edx
	lea	ecx, DWORD PTR [esi+70]
	npad	10
$LL22@MD5:

; 113  : 		output[j] = input[i] & 0xff;

	movzx	eax, BYTE PTR [ecx-2]
	lea	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR _bits$2[ebp+edx], al

; 114  : 		output[j + 1] = (input[i] >> 8) & 0xff;

	movzx	eax, BYTE PTR [ecx-5]
	mov	BYTE PTR _bits$2[ebp+edx+1], al

; 115  : 		output[j + 2] = (input[i] >> 16) & 0xff;

	movzx	eax, BYTE PTR [ecx-4]
	mov	BYTE PTR _bits$2[ebp+edx+2], al

; 116  : 		output[j + 3] = (input[i] >> 24) & 0xff;

	movzx	eax, BYTE PTR [ecx-3]
	mov	BYTE PTR _bits$2[ebp+edx+3], al
	add	edx, 4
	cmp	edx, 8
	jb	SHORT $LL22@MD5

; 267  : 		update(padding, padLen);

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, 120				; 00000078H
	shr	edx, 3
	mov	eax, 56					; 00000038H
	and	edx, 63					; 0000003fH
	sub	ecx, edx
	sub	eax, edx
	cmp	edx, 56					; 00000038H
	push	edi
	cmovae	eax, ecx
	mov	ecx, esi
	push	eax
	push	OFFSET ?padding@?1??finalize@MD5@thatboy@@QAEAAV23@XZ@4PAEA
	call	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update

; 268  : 
; 269  : 		// 增加长度
; 270  : 		update(bits, 8);

	push	8
	lea	eax, DWORD PTR _bits$2[ebp]
	mov	ecx, esi
	push	eax
	call	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update
	lea	edx, DWORD PTR [esi+94]
	mov	edi, 4
	lea	eax, DWORD PTR [esi+78]
	npad	2
$LL27@MD5:

; 113  : 		output[j] = input[i] & 0xff;

	movzx	ecx, BYTE PTR [eax-2]
	lea	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [edx-2], cl
	lea	edx, DWORD PTR [edx+4]

; 114  : 		output[j + 1] = (input[i] >> 8) & 0xff;

	movzx	ecx, BYTE PTR [eax-5]
	mov	BYTE PTR [edx-5], cl

; 115  : 		output[j + 2] = (input[i] >> 16) & 0xff;

	movzx	ecx, BYTE PTR [eax-4]
	mov	BYTE PTR [edx-4], cl

; 116  : 		output[j + 3] = (input[i] >> 24) & 0xff;

	movzx	ecx, BYTE PTR [eax-3]
	mov	BYTE PTR [edx-3], cl
	sub	edi, 1
	jne	SHORT $LL27@MD5

; 276  : 		memset(buffer, 0, sizeof buffer);

	push	64					; 00000040H
	lea	ecx, DWORD PTR [esi+1]
	push	edi
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	xorps	xmm0, xmm0

; 277  : 		memset(count, 0, sizeof count);

	movq	QWORD PTR [esi+68], xmm0

; 278  : 
; 279  : 		finalized = true;

	mov	BYTE PTR [esi], 1

; 75   : 	init();
; 76   : 	update(text.c_str(), (size_type)text.length());
; 77   : 	finalize();
; 78   : }

	pop	edi
$LN37@MD5:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??0MD5@thatboy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; thatboy::MD5::MD5
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?init@MD5@thatboy@@AAEXXZ
_TEXT	SEGMENT
?init@MD5@thatboy@@AAEXXZ PROC				; thatboy::MD5::init, COMDAT
; _this$ = ecx

; 84   : 	finalized = false;

	mov	BYTE PTR [ecx], 0

; 85   : 
; 86   : 	count[0] = 0;

	mov	DWORD PTR [ecx+68], 0

; 87   : 	count[1] = 0;

	mov	DWORD PTR [ecx+72], 0

; 88   : 
; 89   : 	// load magic initialization constants.  
; 90   : 	state[0] = 0x67452301;

	mov	DWORD PTR [ecx+76], 1732584193		; 67452301H

; 91   : 	state[1] = 0xefcdab89;

	mov	DWORD PTR [ecx+80], -271733879		; efcdab89H

; 92   : 	state[2] = 0x98badcfe;

	mov	DWORD PTR [ecx+84], -1732584194		; 98badcfeH

; 93   : 	state[3] = 0x10325476;

	mov	DWORD PTR [ecx+88], 271733878		; 10325476H

; 94   : }

	ret	0
?init@MD5@thatboy@@AAEXXZ ENDP				; thatboy::MD5::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?decode@MD5@thatboy@@CAXQAIQBEI@Z
_TEXT	SEGMENT
_len$dead$ = 8						; size = 4
?decode@MD5@thatboy@@CAXQAIQBEI@Z PROC			; thatboy::MD5::decode, COMDAT
; _output$ = ecx
; _input$ = edx

; 100  : {

	push	esi
	push	edi
	mov	esi, ecx

; 101  : 	for (unsigned int i = 0, j = 0; j < len; i++, j += 4)

	lea	eax, DWORD PTR [edx+2]
	mov	edi, 16					; 00000010H
	npad	4
$LL4@decode:

; 102  : 		output[i] = ((uint4)input[j]) | (((uint4)input[j + 1]) << 8) |

	movzx	edx, BYTE PTR [eax+1]
	lea	esi, DWORD PTR [esi+4]
	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+4]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [eax-5]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [eax-6]
	shl	edx, 8
	or	edx, ecx
	mov	DWORD PTR [esi-4], edx
	sub	edi, 1
	jne	SHORT $LL4@decode

; 103  : 		(((uint4)input[j + 2]) << 16) | (((uint4)input[j + 3]) << 24);
; 104  : }

	pop	edi
	pop	esi
	ret	0
?decode@MD5@thatboy@@CAXQAIQBEI@Z ENDP			; thatboy::MD5::decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?encode@MD5@thatboy@@CAXQAEQBII@Z
_TEXT	SEGMENT
_len$ = 8						; size = 4
?encode@MD5@thatboy@@CAXQAEQBII@Z PROC			; thatboy::MD5::encode, COMDAT
; _output$ = ecx
; _input$ = edx

; 111  : {

	push	ebp
	mov	ebp, esp
	mov	eax, edx

; 112  : 	for (size_type i = 0, j = 0; j < len; i++, j += 4) {

	mov	edx, DWORD PTR _len$[ebp]
	test	edx, edx
	je	SHORT $LN3@encode
	dec	edx
	add	eax, 2
	shr	edx, 2
	push	esi
	lea	esi, DWORD PTR [ecx+2]
	inc	edx
	npad	8
$LL4@encode:

; 113  : 		output[j] = input[i] & 0xff;

	movzx	ecx, BYTE PTR [eax-2]
	lea	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [esi-2], cl
	lea	esi, DWORD PTR [esi+4]

; 114  : 		output[j + 1] = (input[i] >> 8) & 0xff;

	movzx	ecx, BYTE PTR [eax-5]
	mov	BYTE PTR [esi-5], cl

; 115  : 		output[j + 2] = (input[i] >> 16) & 0xff;

	movzx	ecx, BYTE PTR [eax-4]
	mov	BYTE PTR [esi-4], cl

; 116  : 		output[j + 3] = (input[i] >> 24) & 0xff;

	movzx	ecx, BYTE PTR [eax-3]
	mov	BYTE PTR [esi-3], cl
	sub	edx, 1
	jne	SHORT $LL4@encode
	pop	esi
$LN3@encode:

; 117  : 	}
; 118  : }

	pop	ebp
	ret	0
?encode@MD5@thatboy@@CAXQAEQBII@Z ENDP			; thatboy::MD5::encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?transform@MD5@thatboy@@AAEXQBE@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -92					; size = 4
_a$1$ = -88						; size = 4
_b$8$ = -84						; size = 4
_b$4$ = -84						; size = 4
_c$4$ = -80						; size = 4
_c$1$ = -80						; size = 4
_d$1$ = -76						; size = 4
_a$5$ = -76						; size = 4
_d$8$ = -72						; size = 4
_d$5$ = -72						; size = 4
_b$16$ = -72						; size = 4
_a$12$ = -72						; size = 4
_x$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_block$ = 8						; size = 4
?transform@MD5@thatboy@@AAEXQBE@Z PROC			; thatboy::MD5::transform, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, ecx
	push	ebx
	push	esi
	mov	DWORD PTR _this$GSCopy$1$[ebp], eax

; 125  : 	uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

	mov	esi, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [eax+76]
	mov	ebx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR [eax+88]
	mov	DWORD PTR _d$1$[ebp], eax
	mov	eax, DWORD PTR _block$[ebp]
	push	edi
	mov	DWORD PTR _c$1$[ebp], esi
	add	eax, 2
	mov	DWORD PTR _a$1$[ebp], ecx
	lea	esi, DWORD PTR _x$[ebp]
	mov	edi, 16					; 00000010H
	npad	5
$LL6@transform:

; 102  : 		output[i] = ((uint4)input[j]) | (((uint4)input[j + 1]) << 8) |

	movzx	edx, BYTE PTR [eax+1]
	lea	esi, DWORD PTR [esi+4]
	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+4]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [eax-5]
	shl	edx, 8
	or	edx, ecx
	movzx	ecx, BYTE PTR [eax-6]
	shl	edx, 8
	or	edx, ecx
	mov	DWORD PTR [esi-4], edx
	sub	edi, 1
	jne	SHORT $LL6@transform

; 28   : 	return x & y | ~x&z;

	mov	edi, DWORD PTR _c$1$[ebp]
	mov	ecx, ebx
	not	ecx
	mov	esi, DWORD PTR _d$1$[ebp]
	and	ecx, esi
	mov	edx, DWORD PTR _a$1$[ebp]
	mov	eax, edi
	add	edx, -680876936				; d76aa478H
	and	eax, ebx
	add	esi, -389564586				; e8c7b756H
	or	ecx, eax
	mov	eax, ebx
	add	ecx, DWORD PTR _x$[ebp]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 7

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 28   : 	return x & y | ~x&z;

	and	eax, edx
	mov	ecx, edx
	not	ecx
	and	ecx, edi

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, 606105819				; 242070dbH

; 28   : 	return x & y | ~x&z;

	or	ecx, eax
	add	ecx, DWORD PTR _x$[ebp+4]
	add	esi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 12					; 0000000cH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 28   : 	return x & y | ~x&z;

	mov	ecx, esi
	mov	eax, esi
	not	ecx
	and	eax, edx
	and	ecx, ebx
	add	ebx, -1044525330			; c1bdceeeH
	or	ecx, eax
	mov	eax, esi

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ecx, DWORD PTR _x$[ebp+8]
	add	edi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 15					; 0000000fH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 28   : 	return x & y | ~x&z;

	and	eax, edi
	mov	ecx, edi
	not	ecx
	and	ecx, edx
	or	ecx, eax
	mov	eax, edi
	add	ecx, DWORD PTR _x$[ebp+12]
	add	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 10					; 0000000aH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 28   : 	return x & y | ~x&z;

	and	eax, ebx
	mov	ecx, ebx
	not	ecx
	and	ecx, esi
	or	ecx, eax
	mov	eax, ebx
	add	ecx, -176418897				; f57c0fafH
	add	ecx, DWORD PTR _x$[ebp+16]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 7

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 28   : 	return x & y | ~x&z;

	mov	ecx, edx
	and	eax, edx
	not	ecx
	and	ecx, edi
	or	ecx, eax

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ecx, 1200080426				; 4787c62aH
	add	ecx, DWORD PTR _x$[ebp+20]
	add	esi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 12					; 0000000cH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 28   : 	return x & y | ~x&z;

	mov	ecx, esi
	mov	eax, esi
	not	ecx
	and	eax, edx
	and	ecx, ebx
	or	ecx, eax
	add	ecx, -1473231341			; a8304613H
	add	ecx, DWORD PTR _x$[ebp+24]
	add	edi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 15					; 0000000fH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 28   : 	return x & y | ~x&z;

	mov	ecx, edi
	not	ecx
	mov	eax, esi
	and	ecx, edx
	and	eax, edi
	or	ecx, eax
	mov	eax, edi
	add	ecx, -45705983				; fd469501H
	add	ecx, DWORD PTR _x$[ebp+28]
	add	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 10					; 0000000aH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 28   : 	return x & y | ~x&z;

	and	eax, ebx
	mov	ecx, ebx
	not	ecx
	and	ecx, esi
	or	ecx, eax
	mov	eax, ebx

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ecx, 1770035416				; 698098d8H
	add	ecx, DWORD PTR _x$[ebp+32]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 7

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 28   : 	return x & y | ~x&z;

	and	eax, edx
	mov	ecx, edx
	not	ecx
	and	ecx, edi
	or	ecx, eax
	add	ecx, -1958414417			; 8b44f7afH
	add	ecx, DWORD PTR _x$[ebp+36]
	add	esi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 12					; 0000000cH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 28   : 	return x & y | ~x&z;

	mov	ecx, esi
	mov	eax, esi
	not	ecx
	and	eax, edx
	and	ecx, ebx
	or	ecx, eax
	mov	eax, esi
	add	ecx, -42063				; ffff5bb1H
	add	ecx, DWORD PTR _x$[ebp+40]
	add	edi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 15					; 0000000fH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 28   : 	return x & y | ~x&z;

	mov	ecx, edi

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _c$4$[ebp], edi

; 28   : 	return x & y | ~x&z;

	not	ecx
	and	eax, edi
	and	ecx, edx
	or	ecx, eax
	mov	eax, edi
	add	ecx, -1990404162			; 895cd7beH
	add	ecx, DWORD PTR _x$[ebp+44]
	add	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 10					; 0000000aH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 28   : 	return x & y | ~x&z;

	mov	ecx, ebx

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _b$4$[ebp], ebx

; 28   : 	return x & y | ~x&z;

	not	ecx
	and	eax, ebx
	and	ecx, esi
	or	ecx, eax
	mov	eax, ebx

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ecx, 1804603682				; 6b901122H
	add	ecx, DWORD PTR _x$[ebp+48]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 7

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 28   : 	return x & y | ~x&z;

	mov	ecx, edx

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _a$5$[ebp], edx

; 28   : 	return x & y | ~x&z;

	not	ecx
	and	eax, edx
	and	ecx, edi
	lea	edi, DWORD PTR [esi-40341101]
	or	ecx, eax
	add	ecx, DWORD PTR _x$[ebp+52]
	add	edi, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 12					; 0000000cH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, edx
	mov	DWORD PTR _d$5$[ebp], edi

; 28   : 	return x & y | ~x&z;

	mov	esi, edi
	not	esi
	mov	eax, edi
	and	eax, edx
	mov	ecx, esi
	and	ecx, ebx
	mov	ebx, DWORD PTR _c$4$[ebp]
	or	ecx, eax
	add	ebx, -1502002290			; a679438eH
	add	ecx, DWORD PTR _x$[ebp+56]
	mov	eax, edi
	add	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 15					; 0000000fH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ebx, edi
	mov	edi, DWORD PTR _b$4$[ebp]

; 28   : 	return x & y | ~x&z;

	and	eax, ebx
	mov	edx, ebx
	not	edx

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, 1236535329				; 49b40821H

; 28   : 	return x & y | ~x&z;

	mov	ecx, edx

; 32   : 	return x & z | y & ~z;

	and	esi, ebx

; 28   : 	return x & y | ~x&z;

	and	ecx, DWORD PTR _a$5$[ebp]
	or	ecx, eax

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	ecx, DWORD PTR _x$[ebp+60]
	add	edi, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, DWORD PTR _d$5$[ebp]
	mov	eax, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 10					; 0000000aH

; 48   : 	a = rotate_left(a + F(b, c, d) + x + ac, s) + b;

	add	edi, ebx

; 32   : 	return x & z | y & ~z;

	add	ecx, -1069501632			; c040b340H
	and	eax, edi
	and	edx, edi
	or	esi, eax
	mov	eax, DWORD PTR _a$5$[ebp]
	add	esi, DWORD PTR _x$[ebp+4]
	add	eax, -165796510				; f61e2562H
	add	esi, eax
	mov	eax, ebx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 5

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	esi, edi

; 32   : 	return x & z | y & ~z;

	and	eax, esi
	or	edx, eax
	add	edx, DWORD PTR _x$[ebp+24]
	add	edx, ecx
	mov	ecx, edi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 9

; 32   : 	return x & z | y & ~z;

	and	ecx, esi

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edx, esi

; 32   : 	return x & z | y & ~z;

	mov	eax, edx
	and	eax, edi
	or	ecx, eax

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ecx, 643717713				; 265e5a51H
	add	ecx, DWORD PTR _x$[ebp+44]
	add	ebx, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, esi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ebx, 14					; 0000000eH

; 32   : 	return x & z | y & ~z;

	and	ecx, edx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ebx, edx

; 32   : 	return x & z | y & ~z;

	mov	eax, ebx
	and	eax, esi
	or	ecx, eax
	mov	eax, edx
	add	ecx, -373897302				; e9b6c7aaH
	add	ecx, DWORD PTR _x$[ebp]
	add	edi, ecx
	mov	ecx, edx
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 12					; 0000000cH

; 32   : 	return x & z | y & ~z;

	and	ecx, ebx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, ebx

; 32   : 	return x & z | y & ~z;

	and	eax, edi
	or	ecx, eax
	add	ecx, -701558691				; d62f105dH
	add	ecx, DWORD PTR _x$[ebp+20]
	add	esi, ecx
	mov	ecx, ebx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 5

; 32   : 	return x & z | y & ~z;

	not	ecx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	esi, edi

; 32   : 	return x & z | y & ~z;

	and	ecx, edi
	mov	eax, ebx
	and	eax, esi
	or	ecx, eax

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ecx, 38016083				; 02441453H
	add	ecx, DWORD PTR _x$[ebp+40]
	add	edx, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, edi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 9

; 32   : 	return x & z | y & ~z;

	and	ecx, esi

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edx, esi

; 32   : 	return x & z | y & ~z;

	mov	eax, edx
	and	eax, edi
	or	ecx, eax
	add	ecx, -660478335				; d8a1e681H
	add	ecx, DWORD PTR _x$[ebp+60]
	add	ebx, ecx
	mov	ecx, esi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ebx, 14					; 0000000eH

; 32   : 	return x & z | y & ~z;

	and	ecx, edx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ebx, edx

; 32   : 	return x & z | y & ~z;

	mov	eax, ebx
	and	eax, esi
	or	ecx, eax
	mov	eax, edx
	add	ecx, -405537848				; e7d3fbc8H
	add	ecx, DWORD PTR _x$[ebp+16]
	add	edi, ecx
	mov	ecx, edx
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 12					; 0000000cH

; 32   : 	return x & z | y & ~z;

	and	ecx, ebx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, ebx

; 32   : 	return x & z | y & ~z;

	and	eax, edi
	or	ecx, eax
	mov	eax, ebx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ecx, 568446438				; 21e1cde6H
	add	ecx, DWORD PTR _x$[ebp+36]
	add	esi, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, ebx
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 5

; 32   : 	return x & z | y & ~z;

	and	ecx, edi

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	esi, edi

; 32   : 	return x & z | y & ~z;

	and	eax, esi
	or	ecx, eax
	add	ecx, -1019803690			; c33707d6H
	add	ecx, DWORD PTR _x$[ebp+56]
	add	edx, ecx
	mov	ecx, edi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 9

; 32   : 	return x & z | y & ~z;

	and	ecx, esi

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edx, esi

; 32   : 	return x & z | y & ~z;

	mov	eax, edx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _d$8$[ebp], edx

; 32   : 	return x & z | y & ~z;

	and	eax, edi
	or	ecx, eax
	add	ecx, -187363961				; f4d50d87H
	add	ecx, DWORD PTR _x$[ebp+12]
	add	ebx, ecx
	mov	ecx, esi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ebx, 14					; 0000000eH

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ebx, edx

; 32   : 	return x & z | y & ~z;

	and	ecx, edx
	mov	eax, ebx
	and	eax, esi
	or	ecx, eax
	mov	eax, edx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ecx, 1163531501				; 455a14edH
	add	ecx, DWORD PTR _x$[ebp+32]
	add	edi, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, edx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edi, 12					; 0000000cH

; 32   : 	return x & z | y & ~z;

	not	ecx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, ebx

; 32   : 	return x & z | y & ~z;

	and	ecx, ebx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _b$8$[ebp], edi

; 32   : 	return x & z | y & ~z;

	and	eax, edi
	or	ecx, eax
	lea	edx, DWORD PTR [esi-1444681467]
	add	ecx, DWORD PTR _x$[ebp+52]
	mov	eax, ebx
	add	edx, ecx
	mov	esi, DWORD PTR _d$8$[ebp]
	mov	ecx, ebx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 5

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 32   : 	return x & z | y & ~z;

	not	ecx
	and	eax, edx
	and	ecx, edi
	or	ecx, eax
	add	esi, -51403784				; fcefa3f8H
	add	ecx, DWORD PTR _x$[ebp+8]
	add	esi, ecx
	mov	ecx, edi
	not	ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 9

; 32   : 	return x & z | y & ~z;

	and	ecx, edx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 32   : 	return x & z | y & ~z;

	mov	eax, esi
	and	eax, edi

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	lea	edi, DWORD PTR [ebx+1735328473]

; 32   : 	return x & z | y & ~z;

	or	ecx, eax
	mov	ebx, DWORD PTR _b$8$[ebp]

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ecx, DWORD PTR _x$[ebp+28]

; 32   : 	return x & z | y & ~z;

	add	ebx, -1926607734			; 8d2a4c8aH

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, ecx

; 32   : 	return x & z | y & ~z;

	mov	ecx, edx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 14					; 0000000eH

; 32   : 	return x & z | y & ~z;

	not	ecx

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 32   : 	return x & z | y & ~z;

	and	ecx, esi
	mov	eax, edi
	and	eax, edx
	or	ecx, eax

; 36   : 	return x ^ y^z;

	mov	eax, esi

; 32   : 	return x & z | y & ~z;

	add	ecx, DWORD PTR _x$[ebp+48]

; 36   : 	return x ^ y^z;

	xor	eax, edi

; 32   : 	return x & z | y & ~z;

	add	ebx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 12					; 0000000cH

; 52   : 	a = rotate_left(a + G(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 36   : 	return x ^ y^z;

	xor	eax, ebx
	add	eax, -378558				; fffa3942H
	add	eax, DWORD PTR _x$[ebp+20]
	add	edx, eax
	mov	eax, edi
	xor	eax, ebx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 4

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 36   : 	return x ^ y^z;

	xor	eax, edx
	add	eax, -2022574463			; 8771f681H
	add	eax, DWORD PTR _x$[ebp+32]
	add	esi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 11					; 0000000bH

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 36   : 	return x ^ y^z;

	mov	eax, esi
	mov	ecx, esi
	xor	eax, ebx
	xor	eax, edx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	eax, 1839030562				; 6d9d6122H
	add	eax, DWORD PTR _x$[ebp+44]
	add	edi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 16					; 00000010H

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 36   : 	return x ^ y^z;

	xor	ecx, edi
	mov	eax, ecx
	xor	eax, edx
	add	eax, -35309556				; fde5380cH
	add	eax, DWORD PTR _x$[ebp+56]
	add	ebx, eax
	mov	eax, edi

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 9

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 36   : 	return x ^ y^z;

	xor	ecx, ebx
	add	ecx, -1530992060			; a4beea44H
	add	ecx, DWORD PTR _x$[ebp+4]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 4

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 36   : 	return x ^ y^z;

	xor	eax, ebx
	xor	eax, edx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	eax, 1272893353				; 4bdecfa9H
	add	eax, DWORD PTR _x$[ebp+16]
	add	esi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 11					; 0000000bH

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 36   : 	return x ^ y^z;

	mov	eax, esi
	mov	ecx, esi
	xor	eax, ebx
	xor	eax, edx
	add	eax, -155497632				; f6bb4b60H
	add	eax, DWORD PTR _x$[ebp+28]
	add	edi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 16					; 00000010H

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 36   : 	return x ^ y^z;

	xor	ecx, edi
	mov	eax, ecx
	xor	eax, edx
	add	eax, -1094730640			; bebfbc70H
	add	eax, DWORD PTR _x$[ebp+40]
	add	ebx, eax
	mov	eax, edi

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	ebx, 9

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	ebx, edi

; 36   : 	return x ^ y^z;

	xor	eax, ebx
	xor	ecx, ebx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	ecx, 681279174				; 289b7ec6H
	add	ecx, DWORD PTR _x$[ebp+52]
	add	edx, ecx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 4

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, ebx

; 36   : 	return x ^ y^z;

	xor	eax, edx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _a$12$[ebp], edx

; 36   : 	return x ^ y^z;

	add	eax, -358537222				; eaa127faH
	add	eax, DWORD PTR _x$[ebp]
	add	esi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 11					; 0000000bH

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 36   : 	return x ^ y^z;

	mov	eax, esi
	mov	ecx, esi
	xor	eax, ebx
	xor	eax, edx
	add	eax, -722521979				; d4ef3085H
	add	eax, DWORD PTR _x$[ebp+12]
	add	edi, eax
	mov	eax, DWORD PTR _a$12$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 16					; 00000010H

; 36   : 	return x ^ y^z;

	add	eax, -640364487				; d9d4d039H

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 36   : 	return x ^ y^z;

	xor	ecx, edi
	xor	edx, ecx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, 76029189				; 04881d05H
	add	edx, DWORD PTR _x$[ebp+24]
	add	edx, ebx

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edx, 9

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 36   : 	return x ^ y^z;

	xor	ecx, edx
	add	ecx, DWORD PTR _x$[ebp+36]
	add	ecx, eax
	mov	eax, edi
	xor	eax, edx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ecx, 4

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	ecx, edx

; 36   : 	return x ^ y^z;

	xor	eax, ecx
	add	eax, -421815835				; e6db99e5H
	add	eax, DWORD PTR _x$[ebp+48]
	add	esi, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 11					; 0000000bH

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	esi, ecx

; 36   : 	return x ^ y^z;

	mov	eax, esi
	xor	eax, edx
	xor	eax, ecx

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	eax, 530742520				; 1fa27cf8H
	add	eax, DWORD PTR _x$[ebp+60]
	add	edi, eax

; 36   : 	return x ^ y^z;

	mov	eax, esi

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 16					; 00000010H

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 36   : 	return x ^ y^z;

	xor	eax, edi
	xor	eax, ecx
	add	eax, -995338651				; c4ac5665H
	add	eax, DWORD PTR _x$[ebp+8]
	add	edx, eax

; 40   : 	return y ^ (x | ~z);

	mov	eax, esi
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edx, 9

; 56   : 	a = rotate_left(a + H(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 40   : 	return y ^ (x | ~z);

	or	eax, edx
	xor	eax, edi
	add	eax, -198630844				; f4292244H
	add	eax, DWORD PTR _x$[ebp]
	add	ecx, eax
	mov	eax, edi
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ecx, 6

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	ecx, edx

; 40   : 	return y ^ (x | ~z);

	or	eax, ecx
	xor	eax, edx

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, 1126891415				; 432aff97H
	add	eax, DWORD PTR _x$[ebp+28]
	add	esi, eax

; 40   : 	return y ^ (x | ~z);

	mov	eax, edx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 10					; 0000000aH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	esi, ecx

; 40   : 	return y ^ (x | ~z);

	or	eax, esi
	xor	eax, ecx
	add	eax, -1416354905			; ab9423a7H
	add	eax, DWORD PTR _x$[ebp+56]
	add	edi, eax
	mov	eax, ecx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 15					; 0000000fH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 40   : 	return y ^ (x | ~z);

	or	eax, edi
	xor	eax, esi
	add	eax, -57434055				; fc93a039H
	add	eax, DWORD PTR _x$[ebp+20]
	add	edx, eax
	mov	eax, esi
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edx, 11					; 0000000bH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 40   : 	return y ^ (x | ~z);

	or	eax, edx
	xor	eax, edi

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, 1700485571				; 655b59c3H
	add	eax, DWORD PTR _x$[ebp+48]
	add	ecx, eax

; 40   : 	return y ^ (x | ~z);

	mov	eax, edi
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ecx, 6

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	ecx, edx

; 40   : 	return y ^ (x | ~z);

	or	eax, ecx
	xor	eax, edx
	add	eax, -1894986606			; 8f0ccc92H
	add	eax, DWORD PTR _x$[ebp+12]
	add	esi, eax
	mov	eax, edx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 10					; 0000000aH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	esi, ecx

; 40   : 	return y ^ (x | ~z);

	or	eax, esi
	xor	eax, ecx
	add	eax, -1051523				; ffeff47dH
	add	eax, DWORD PTR _x$[ebp+40]
	add	edi, eax
	mov	eax, ecx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 15					; 0000000fH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edi, esi

; 40   : 	return y ^ (x | ~z);

	or	eax, edi
	xor	eax, esi
	add	eax, -2054922799			; 85845dd1H
	add	eax, DWORD PTR _x$[ebp+4]
	add	edx, eax
	mov	eax, esi

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edx, 11					; 0000000bH

; 40   : 	return y ^ (x | ~z);

	not	eax

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 40   : 	return y ^ (x | ~z);

	or	eax, edx
	xor	eax, edi

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, 1873313359				; 6fa87e4fH

; 40   : 	return y ^ (x | ~z);

	lea	ebx, DWORD PTR [esi-30611744]

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, DWORD PTR _x$[ebp+32]
	add	ecx, eax

; 40   : 	return y ^ (x | ~z);

	mov	eax, edi
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ecx, 6

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	ecx, edx

; 40   : 	return y ^ (x | ~z);

	or	eax, ecx
	xor	eax, edx
	add	eax, DWORD PTR _x$[ebp+60]
	add	ebx, eax
	lea	esi, DWORD PTR [ecx-145523070]
	mov	eax, edx

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ebx, 10					; 0000000aH

; 40   : 	return y ^ (x | ~z);

	not	eax

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	ebx, ecx

; 40   : 	return y ^ (x | ~z);

	or	eax, ebx
	xor	eax, ecx
	add	eax, -1560198380			; a3014314H
	add	eax, DWORD PTR _x$[ebp+24]
	add	edi, eax
	mov	eax, ecx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edi, 15					; 0000000fH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edi, ebx

; 40   : 	return y ^ (x | ~z);

	or	eax, edi
	xor	eax, ebx

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, 1309151649				; 4e0811a1H
	add	eax, DWORD PTR _x$[ebp+52]
	lea	ecx, DWORD PTR [edi+718787259]
	add	edx, eax

; 40   : 	return y ^ (x | ~z);

	mov	eax, ebx
	not	eax

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	edx, 11					; 0000000bH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edx, edi

; 40   : 	return y ^ (x | ~z);

	or	eax, edx

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	mov	DWORD PTR _b$16$[ebp], edx

; 40   : 	return y ^ (x | ~z);

	xor	eax, edi
	add	eax, DWORD PTR _x$[ebp+16]
	add	esi, eax
	mov	eax, edi
	not	eax

; 126  : 	decode(x, block, blocksize);
; 127  : 
; 128  : 	/* Round 1 */
; 129  : 	FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */
; 130  : 	FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */
; 131  : 	FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */
; 132  : 	FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */
; 133  : 	FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */
; 134  : 	FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */
; 135  : 	FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */
; 136  : 	FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */
; 137  : 	FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */
; 138  : 	FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */
; 139  : 	FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
; 140  : 	FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
; 141  : 	FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
; 142  : 	FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
; 143  : 	FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
; 144  : 	FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
; 145  : 
; 146  : 	/* Round 2 */
; 147  : 	GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */
; 148  : 	GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */
; 149  : 	GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
; 150  : 	GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */
; 151  : 	GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */
; 152  : 	GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */
; 153  : 	GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
; 154  : 	GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */
; 155  : 	GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */
; 156  : 	GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
; 157  : 	GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */
; 158  : 	GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */
; 159  : 	GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
; 160  : 	GG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */
; 161  : 	GG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */
; 162  : 	GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
; 163  : 
; 164  : 	/* Round 3 */
; 165  : 	HH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */
; 166  : 	HH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */
; 167  : 	HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
; 168  : 	HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
; 169  : 	HH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */
; 170  : 	HH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */
; 171  : 	HH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */
; 172  : 	HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
; 173  : 	HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
; 174  : 	HH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */
; 175  : 	HH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */
; 176  : 	HH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */
; 177  : 	HH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */
; 178  : 	HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
; 179  : 	HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
; 180  : 	HH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */
; 181  : 
; 182  : 	/* Round 4 */
; 183  : 	II(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */
; 184  : 	II(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */
; 185  : 	II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
; 186  : 	II(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */
; 187  : 	II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
; 188  : 	II(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */
; 189  : 	II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
; 190  : 	II(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */
; 191  : 	II(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */
; 192  : 	II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
; 193  : 	II(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */
; 194  : 	II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
; 195  : 	II(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */
; 196  : 	II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
; 197  : 	II(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */
; 198  : 	II(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */
; 199  : 
; 200  : 	state[0] += a;

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	esi, 6

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	esi, edx

; 40   : 	return y ^ (x | ~z);

	or	eax, esi
	xor	eax, edx
	lea	edx, DWORD PTR [ebx-1120210379]
	add	eax, DWORD PTR _x$[ebp+44]
	mov	ebx, DWORD PTR _b$16$[ebp]
	add	edx, eax

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	edx, 10					; 0000000aH

; 40   : 	return y ^ (x | ~z);

	mov	eax, ebx
	not	eax

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	edx, esi

; 40   : 	return y ^ (x | ~z);

	or	eax, edx
	xor	eax, esi

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	eax, DWORD PTR _x$[ebp+8]
	add	ecx, eax

; 126  : 	decode(x, block, blocksize);
; 127  : 
; 128  : 	/* Round 1 */
; 129  : 	FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */
; 130  : 	FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */
; 131  : 	FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */
; 132  : 	FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */
; 133  : 	FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */
; 134  : 	FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */
; 135  : 	FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */
; 136  : 	FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */
; 137  : 	FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */
; 138  : 	FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */
; 139  : 	FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
; 140  : 	FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
; 141  : 	FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
; 142  : 	FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
; 143  : 	FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
; 144  : 	FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
; 145  : 
; 146  : 	/* Round 2 */
; 147  : 	GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */
; 148  : 	GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */
; 149  : 	GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
; 150  : 	GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */
; 151  : 	GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */
; 152  : 	GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */
; 153  : 	GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
; 154  : 	GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */
; 155  : 	GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */
; 156  : 	GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
; 157  : 	GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */
; 158  : 	GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */
; 159  : 	GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
; 160  : 	GG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */
; 161  : 	GG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */
; 162  : 	GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
; 163  : 
; 164  : 	/* Round 3 */
; 165  : 	HH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */
; 166  : 	HH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */
; 167  : 	HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
; 168  : 	HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
; 169  : 	HH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */
; 170  : 	HH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */
; 171  : 	HH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */
; 172  : 	HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
; 173  : 	HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
; 174  : 	HH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */
; 175  : 	HH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */
; 176  : 	HH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */
; 177  : 	HH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */
; 178  : 	HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
; 179  : 	HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
; 180  : 	HH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */
; 181  : 
; 182  : 	/* Round 4 */
; 183  : 	II(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */
; 184  : 	II(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */
; 185  : 	II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
; 186  : 	II(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */
; 187  : 	II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
; 188  : 	II(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */
; 189  : 	II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
; 190  : 	II(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */
; 191  : 	II(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */
; 192  : 	II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
; 193  : 	II(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */
; 194  : 	II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
; 195  : 	II(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */
; 196  : 	II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
; 197  : 	II(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */
; 198  : 	II(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */
; 199  : 
; 200  : 	state[0] += a;

	mov	eax, DWORD PTR _a$1$[ebp]
	add	eax, esi

; 44   : 	return (x << n) | (x >> (32 - n));

	rol	ecx, 15					; 0000000fH

; 60   : 	a = rotate_left(a + I(b, c, d) + x + ac, s) + b;

	add	ecx, edx

; 126  : 	decode(x, block, blocksize);
; 127  : 
; 128  : 	/* Round 1 */
; 129  : 	FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */
; 130  : 	FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */
; 131  : 	FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */
; 132  : 	FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */
; 133  : 	FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */
; 134  : 	FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */
; 135  : 	FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */
; 136  : 	FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */
; 137  : 	FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */
; 138  : 	FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */
; 139  : 	FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
; 140  : 	FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
; 141  : 	FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
; 142  : 	FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
; 143  : 	FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
; 144  : 	FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
; 145  : 
; 146  : 	/* Round 2 */
; 147  : 	GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */
; 148  : 	GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */
; 149  : 	GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
; 150  : 	GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */
; 151  : 	GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */
; 152  : 	GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */
; 153  : 	GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
; 154  : 	GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */
; 155  : 	GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */
; 156  : 	GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
; 157  : 	GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */
; 158  : 	GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */
; 159  : 	GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
; 160  : 	GG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */
; 161  : 	GG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */
; 162  : 	GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
; 163  : 
; 164  : 	/* Round 3 */
; 165  : 	HH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */
; 166  : 	HH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */
; 167  : 	HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
; 168  : 	HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
; 169  : 	HH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */
; 170  : 	HH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */
; 171  : 	HH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */
; 172  : 	HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
; 173  : 	HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
; 174  : 	HH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */
; 175  : 	HH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */
; 176  : 	HH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */
; 177  : 	HH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */
; 178  : 	HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
; 179  : 	HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
; 180  : 	HH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */
; 181  : 
; 182  : 	/* Round 4 */
; 183  : 	II(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */
; 184  : 	II(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */
; 185  : 	II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
; 186  : 	II(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */
; 187  : 	II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
; 188  : 	II(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */
; 189  : 	II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
; 190  : 	II(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */
; 191  : 	II(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */
; 192  : 	II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
; 193  : 	II(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */
; 194  : 	II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
; 195  : 	II(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */
; 196  : 	II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
; 197  : 	II(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */
; 198  : 	II(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */
; 199  : 
; 200  : 	state[0] += a;

	mov	DWORD PTR [edi+76], eax

; 202  : 	state[2] += c;

	add	DWORD PTR [edi+84], ecx

; 40   : 	return y ^ (x | ~z);

	lea	eax, DWORD PTR [ebx-343485551]
	not	esi
	or	esi, ecx
	xor	esi, edx
	add	esi, DWORD PTR _x$[ebp+36]
	add	eax, esi

; 44   : 	return (x << n) | (x >> (32 - n));

	ror	eax, 11					; 0000000bH

; 201  : 	state[1] += b;

	add	eax, DWORD PTR [edi+80]
	add	eax, ecx

; 203  : 	state[3] += d;

	add	DWORD PTR [edi+88], edx

; 204  : 
; 205  : 	// Zeroize sensitive information.  
; 206  : 	memset(x, 0, sizeof x);
; 207  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [edi+80], eax
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?transform@MD5@thatboy@@AAEXQBE@Z ENDP			; thatboy::MD5::transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?update@MD5@thatboy@@QAEXPBEI@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_length$ = 12						; size = 4
?update@MD5@thatboy@@QAEXPBEI@Z PROC			; thatboy::MD5::update, COMDAT
; _this$ = ecx

; 213  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx

; 214  : 	// 计算字节数对64取模
; 215  : 	size_type index = count[0] / 8 % blocksize;
; 216  : 
; 217  : 	// 更新位数
; 218  : 	if ((count[0] += (length << 3)) < (length << 3))

	mov	ecx, DWORD PTR _length$[ebp]
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebx+68]
	mov	esi, eax
	shr	esi, 3
	and	esi, 63					; 0000003fH
	lea	edx, DWORD PTR [eax+ecx*8]
	lea	eax, DWORD PTR [ecx*8]
	mov	DWORD PTR [ebx+68], edx
	cmp	edx, eax
	mov	edx, DWORD PTR [ebx+72]
	jae	SHORT $LN5@update

; 219  : 		count[1]++;

	inc	edx
$LN5@update:

; 220  : 	count[1] += (length >> 29);

	mov	eax, ecx

; 221  : 
; 222  : 	// 需要填充字节数
; 223  : 	size_type firstpart = 64 - index;

	mov	edi, 64					; 00000040H
	shr	eax, 29					; 0000001dH
	sub	edi, esi
	add	eax, edx
	mov	DWORD PTR [ebx+72], eax

; 224  : 
; 225  : 	size_type i;
; 226  : 
; 227  : 	// 多次变换
; 228  : 	if (length >= firstpart)

	cmp	ecx, edi
	jb	SHORT $LN6@update

; 229  : 	{
; 230  : 		memcpy(&buffer[index], input, firstpart);

	push	edi
	push	DWORD PTR _input$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	add	eax, esi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 231  : 		transform(buffer);

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, ebx
	push	eax
	call	?transform@MD5@thatboy@@AAEXQBE@Z	; thatboy::MD5::transform

; 232  : 
; 233  : 		for (i = firstpart; i + blocksize <= length; i += blocksize)

	mov	ecx, DWORD PTR _length$[ebp]
	lea	esi, DWORD PTR [edi+64]
	cmp	esi, ecx
	ja	SHORT $LN3@update
$LL4@update:

; 234  : 			transform(&input[i]);

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, ebx
	add	eax, -64				; ffffffc0H
	add	eax, esi
	push	eax
	call	?transform@MD5@thatboy@@AAEXQBE@Z	; thatboy::MD5::transform
	mov	ecx, DWORD PTR _length$[ebp]
	add	esi, 64					; 00000040H
	add	edi, 64					; 00000040H
	cmp	esi, ecx
	jbe	SHORT $LL4@update
$LN3@update:

; 235  : 
; 236  : 		index = 0;

	xor	esi, esi

; 237  : 	}

	jmp	SHORT $LN7@update
$LN6@update:

; 238  : 	else
; 239  : 		i = 0;

	xor	edi, edi
$LN7@update:

; 240  : 
; 241  : 	memcpy(&buffer[index], &input[i], length - i);

	mov	eax, DWORD PTR _input$[ebp]
	sub	ecx, edi
	add	eax, edi
	push	ecx
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	add	eax, esi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 242  : }

	pop	ebp
	ret	8
?update@MD5@thatboy@@QAEXPBEI@Z ENDP			; thatboy::MD5::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?update@MD5@thatboy@@QAEXPBDI@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_length$ = 12						; size = 4
?update@MD5@thatboy@@QAEXPBDI@Z PROC			; thatboy::MD5::update, COMDAT
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp

; 248  : }

	pop	ebp

; 247  : 	update((const unsigned char*)input, length);

	jmp	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update
?update@MD5@thatboy@@QAEXPBDI@Z ENDP			; thatboy::MD5::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?finalize@MD5@thatboy@@QAEAAV12@XZ
_TEXT	SEGMENT
_bits$1 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
?finalize@MD5@thatboy@@QAEAAV12@XZ PROC			; thatboy::MD5::finalize, COMDAT
; _this$ = ecx

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 253  : 	static unsigned char padding[64] = {
; 254  : 		0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
; 255  : 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
; 256  : 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
; 257  : 	};
; 258  : 
; 259  : 	if (!finalized) {

	cmp	BYTE PTR [esi], 0
	jne	$LN24@finalize

; 260  : 		// 保存位数 
; 261  : 		unsigned char bits[8];
; 262  : 		encode(bits, count, 8);

	xor	edx, edx
	lea	ecx, DWORD PTR [esi+70]
$LL9@finalize:

; 113  : 		output[j] = input[i] & 0xff;

	movzx	eax, BYTE PTR [ecx-2]
	lea	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR _bits$1[ebp+edx], al

; 114  : 		output[j + 1] = (input[i] >> 8) & 0xff;

	movzx	eax, BYTE PTR [ecx-5]
	mov	BYTE PTR _bits$1[ebp+edx+1], al

; 115  : 		output[j + 2] = (input[i] >> 16) & 0xff;

	movzx	eax, BYTE PTR [ecx-4]
	mov	BYTE PTR _bits$1[ebp+edx+2], al

; 116  : 		output[j + 3] = (input[i] >> 24) & 0xff;

	movzx	eax, BYTE PTR [ecx-3]
	mov	BYTE PTR _bits$1[ebp+edx+3], al
	add	edx, 4
	cmp	edx, 8
	jb	SHORT $LL9@finalize

; 263  : 
; 264  : 		// 填充
; 265  : 		size_type index = count[0] / 8 % 64;
; 266  : 		size_type padLen = (index < 56) ? (56 - index) : (120 - index);
; 267  : 		update(padding, padLen);

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, 120				; 00000078H
	shr	edx, 3
	mov	eax, 56					; 00000038H
	and	edx, 63					; 0000003fH
	sub	ecx, edx
	sub	eax, edx
	cmp	edx, 56					; 00000038H
	push	edi
	cmovae	eax, ecx
	mov	ecx, esi
	push	eax
	push	OFFSET ?padding@?1??finalize@MD5@thatboy@@QAEAAV23@XZ@4PAEA
	call	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update

; 268  : 
; 269  : 		// 增加长度
; 270  : 		update(bits, 8);

	push	8
	lea	eax, DWORD PTR _bits$1[ebp]
	mov	ecx, esi
	push	eax
	call	?update@MD5@thatboy@@QAEXPBEI@Z		; thatboy::MD5::update
	lea	edx, DWORD PTR [esi+94]
	mov	edi, 4
	lea	eax, DWORD PTR [esi+78]
	npad	1
$LL14@finalize:

; 113  : 		output[j] = input[i] & 0xff;

	movzx	ecx, BYTE PTR [eax-2]
	lea	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [edx-2], cl
	lea	edx, DWORD PTR [edx+4]

; 114  : 		output[j + 1] = (input[i] >> 8) & 0xff;

	movzx	ecx, BYTE PTR [eax-5]
	mov	BYTE PTR [edx-5], cl

; 115  : 		output[j + 2] = (input[i] >> 16) & 0xff;

	movzx	ecx, BYTE PTR [eax-4]
	mov	BYTE PTR [edx-4], cl

; 116  : 		output[j + 3] = (input[i] >> 24) & 0xff;

	movzx	ecx, BYTE PTR [eax-3]
	mov	BYTE PTR [edx-3], cl
	sub	edi, 1
	jne	SHORT $LL14@finalize

; 271  : 
; 272  : 		// 存储状态
; 273  : 		encode(digest, state, 16);
; 274  : 
; 275  : 		// 清零  
; 276  : 		memset(buffer, 0, sizeof buffer);

	push	64					; 00000040H
	lea	ecx, DWORD PTR [esi+1]
	push	edi
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	xorps	xmm0, xmm0

; 277  : 		memset(count, 0, sizeof count);

	movq	QWORD PTR [esi+68], xmm0

; 278  : 
; 279  : 		finalized = true;

	mov	BYTE PTR [esi], 1

; 280  : 	}
; 281  : 
; 282  : 	return *this;

	pop	edi
$LN24@finalize:

; 283  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?finalize@MD5@thatboy@@QAEAAV12@XZ ENDP			; thatboy::MD5::finalize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?hexdigest@MD5@thatboy@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -44				; size = 4
_buf$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?hexdigest@MD5@thatboy@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; thatboy::MD5::hexdigest, COMDAT
; _this$ = ecx

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 290  : 	if (!finalized)

	cmp	BYTE PTR [ecx], 0
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	jne	SHORT $LN2@hexdigest
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	push	OFFSET ??_C@_00CNPNBAHC@@
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp

; 291  : 		return "";

	jmp	SHORT $LN24@hexdigest
$LN2@hexdigest:

; 292  : 
; 293  : 	char buf[33];
; 294  : 	sprintf_s(buf, 33, "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",

	movzx	eax, BYTE PTR [ecx+107]
	push	eax
	movzx	eax, BYTE PTR [ecx+106]
	push	eax
	movzx	eax, BYTE PTR [ecx+105]
	push	eax
	movzx	eax, BYTE PTR [ecx+104]
	push	eax
	movzx	eax, BYTE PTR [ecx+103]
	push	eax
	movzx	eax, BYTE PTR [ecx+102]
	push	eax
	movzx	eax, BYTE PTR [ecx+101]
	push	eax
	movzx	eax, BYTE PTR [ecx+100]
	push	eax
	movzx	eax, BYTE PTR [ecx+99]
	push	eax
	movzx	eax, BYTE PTR [ecx+98]
	push	eax
	movzx	eax, BYTE PTR [ecx+97]
	push	eax
	movzx	eax, BYTE PTR [ecx+96]
	push	eax
	movzx	eax, BYTE PTR [ecx+95]
	push	eax
	movzx	eax, BYTE PTR [ecx+94]
	push	eax
	movzx	eax, BYTE PTR [ecx+93]
	push	eax
	movzx	eax, BYTE PTR [ecx+92]
	push	eax
	push	OFFSET ??_C@_0EB@KPGMAIDL@?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02X?$CF02@
	lea	eax, DWORD PTR _buf$[ebp]
	push	33					; 00000021H
	push	eax
	call	_sprintf_s
	add	esp, 76					; 0000004cH

; 295  : 			  digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7],
; 296  : 			  digest[8], digest[9], digest[10], digest[11], digest[12], digest[13], digest[14], digest[15]);
; 297  : 	buf[32] = 0;

	mov	BYTE PTR _buf$[ebp+32], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2337 :         assign(_Ptr);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
$LN24@hexdigest:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp

; 300  : }

	mov	DWORD PTR [esi+16], 0
	mov	ecx, esi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	BYTE PTR [esi], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?hexdigest@MD5@thatboy@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; thatboy::MD5::hexdigest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp
;	COMDAT ?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -128				; size = 4
___$ReturnUdt$ = -128					; size = 4
_md5$ = -124						; size = 108
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 24
?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z PROC ; thatboy::md5, COMDAT
; ___$ReturnUdt$ = ecx

; 312  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 313  : 	MD5 md5(str);

	lea	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	call	??0MD5@thatboy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; thatboy::MD5::MD5

; 314  : 	return md5.hexdigest();

	push	esi
	lea	ecx, DWORD PTR _md5$[ebp]
	call	?hexdigest@MD5@thatboy@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; thatboy::MD5::hexdigest
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _str$[ebp+20]
	cmp	edx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN18@md5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN28@md5

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN28@md5
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN28@md5:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@md5:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\MD5.cpp

; 314  : 	return md5.hexdigest();

	mov	eax, esi

; 315  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@md5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z$0:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?md5@thatboy@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ENDP ; thatboy::md5
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 3579 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3580 :     }

	ret	0
$LN8@data:

; 3579 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3580 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 122  :             return _Ok;

	mov	al, BYTE PTR [ecx+4]

; 123  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 111  : #if _HAS_EXCEPTIONS
; 112  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 113  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios

; 80   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 80   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 81   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 114  :             }
; 115  : #else // _HAS_EXCEPTIONS
; 116  :             this->_Myostr._Osfx();
; 117  : #endif // _HAS_EXCEPTIONS
; 118  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	edi, DWORD PTR __Ostr$[ebp]

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR [esi], edi

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios

; 80   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 73   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN8@sentry

; 74   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi]
$LN8@sentry:

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xiosbase

; 280  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]

; 299  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+edi+12], 0

; 280  :         return _Mystate;

	lea	ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 93   :             if (!_Ostr.good()) {

	je	SHORT $LN2@sentry

; 94   :                 _Ok = false;

	xor	al, al

; 95   :                 return;

	jmp	SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios

; 70   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN4@sentry
	cmp	ecx, edi
	je	SHORT $LN4@sentry

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+edi+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN23@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

	mov	al, 1
$LN23@sentry:

; 107  :         }

	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios

; 80   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 80   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ios

; 80   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream

; 73   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN6@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 75   :             }
; 76   :         }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 405  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 406  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 397  :         return _Left == _Right;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 398  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3593 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3594 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsprintf_s_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1497 :     {

	push	ebp
	mov	ebp, esp

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1503 :     }

	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

	push	ebp
	mov	ebp, esp

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);
; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1846 :             __crt_va_end(_ArgList);
; 1847 :             return _Result;
; 1848 :         }

	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4185 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4186 :         _Mypair._Myval2._Orphan_all();
; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 4199 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2627 :     ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 2635 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2186 :         _Bxty() {} // user-provided, for fancy pointers

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 2188 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1251 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	eax, ecx
	ret	8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 4183 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 365  :         const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	edx
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 368  :     }

	pop	ebp
	ret	0
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 2883 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	push	esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 2883 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Count$[ebp]
	push	edi
	push	DWORD PTR __Ptr$[ebp]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2884 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 2886 :             },

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4103 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4104 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4105 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4106 :         if (_New_size > max_size()) {

	mov	eax, DWORD PTR __New_size$[ebp]
	push	ebx
	mov	ebx, ecx
	push	edi
	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN61@Reallocate

; 4108 :         }
; 4109 : 
; 4110 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4108 :         }
; 4109 : 
; 4110 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	DWORD PTR __Old$1$[ebp], ecx

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4088 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Reallocate

; 4092 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4113 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN62@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN53@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR _<_Args_0>$[ebp]

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi

; 4116 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [ebx+20], esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	eax, DWORD PTR __New_size$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4117 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+eax], 0

; 4117 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	pop	esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4119 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4125 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	ebx

; 4126 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN61@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4107 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN62@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN59@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T12 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2871 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2872 :         // assign [_Ptr, _Ptr + _Count)
; 2873 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	edi, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	edi, ecx
	ja	SHORT $LN2@assign

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN5@assign:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[ebp]

; 2874 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2875 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], edi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 2876 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2877 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR [ebx+edi], 0

; 2888 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:

; 4106 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN74@assign

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN19@assign

; 4088 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN18@assign
$LN19@assign:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN20@assign

; 4092 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN18@assign
$LN20@assign:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4113 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN27@assign

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN75@assign

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN63@assign

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN72@assign
$LN27@assign:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN28@assign

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN72@assign
$LN28@assign:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN72@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[ebp]

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR $T12[ebp], eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 4116 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	ebx, DWORD PTR $T12[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	eax, DWORD PTR __Old$1$[ebp]

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [ebx+edi], 0

; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@assign

; 4119 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN66@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN63@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN66@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2881 :         return _Reallocate_for(

	mov	DWORD PTR [esi], ebx

; 2888 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN63@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4107 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN75@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN70@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 987  :     // convert size_t to size_t, unchanged
; 988  :     return _Len;

	mov	eax, ecx

; 989  : }

	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 310  :         // find length of null-terminated string
; 311  : #if _HAS_CXX17
; 312  : #ifdef __cpp_char8_t
; 313  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 314  : #if _HAS_U8_INTRINSICS
; 315  :             return __builtin_u8strlen(_First);
; 316  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 317  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 318  : #endif // _HAS_U8_INTRINSICS
; 319  :         } else
; 320  : #endif // __cpp_char8_t
; 321  :         {
; 322  :             return __builtin_strlen(_First);
; 323  :         }
; 324  : #else // _HAS_CXX17
; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edx, DWORD PTR [ecx+1]
$LL3@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@length
	sub	ecx, edx
	mov	eax, ecx

; 326  : #endif // _HAS_CXX17
; 327  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
$T14 = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2890 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]

; 2890 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	sub	esp, 8
	push	ebx
	push	esi

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	esi, edx

; 2890 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	push	edi
	mov	edi, ecx

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	ecx, DWORD PTR [esi+1]
$LL75@assign:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL75@assign
	sub	esi, ecx

; 2873 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	esi, ecx
	ja	SHORT $LN6@assign

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, edi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [edi]
$LN9@assign:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	push	edx
	push	ebx

; 2875 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [edi+16], esi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	call	_memmove
	add	esp, 12					; 0000000cH

; 2877 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR [ebx+esi], 0

; 2891 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2892 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@assign:

; 4106 :         if (_New_size > max_size()) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN79@assign

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, esi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN23@assign

; 4088 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN22@assign
$LN23@assign:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN24@assign

; 4092 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN22@assign
$LN24@assign:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN22@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4113 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN31@assign

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN80@assign

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN67@assign

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN77@assign
$LN31@assign:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN32@assign

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN77@assign
$LN32@assign:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN77@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	DWORD PTR __Ptr$[ebp]

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR $T14[ebp], eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [edi+16], esi

; 4116 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], ebx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	ebx, DWORD PTR $T14[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	eax, DWORD PTR __Old$1$[ebp]

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [ebx+esi], 0

; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN17@assign

; 4119 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN70@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN67@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN70@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN17@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2881 :         return _Reallocate_for(

	mov	DWORD PTR [edi], ebx

; 2891 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2892 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN67@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN79@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4107 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN80@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN76@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$dead$ = ecx

; 1254 :     void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2333 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

	push	ebp
	mov	ebp, esp
	push	esi

; 2334 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2335 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2336 :         _Tidy_init();
; 2337 :         assign(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	mov	esi, ecx

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0

; 2334 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2335 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2336 :         _Tidy_init();
; 2337 :         assign(_Ptr);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2338 :         _Proxy._Release();
; 2339 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 3575 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3576 :     }

	ret	0
$LN8@c_str:

; 3575 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3576 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
END
