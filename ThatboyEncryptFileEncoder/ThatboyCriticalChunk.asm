; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\thatboycriticalchunk.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2TDAT_Chunk@thatboy@@8			; thatboy::TDAT_Chunk::`RTTI Base Class Array'
PUBLIC	??_R2TEND_Chunk@thatboy@@8			; thatboy::TEND_Chunk::`RTTI Base Class Array'
PUBLIC	??_R2THDR_Chunk@thatboy@@8			; thatboy::THDR_Chunk::`RTTI Base Class Array'
PUBLIC	??_R2Chunk@thatboy@@8				; thatboy::Chunk::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TDAT_Chunk@thatboy@@8		; thatboy::TDAT_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@TEND_Chunk@thatboy@@8		; thatboy::TEND_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@THDR_Chunk@thatboy@@8		; thatboy::THDR_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Chunk@thatboy@@8			; thatboy::Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3TDAT_Chunk@thatboy@@8			; thatboy::TDAT_Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVTDAT_Chunk@thatboy@@@8			; thatboy::TDAT_Chunk `RTTI Type Descriptor'
PUBLIC	??_R3TEND_Chunk@thatboy@@8			; thatboy::TEND_Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVTEND_Chunk@thatboy@@@8			; thatboy::TEND_Chunk `RTTI Type Descriptor'
PUBLIC	??_R3THDR_Chunk@thatboy@@8			; thatboy::THDR_Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVTHDR_Chunk@thatboy@@@8			; thatboy::THDR_Chunk `RTTI Type Descriptor'
PUBLIC	??_R3Chunk@thatboy@@8				; thatboy::Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUChunk@thatboy@@@8			; thatboy::Chunk `RTTI Type Descriptor'
PUBLIC	??_R4TDAT_Chunk@thatboy@@6B@			; thatboy::TDAT_Chunk::`RTTI Complete Object Locator'
PUBLIC	??_R4TEND_Chunk@thatboy@@6B@			; thatboy::TEND_Chunk::`RTTI Complete Object Locator'
PUBLIC	??_R4THDR_Chunk@thatboy@@6B@			; thatboy::THDR_Chunk::`RTTI Complete Object Locator'
PUBLIC	??_R4Chunk@thatboy@@6B@				; thatboy::Chunk::`RTTI Complete Object Locator'
PUBLIC	??_7TDAT_Chunk@thatboy@@6B@			; thatboy::TDAT_Chunk::`vftable'
PUBLIC	??_7TEND_Chunk@thatboy@@6B@			; thatboy::TEND_Chunk::`vftable'
PUBLIC	??_7Chunk@thatboy@@6B@				; thatboy::Chunk::`vftable'
PUBLIC	??_7THDR_Chunk@thatboy@@6B@			; thatboy::THDR_Chunk::`vftable'
EXTRN	__imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z:PROC
EXTRN	__imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z:PROC
EXTRN	__imp_??_V@YAXPAX@Z:PROC
EXTRN	__imp_??_U@YAPAXI@Z:PROC
;	COMDAT ??_7THDR_Chunk@thatboy@@6B@
CONST	SEGMENT
??_7THDR_Chunk@thatboy@@6B@ DD FLAT:??_R4THDR_Chunk@thatboy@@6B@ ; thatboy::THDR_Chunk::`vftable'
	DD	FLAT:?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?checkCrcCode@THDR_Chunk@thatboy@@UBE_NE@Z
	DD	FLAT:?doFigure@THDR_Chunk@thatboy@@UAEXE@Z
CONST	ENDS
;	COMDAT ??_7Chunk@thatboy@@6B@
CONST	SEGMENT
??_7Chunk@thatboy@@6B@ DD FLAT:??_R4Chunk@thatboy@@6B@	; thatboy::Chunk::`vftable'
	DD	FLAT:?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?checkCrcCode@Chunk@thatboy@@UBE_NE@Z
	DD	FLAT:?doFigure@Chunk@thatboy@@UAEXE@Z
CONST	ENDS
;	COMDAT ??_7TEND_Chunk@thatboy@@6B@
CONST	SEGMENT
??_7TEND_Chunk@thatboy@@6B@ DD FLAT:??_R4TEND_Chunk@thatboy@@6B@ ; thatboy::TEND_Chunk::`vftable'
	DD	FLAT:?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?checkCrcCode@TEND_Chunk@thatboy@@UBE_NE@Z
	DD	FLAT:?doFigure@TEND_Chunk@thatboy@@UAEXE@Z
CONST	ENDS
;	COMDAT ??_7TDAT_Chunk@thatboy@@6B@
CONST	SEGMENT
??_7TDAT_Chunk@thatboy@@6B@ DD FLAT:??_R4TDAT_Chunk@thatboy@@6B@ ; thatboy::TDAT_Chunk::`vftable'
	DD	FLAT:?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
	DD	FLAT:?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z
	DD	FLAT:?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z
CONST	ENDS
;	COMDAT ??_R4Chunk@thatboy@@6B@
rdata$r	SEGMENT
??_R4Chunk@thatboy@@6B@ DD 00H				; thatboy::Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUChunk@thatboy@@@8
	DD	FLAT:??_R3Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R4THDR_Chunk@thatboy@@6B@
rdata$r	SEGMENT
??_R4THDR_Chunk@thatboy@@6B@ DD 00H			; thatboy::THDR_Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTHDR_Chunk@thatboy@@@8
	DD	FLAT:??_R3THDR_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R4TEND_Chunk@thatboy@@6B@
rdata$r	SEGMENT
??_R4TEND_Chunk@thatboy@@6B@ DD 00H			; thatboy::TEND_Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTEND_Chunk@thatboy@@@8
	DD	FLAT:??_R3TEND_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R4TDAT_Chunk@thatboy@@6B@
rdata$r	SEGMENT
??_R4TDAT_Chunk@thatboy@@6B@ DD 00H			; thatboy::TDAT_Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTDAT_Chunk@thatboy@@@8
	DD	FLAT:??_R3TDAT_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUChunk@thatboy@@@8
data$r	SEGMENT
??_R0?AUChunk@thatboy@@@8 DD FLAT:??_7type_info@@6B@	; thatboy::Chunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUChunk@thatboy@@', 00H
data$r	ENDS
;	COMDAT ??_R3Chunk@thatboy@@8
rdata$r	SEGMENT
??_R3Chunk@thatboy@@8 DD 00H				; thatboy::Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTHDR_Chunk@thatboy@@@8
data$r	SEGMENT
??_R0?AVTHDR_Chunk@thatboy@@@8 DD FLAT:??_7type_info@@6B@ ; thatboy::THDR_Chunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTHDR_Chunk@thatboy@@', 00H
data$r	ENDS
;	COMDAT ??_R3THDR_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R3THDR_Chunk@thatboy@@8 DD 00H			; thatboy::THDR_Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2THDR_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTEND_Chunk@thatboy@@@8
data$r	SEGMENT
??_R0?AVTEND_Chunk@thatboy@@@8 DD FLAT:??_7type_info@@6B@ ; thatboy::TEND_Chunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTEND_Chunk@thatboy@@', 00H
data$r	ENDS
;	COMDAT ??_R3TEND_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R3TEND_Chunk@thatboy@@8 DD 00H			; thatboy::TEND_Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2TEND_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTDAT_Chunk@thatboy@@@8
data$r	SEGMENT
??_R0?AVTDAT_Chunk@thatboy@@@8 DD FLAT:??_7type_info@@6B@ ; thatboy::TDAT_Chunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTDAT_Chunk@thatboy@@', 00H
data$r	ENDS
;	COMDAT ??_R3TDAT_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R3TDAT_Chunk@thatboy@@8 DD 00H			; thatboy::TDAT_Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2TDAT_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Chunk@thatboy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Chunk@thatboy@@8 DD FLAT:??_R0?AUChunk@thatboy@@@8 ; thatboy::Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@THDR_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@THDR_Chunk@thatboy@@8 DD FLAT:??_R0?AVTHDR_Chunk@thatboy@@@8 ; thatboy::THDR_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3THDR_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@TEND_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TEND_Chunk@thatboy@@8 DD FLAT:??_R0?AVTEND_Chunk@thatboy@@@8 ; thatboy::TEND_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TEND_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@TDAT_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TDAT_Chunk@thatboy@@8 DD FLAT:??_R0?AVTDAT_Chunk@thatboy@@@8 ; thatboy::TDAT_Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TDAT_Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R2Chunk@thatboy@@8
rdata$r	SEGMENT
??_R2Chunk@thatboy@@8 DD FLAT:??_R1A@?0A@EA@Chunk@thatboy@@8 ; thatboy::Chunk::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2THDR_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R2THDR_Chunk@thatboy@@8 DD FLAT:??_R1A@?0A@EA@THDR_Chunk@thatboy@@8 ; thatboy::THDR_Chunk::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R2TEND_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R2TEND_Chunk@thatboy@@8 DD FLAT:??_R1A@?0A@EA@TEND_Chunk@thatboy@@8 ; thatboy::TEND_Chunk::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Chunk@thatboy@@8
rdata$r	ENDS
;	COMDAT ??_R2TDAT_Chunk@thatboy@@8
rdata$r	SEGMENT
??_R2TDAT_Chunk@thatboy@@8 DD FLAT:??_R1A@?0A@EA@TDAT_Chunk@thatboy@@8 ; thatboy::TDAT_Chunk::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Chunk@thatboy@@8
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??$_Uninitialized_copy@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$forward@V?$allocator@E@std@@@std@@YA$$QAV?$allocator@E@0@AAV10@@Z ; std::forward<std::allocator<unsigned char> >
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
PUBLIC	??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	?crcCompute@?$CRC@I@thatboy@@QAEIPBEI@Z		; thatboy::CRC<unsigned int>::crcCompute
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QBEPBEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z		; thatboy::TDAT_Chunk::doFigure
PUBLIC	??1TDAT_Chunk@thatboy@@QAE@XZ			; thatboy::TDAT_Chunk::~TDAT_Chunk
PUBLIC	??0TDAT_Chunk@thatboy@@QAE@ABV01@@Z		; thatboy::TDAT_Chunk::TDAT_Chunk
PUBLIC	?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z	; thatboy::TDAT_Chunk::checkCrcCode
PUBLIC	?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::TDAT_Chunk::read
PUBLIC	?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::TDAT_Chunk::write
PUBLIC	??0TDAT_Chunk@thatboy@@QAE@XZ			; thatboy::TDAT_Chunk::TDAT_Chunk
PUBLIC	?doFigure@TEND_Chunk@thatboy@@UAEXE@Z		; thatboy::TEND_Chunk::doFigure
PUBLIC	??0TEND_Chunk@thatboy@@QAE@ABV01@@Z		; thatboy::TEND_Chunk::TEND_Chunk
PUBLIC	?checkCrcCode@TEND_Chunk@thatboy@@UBE_NE@Z	; thatboy::TEND_Chunk::checkCrcCode
PUBLIC	??0TEND_Chunk@thatboy@@QAE@XZ			; thatboy::TEND_Chunk::TEND_Chunk
PUBLIC	?doFigure@THDR_Chunk@thatboy@@UAEXE@Z		; thatboy::THDR_Chunk::doFigure
PUBLIC	??0Chunk@thatboy@@QAE@ABU01@@Z			; thatboy::Chunk::Chunk
PUBLIC	??0THDR_Chunk@thatboy@@QAE@ABV01@@Z		; thatboy::THDR_Chunk::THDR_Chunk
PUBLIC	?checkCrcCode@THDR_Chunk@thatboy@@UBE_NE@Z	; thatboy::THDR_Chunk::checkCrcCode
PUBLIC	?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::THDR_Chunk::read
PUBLIC	?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::THDR_Chunk::write
PUBLIC	??0Chunk@thatboy@@QAE@XZ			; thatboy::Chunk::Chunk
PUBLIC	??0THDR_Chunk@thatboy@@QAE@XZ			; thatboy::THDR_Chunk::THDR_Chunk
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z$0
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ??0THDR_Chunk@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0THDR_Chunk@thatboy@@QAE@XZ PROC			; thatboy::THDR_Chunk::THDR_Chunk, COMDAT
; _this$ = ecx

; 8    : {

	mov	DWORD PTR [ecx], OFFSET ??_7THDR_Chunk@thatboy@@6B@

; 9    : 	Chunk::dataLength = sizeof(crcEncodeType) + sizeof(reserve);
; 10   : 	Chunk::typeCode = hdrChunkType;
; 11   : 	Chunk::crcCode = 0;
; 12   : 	crcEncodeType = static_cast<BYTE>(CRC32::CRC32_TYPE::eMPEG2);
; 13   : 	reserve[0] = reserve[1] = reserve[2] = 0;
; 14   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 4
	mov	DWORD PTR [ecx+8], 1380206676		; 52444854H
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 10			; 0000000aH
	ret	0
??0THDR_Chunk@thatboy@@QAE@XZ ENDP			; thatboy::THDR_Chunk::THDR_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Chunk@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0Chunk@thatboy@@QAE@XZ PROC				; thatboy::Chunk::Chunk, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7Chunk@thatboy@@6B@
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0Chunk@thatboy@@QAE@XZ ENDP				; thatboy::Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
_os$ = 8						; size = 4
?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::THDR_Chunk::write, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 7    : 	os.write((LPCSTR)&dataLength, sizeof(dataLength));

	mov	esi, DWORD PTR _os$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 17   : {

	push	edi
	mov	edi, ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 7    : 	os.write((LPCSTR)&dataLength, sizeof(dataLength));

	mov	ecx, esi
	push	0
	push	4
	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 8    : 	os.write((LPCSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 9    : 	os.write((LPCSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	eax, DWORD PTR [edi+12]
	mov	ecx, esi
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 19   : 	os.write((LPCSTR)&crcEncodeType, sizeof(crcEncodeType));

	push	0
	push	1
	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 20   : 	os.write((LPCSTR)reserve, sizeof(reserve));

	push	0
	push	3
	lea	ecx, DWORD PTR [edi+17]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 21   : 	return os;
; 22   : }

	pop	edi
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?write@THDR_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::THDR_Chunk::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
_is$ = 8						; size = 4
?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::THDR_Chunk::read, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 15   : 	is.read((LPSTR)&dataLength, sizeof(dataLength));

	mov	esi, DWORD PTR _is$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 25   : {

	push	edi
	mov	edi, ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 15   : 	is.read((LPSTR)&dataLength, sizeof(dataLength));

	mov	ecx, esi
	push	0
	push	4
	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 16   : 	is.read((LPSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 17   : 	is.read((LPSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	eax, DWORD PTR [edi+12]
	mov	ecx, esi
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 27   : 	is.read((LPSTR)&crcEncodeType, sizeof(crcEncodeType));

	push	0
	push	1
	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 28   : 	is.read((LPSTR)reserve, sizeof(reserve));

	push	0
	push	3
	lea	ecx, DWORD PTR [edi+17]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 29   : 	return is;
; 30   : }

	pop	edi
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?read@THDR_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::THDR_Chunk::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?checkCrcCode@THDR_Chunk@thatboy@@UBE_NE@Z
_TEXT	SEGMENT
_NChunk$ = -20						; size = 20
_crcEncodeType$ = 8					; size = 1
?checkCrcCode@THDR_Chunk@thatboy@@UBE_NE@Z PROC		; thatboy::THDR_Chunk::checkCrcCode, COMDAT
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 34   : 	THDR_Chunk NChunk(*this);
; 35   : 	NChunk.doFigure(crcEncodeType);

	push	DWORD PTR _crcEncodeType$[ebp]
	mov	esi, ecx
	mov	DWORD PTR _NChunk$[ebp], OFFSET ??_7THDR_Chunk@thatboy@@6B@
	lea	ecx, DWORD PTR _NChunk$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _NChunk$[ebp+4], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _NChunk$[ebp+8], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _NChunk$[ebp+12], eax
	movzx	eax, BYTE PTR [esi+16]
	mov	BYTE PTR _NChunk$[ebp+16], al
	mov	ax, WORD PTR [esi+17]
	mov	WORD PTR _NChunk$[ebp+17], ax
	movzx	eax, BYTE PTR [esi+19]
	mov	BYTE PTR _NChunk$[ebp+19], al
	call	?doFigure@THDR_Chunk@thatboy@@UAEXE@Z	; thatboy::THDR_Chunk::doFigure

; 36   : 	return NChunk.crcCode == crcCode;

	mov	eax, DWORD PTR _NChunk$[ebp+12]
	cmp	eax, DWORD PTR [esi+12]
	pop	esi
	sete	al

; 37   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?checkCrcCode@THDR_Chunk@thatboy@@UBE_NE@Z ENDP		; thatboy::THDR_Chunk::checkCrcCode
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0THDR_Chunk@thatboy@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0THDR_Chunk@thatboy@@QAE@ABV01@@Z PROC		; thatboy::THDR_Chunk::THDR_Chunk, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Chunk@thatboy@@6B@
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx], OFFSET ??_7THDR_Chunk@thatboy@@6B@
	movzx	eax, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+16], al
	mov	ax, WORD PTR [edx+17]
	mov	WORD PTR [ecx+17], ax
	movzx	eax, BYTE PTR [edx+19]
	mov	BYTE PTR [ecx+19], al
	mov	eax, ecx
	pop	ebp
	ret	4
??0THDR_Chunk@thatboy@@QAE@ABV01@@Z ENDP		; thatboy::THDR_Chunk::THDR_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Chunk@thatboy@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Chunk@thatboy@@QAE@ABU01@@Z PROC			; thatboy::Chunk::Chunk, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Chunk@thatboy@@6B@
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0Chunk@thatboy@@QAE@ABU01@@Z ENDP			; thatboy::Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?doFigure@THDR_Chunk@thatboy@@UAEXE@Z
_TEXT	SEGMENT
_crc$ = -1064						; size = 1048
_crcBuff$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_crcType$ = 8						; size = 1
?doFigure@THDR_Chunk@thatboy@@UAEXE@Z PROC		; thatboy::THDR_Chunk::doFigure, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1068				; 0000042cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1068], eax
	mov	al, BYTE PTR _crcType$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	bl, al

; 41   : 	Chunk::dataLength = sizeof(crcEncodeType) + sizeof(reserve);
; 42   : 	Chunk::typeCode = hdrChunkType;
; 43   : 	crcEncodeType = static_cast<BYTE>(CRC32::CRC32_TYPE(crcType));
; 44   : 	reserve[0] = reserve[1] = reserve[2] = 0;
; 45   : 
; 46   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcEncodeType));

	push	ebx
	lea	ecx, DWORD PTR _crc$[esp+1084]
	mov	BYTE PTR [edi+16], al
	mov	DWORD PTR [edi+4], 4
	mov	DWORD PTR [edi+8], 1380206676		; 52444854H
	mov	WORD PTR [edi+18], 0
	mov	BYTE PTR [edi+17], 0
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32

; 51   : 	memcpy(crcBuff + sizeof(typeCode) + sizeof(crcEncodeType), reserve, sizeof(reserve));

	mov	ax, WORD PTR [edi+17]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 51   : 	memcpy(crcBuff + sizeof(typeCode) + sizeof(crcEncodeType), reserve, sizeof(reserve));

	mov	WORD PTR _crcBuff$[esp+1085], ax
	movzx	eax, BYTE PTR [edi+19]
	mov	BYTE PTR _crcBuff$[esp+1084], bl
	mov	ebx, DWORD PTR _crc$[esp+2120]
	mov	BYTE PTR _crcBuff$[esp+1087], al
	add	ebx, -8					; fffffff8H
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	eax, DWORD PTR _crc$[esp+1084]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 49   : 	memcpy(crcBuff, (LPCSTR)&typeCode, sizeof(typeCode));

	mov	DWORD PTR _crcBuff$[esp+1080], 1380206676 ; 52444854H
$LL6@doFigure:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	edx, eax
	mov	ecx, ebx
	shr	edx, cl
	movzx	ecx, BYTE PTR _crcBuff$[esp+esi+1080]
	inc	esi
	movzx	edx, dl
	xor	edx, ecx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	eax, 8
	xor	eax, DWORD PTR _crc$[esp+edx*4+1096]
	cmp	esi, 8
	jb	SHORT $LL6@doFigure

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	xor	eax, DWORD PTR _crc$[esp+1088]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 54   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1080]
	mov	DWORD PTR [edi+12], eax
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?doFigure@THDR_Chunk@thatboy@@UAEXE@Z ENDP		; thatboy::THDR_Chunk::doFigure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ??0TEND_Chunk@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0TEND_Chunk@thatboy@@QAE@XZ PROC			; thatboy::TEND_Chunk::TEND_Chunk, COMDAT
; _this$ = ecx

; 59   : {

	mov	DWORD PTR [ecx], OFFSET ??_7TEND_Chunk@thatboy@@6B@

; 60   : 	Chunk::dataLength = 0;
; 61   : 	Chunk::typeCode = endChunkType;
; 62   : 	Chunk::crcCode = 0;
; 63   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 1145980244		; 444e4554H
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0TEND_Chunk@thatboy@@QAE@XZ ENDP			; thatboy::TEND_Chunk::TEND_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?checkCrcCode@TEND_Chunk@thatboy@@UBE_NE@Z
_TEXT	SEGMENT
_NChunk$ = -16						; size = 16
_crcEncodeType$ = 8					; size = 1
?checkCrcCode@TEND_Chunk@thatboy@@UBE_NE@Z PROC		; thatboy::TEND_Chunk::checkCrcCode, COMDAT
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	esi

; 67   : 	TEND_Chunk NChunk(*this);
; 68   : 	NChunk.doFigure(crcEncodeType);

	push	DWORD PTR _crcEncodeType$[ebp]
	mov	esi, ecx
	mov	DWORD PTR _NChunk$[esp+28], OFFSET ??_7TEND_Chunk@thatboy@@6B@
	lea	ecx, DWORD PTR _NChunk$[esp+28]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _NChunk$[esp+32], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _NChunk$[esp+36], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _NChunk$[esp+40], eax
	call	?doFigure@TEND_Chunk@thatboy@@UAEXE@Z	; thatboy::TEND_Chunk::doFigure

; 69   : 	return NChunk.crcCode == crcCode;

	mov	eax, DWORD PTR _NChunk$[esp+36]
	cmp	eax, DWORD PTR [esi+12]

; 70   : }

	pop	esi
	sete	al
	mov	esp, ebp
	pop	ebp
	ret	4
?checkCrcCode@TEND_Chunk@thatboy@@UBE_NE@Z ENDP		; thatboy::TEND_Chunk::checkCrcCode
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0TEND_Chunk@thatboy@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TEND_Chunk@thatboy@@QAE@ABV01@@Z PROC		; thatboy::TEND_Chunk::TEND_Chunk, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Chunk@thatboy@@6B@
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7TEND_Chunk@thatboy@@6B@
	pop	ebp
	ret	4
??0TEND_Chunk@thatboy@@QAE@ABV01@@Z ENDP		; thatboy::TEND_Chunk::TEND_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?doFigure@TEND_Chunk@thatboy@@UAEXE@Z
_TEXT	SEGMENT
_crc$ = -1056						; size = 1048
__$ArrayPad$ = -4					; size = 4
_crcType$ = 8						; size = 1
?doFigure@TEND_Chunk@thatboy@@UAEXE@Z PROC		; thatboy::TEND_Chunk::doFigure, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1060], eax
	push	ebx
	push	esi
	push	edi

; 74   : 	Chunk::dataLength = 0;
; 75   : 	Chunk::typeCode = endChunkType;
; 76   : 
; 77   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	push	DWORD PTR _crcType$[ebp]
	mov	edi, ecx
	lea	ecx, DWORD PTR _crc$[esp+1076]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 1145980244		; 444e4554H
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
	mov	ebx, DWORD PTR _crc$[esp+2112]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
	mov	eax, DWORD PTR _crc$[esp+1076]
	add	ebx, -8					; fffffff8H
	npad	7
$LL6@doFigure:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	edx, eax
	mov	ecx, ebx
	shr	edx, cl
	movzx	ecx, BYTE PTR [edi+esi+8]
	inc	esi
	movzx	edx, dl
	xor	edx, ecx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	eax, 8
	xor	eax, DWORD PTR _crc$[esp+edx*4+1088]
	cmp	esi, 4
	jb	SHORT $LL6@doFigure

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	ecx, DWORD PTR _crc$[esp+1080]
	xor	ecx, eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 79   : 	Chunk::crcCode = crc.crcCompute((BYTE_CPTR)&typeCode, dataLength + sizeof(DWORD));

	mov	DWORD PTR [edi+12], ecx

; 80   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1072]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?doFigure@TEND_Chunk@thatboy@@UAEXE@Z ENDP		; thatboy::TEND_Chunk::doFigure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ??0TDAT_Chunk@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0TDAT_Chunk@thatboy@@QAE@XZ PROC			; thatboy::TDAT_Chunk::TDAT_Chunk, COMDAT
; _this$ = ecx

; 85   : {

	mov	DWORD PTR [ecx], OFFSET ??_7TDAT_Chunk@thatboy@@6B@

; 89   : }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 86   : 	Chunk::dataLength = 0;

	mov	DWORD PTR [ecx+4], 0

; 87   : 	Chunk::typeCode = dataChunkType;

	mov	DWORD PTR [ecx+8], 1413563476		; 54414454H

; 88   : 	Chunk::crcCode = 0;

	mov	DWORD PTR [ecx+12], 0

; 89   : }

	ret	0
??0TDAT_Chunk@thatboy@@QAE@XZ ENDP			; thatboy::TDAT_Chunk::TDAT_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
_os$ = 8						; size = 4
?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::TDAT_Chunk::write, COMDAT
; _this$ = ecx

; 92   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	push	edi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 7    : 	os.write((LPCSTR)&dataLength, sizeof(dataLength));

	mov	edi, DWORD PTR _os$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 92   : {

	mov	ebx, ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 7    : 	os.write((LPCSTR)&dataLength, sizeof(dataLength));

	push	0
	push	4
	mov	ecx, edi
	lea	esi, DWORD PTR [ebx+4]
	push	esi
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 8    : 	os.write((LPCSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	eax, DWORD PTR [ebx+8]
	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 9    : 	os.write((LPCSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	eax, DWORD PTR [ebx+12]
	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 94   : 	return os.write((LPCSTR)compressData.data(), dataLength);

	push	0
	push	DWORD PTR [esi]
	mov	ecx, edi
	push	DWORD PTR [ebx+16]
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?write@TDAT_Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::TDAT_Chunk::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
tv244 = -4						; size = 4
_is$ = 8						; size = 4
?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::TDAT_Chunk::read, COMDAT
; _this$ = ecx

; 98   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 15   : 	is.read((LPSTR)&dataLength, sizeof(dataLength));

	mov	ebx, DWORD PTR _is$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 98   : {

	push	esi
	push	edi
	mov	esi, ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 15   : 	is.read((LPSTR)&dataLength, sizeof(dataLength));

	mov	ecx, ebx
	push	0
	push	4
	lea	edi, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR tv244[esp+28], edi
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 16   : 	is.read((LPSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	eax, DWORD PTR [esi+8]
	mov	ecx, ebx
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 17   : 	is.read((LPSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	eax, DWORD PTR [esi+12]
	mov	ecx, ebx
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+20]
	mov	ecx, ebx
	mov	edx, DWORD PTR [esi+16]
	sub	ecx, edx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 100  : 	compressData.resize(dataLength / sizeof(BYTE));

	mov	edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	edi, ecx
	jae	SHORT $LN8@read

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+edi]

; 1219 :             _Orphan_range(_Newlast, _Mylast);
; 1220 :             _Destroy(_Newlast, _Mylast);
; 1221 :             _Mylast = _Newlast;
; 1222 :             return;

	jmp	SHORT $LN18@read
$LN8@read:

; 1223 :         }
; 1224 : 
; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN9@read

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+24]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	edi, eax
	jbe	SHORT $LN10@read

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	edi
	lea	ecx, DWORD PTR [esi+16]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1229 :                 return;

	jmp	SHORT $LN9@read
$LN10@read:

; 1230 :             }
; 1231 : 
; 1232 :             const pointer _Oldlast = _Mylast;
; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	ebx
	call	_memset
	add	esp, 12					; 0000000cH

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [edi+ebx]
$LN18@read:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 101  : 	return is.read((LPSTR)compressData.data(), dataLength);

	mov	DWORD PTR [esi+20], eax
$LN9@read:
	mov	eax, DWORD PTR tv244[esp+16]
	mov	ecx, DWORD PTR _is$[ebp]
	push	0
	push	DWORD PTR [eax]
	push	DWORD PTR [esi+16]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?read@TDAT_Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::TDAT_Chunk::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z
_TEXT	SEGMENT
_NChunk$ = -48						; size = 28
__Rightlast$1$ = -20					; size = 4
__Rightfirst$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_crcEncodeType$ = 8					; size = 1
?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z PROC		; thatboy::TDAT_Chunk::checkCrcCode, COMDAT
; _this$ = ecx

; 105  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR _NChunk$[ebp+4], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _NChunk$[ebp+8], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _NChunk$[ebp+12], eax

; 375  : 
; 376  :     void _Swap_val(_Vector_val& _Right) noexcept {
; 377  :         this->_Swap_proxy_and_iterators(_Right);
; 378  :         _Swap_adl(_Myfirst, _Right._Myfirst);
; 379  :         _Swap_adl(_Mylast, _Right._Mylast);
; 380  :         _Swap_adl(_Myend, _Right._Myend);
; 381  :     }
; 382  : 
; 383  :     void _Take_contents(_Vector_val& _Right) noexcept {
; 384  :         this->_Swap_proxy_and_iterators(_Right);
; 385  :         _Myfirst = _Right._Myfirst;
; 386  :         _Mylast  = _Right._Mylast;
; 387  :         _Myend   = _Right._Myend;
; 388  : 
; 389  :         _Right._Myfirst = pointer();
; 390  :         _Right._Mylast  = pointer();
; 391  :         _Right._Myend   = pointer();
; 392  :     }
; 393  : 
; 394  :     pointer _Myfirst; // pointer to beginning of array
; 395  :     pointer _Mylast; // pointer to current end of sequence
; 396  :     pointer _Myend; // pointer to end of array
; 397  : };
; 398  : 
; 399  : // FUNCTION TEMPLATE _Unfancy_maybe_null
; 400  : template <class _Ptrty>
; 401  : auto _Unfancy_maybe_null(_Ptrty _Ptr) { // converts from a (potentially null) fancy pointer to a plain pointer
; 402  :     return _Ptr ? _STD addressof(*_Ptr) : nullptr;
; 403  : }
; 404  : 
; 405  : template <class _Ty>
; 406  : _Ty* _Unfancy_maybe_null(_Ty* _Ptr) { // do nothing for plain pointers
; 407  :     return _Ptr;
; 408  : }
; 409  : 
; 410  : // CLASS TEMPLATE vector
; 411  : template <class _Ty, class _Alloc = allocator<_Ty>>
; 412  : class vector { // varying size array of values
; 413  : private:
; 414  :     template <class>
; 415  :     friend class _Vb_val;
; 416  :     friend _Tidy_guard<vector>;
; 417  : 
; 418  :     using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
; 419  :     using _Alty_traits = allocator_traits<_Alty>;
; 420  : 
; 421  : public:
; 422  :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Ty, typename _Alloc::value_type>,
; 423  :         _MISMATCHED_ALLOCATOR_MESSAGE("vector<T, Allocator>", "T"));
; 424  : 
; 425  :     using value_type      = _Ty;
; 426  :     using allocator_type  = _Alloc;
; 427  :     using pointer         = typename _Alty_traits::pointer;
; 428  :     using const_pointer   = typename _Alty_traits::const_pointer;
; 429  :     using reference       = _Ty&;
; 430  :     using const_reference = const _Ty&;
; 431  :     using size_type       = typename _Alty_traits::size_type;
; 432  :     using difference_type = typename _Alty_traits::difference_type;
; 433  : 
; 434  : private:
; 435  :     using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
; 436  :         _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer, _Ty&, const _Ty&>>>;
; 437  : 
; 438  : public:
; 439  :     using iterator               = _Vector_iterator<_Scary_val>;
; 440  :     using const_iterator         = _Vector_const_iterator<_Scary_val>;
; 441  :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 442  :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 443  : 
; 444  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }
; 447  : 
; 448  :     explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 449  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 450  :     }
; 451  : 
; 452  : private:
; 453  :     template <class _Ty2>
; 454  :     void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {
; 455  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 456  :         auto& _My_data  = _Mypair._Myval2;
; 457  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 458  :         if (_Count != 0) {
; 459  :             _Buy_nonzero(_Count);
; 460  :             _Tidy_guard<vector> _Guard{this};
; 461  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);
; 462  :             _Guard._Target   = nullptr;
; 463  :         }
; 464  : 
; 465  :         _Proxy._Release();
; 466  :     }
; 467  : 
; 468  : public:
; 469  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())
; 470  :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 471  :         _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
; 472  :     }
; 473  : 
; 474  :     vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
; 475  :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 476  :         _Construct_n_copies_of_ty(_Count, _Val);
; 477  :     }
; 478  : 
; 479  : private:
; 480  :     template <class _Iter>
; 481  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag) {
; 482  :         _Tidy_guard<vector> _Guard{this};
; 483  :         for (; _First != _Last; ++_First) {
; 484  :             emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
; 485  :         }
; 486  : 
; 487  :         _Guard._Target = nullptr;
; 488  :     }
; 489  : 
; 490  :     template <class _Iter>
; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {
; 492  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 493  :         if (_Count != 0) {
; 494  :             _Buy_nonzero(_Count);
; 495  :             _Tidy_guard<vector> _Guard{this};
; 496  :             auto& _My_data   = _Mypair._Myval2;
; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);
; 498  :             _Guard._Target   = nullptr;
; 499  :         }
; 500  :     }
; 501  : 
; 502  : public:
; 503  :     template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
; 504  :     vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 505  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 506  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 507  :         _Adl_verify_range(_First, _Last);
; 508  :         _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 509  :         _Proxy._Release();
; 510  :     }
; 511  : 
; 512  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 513  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 514  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
; 516  :         _Proxy._Release();
; 517  :     }
; 518  : 
; 519  :     vector(const vector& _Right)
; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _NChunk$[ebp], OFFSET ??_7TDAT_Chunk@thatboy@@6B@

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _NChunk$[ebp+16], 0
	mov	DWORD PTR _NChunk$[ebp+20], 0
	mov	DWORD PTR _NChunk$[ebp+24], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	DWORD PTR __Rightfirst$1$[ebp], eax

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	DWORD PTR __Rightlast$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

	cmp	eax, ecx
	je	SHORT $LN54@checkCrcCo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	edi, ecx
	sub	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN22@checkCrcCo

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	$LN108@checkCrcCo

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN96@checkCrcCo

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@checkCrcCo
$LN22@checkCrcCo:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN23@checkCrcCo

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN21@checkCrcCo
$LN23@checkCrcCo:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN21@checkCrcCo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _NChunk$[ebp+16], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	mov	edi, DWORD PTR __Rightfirst$1$[ebp]
	push	edi
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR _NChunk$[ebp+24], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	sub	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

	add	esi, DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR _NChunk$[ebp+20], esi
$LN54@checkCrcCo:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 107  : 	NChunk.doFigure(crcEncodeType);

	push	DWORD PTR _crcEncodeType$[ebp]
	lea	ecx, DWORD PTR _NChunk$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z	; thatboy::TDAT_Chunk::doFigure

; 108  : 	return NChunk.crcCode == crcCode;

	mov	eax, DWORD PTR _NChunk$[ebp+12]
	cmp	eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR _NChunk$[ebp+16]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 108  : 	return NChunk.crcCode == crcCode;

	sete	bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN83@checkCrcCo

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	edx, DWORD PTR _NChunk$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN99@checkCrcCo

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN99@checkCrcCo
$LN96@checkCrcCo:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN99@checkCrcCo:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN83@checkCrcCo:
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 108  : 	return NChunk.crcCode == crcCode;

	mov	al, bl

; 109  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN108@checkCrcCo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN106@checkCrcCo:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z$0:
	lea	ecx, DWORD PTR _NChunk$[ebp]
	jmp	??1TDAT_Chunk@thatboy@@QAE@XZ
__ehhandler$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?checkCrcCode@TDAT_Chunk@thatboy@@UBE_NE@Z ENDP		; thatboy::TDAT_Chunk::checkCrcCode
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0TDAT_Chunk@thatboy@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightlast$1$ = -4					; size = 4
_this$ = -4						; size = 4
__Rightfirst$1$ = 8					; size = 4
___that$ = 8						; size = 4
??0TDAT_Chunk@thatboy@@QAE@ABV01@@Z PROC		; thatboy::TDAT_Chunk::TDAT_Chunk, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	edx, DWORD PTR ___that$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR [edi], OFFSET ??_7Chunk@thatboy@@6B@
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi], OFFSET ??_7TDAT_Chunk@thatboy@@6B@
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR [edx+16]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Rightfirst$1$[ebp], eax
	mov	DWORD PTR __Rightlast$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

	cmp	eax, ecx
	je	SHORT $LN51@TDAT_Chunk

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	push	ebx
	mov	ebx, ecx
	sub	ebx, eax
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN19@TDAT_Chunk

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ebx+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, ebx
	jbe	SHORT $LN75@TDAT_Chunk

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN28@TDAT_Chunk

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@TDAT_Chunk
$LN28@TDAT_Chunk:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@TDAT_Chunk:

; 179  :     if (_Bytes != 0) {

	test	ebx, ebx
	je	SHORT $LN20@TDAT_Chunk

; 51   :         return ::operator new(_Bytes);

	push	ebx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN18@TDAT_Chunk
$LN20@TDAT_Chunk:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN18@TDAT_Chunk:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi+16], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+20], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ebx
	mov	ebx, DWORD PTR __Rightfirst$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR [edi+24], eax

; 1591 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

	mov	esi, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ebx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	sub	esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

	add	esi, DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [edi+20], esi
	pop	esi
	pop	ebx
$LN51@TDAT_Chunk:
	mov	eax, edi
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN75@TDAT_Chunk:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN73@TDAT_Chunk:
	int	3
??0TDAT_Chunk@thatboy@@QAE@ABV01@@Z ENDP		; thatboy::TDAT_Chunk::TDAT_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1TDAT_Chunk@thatboy@@QAE@XZ
_TEXT	SEGMENT
??1TDAT_Chunk@thatboy@@QAE@XZ PROC			; thatboy::TDAT_Chunk::~TDAT_Chunk, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@TDAT_Chunk

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@TDAT_Chunk

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@TDAT_Chunk

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@TDAT_Chunk:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [esi+20], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [esi+24], 0
$LN6@TDAT_Chunk:
	pop	esi
	ret	0
$LN19@TDAT_Chunk:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN28@TDAT_Chunk:
	int	3
??1TDAT_Chunk@thatboy@@QAE@XZ ENDP			; thatboy::TDAT_Chunk::~TDAT_Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp
;	COMDAT ?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z
_TEXT	SEGMENT
tv304 = -1064						; size = 4
_this$GSCopy$1$ = -1060					; size = 4
_crc$ = -1056						; size = 1048
__$ArrayPad$ = -4					; size = 4
_crcType$ = 8						; size = 1
?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z PROC		; thatboy::TDAT_Chunk::doFigure, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1068				; 0000042cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1068], eax
	push	ebx
	mov	ebx, ecx

; 115  : 
; 116  : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	lea	ecx, DWORD PTR _crc$[esp+1072]
	push	esi
	push	edi
	push	DWORD PTR _crcType$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebx+20]
	sub	esi, DWORD PTR [ebx+16]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 112  : {

	mov	DWORD PTR _this$GSCopy$1$[esp+1084], ebx

; 113  : 	Chunk::dataLength = sizeof(BYTE) * compressData.size();

	mov	DWORD PTR [ebx+4], esi

; 114  : 	Chunk::typeCode = dataChunkType;

	mov	DWORD PTR [ebx+8], 1413563476		; 54414454H

; 115  : 
; 116  : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32

; 117  : 	BYTE* crcBuff = new BYTE[dataLength + sizeof(DWORD)];

	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_??_U@YAPAXI@Z

; 118  : 
; 119  : 	memcpy(crcBuff, (LPCSTR)&typeCode, sizeof(typeCode));

	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, eax
	mov	DWORD PTR [edi], ecx

; 120  : 	memcpy(crcBuff + sizeof(typeCode), (LPCSTR)compressData.data(), dataLength);

	lea	ecx, DWORD PTR [edi+4]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx+16]
	push	ecx
	call	_memcpy

; 121  : 	Chunk::crcCode = crc.crcCompute(crcBuff, dataLength + sizeof(DWORD));

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	eax, DWORD PTR _crc$[esp+1084]

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 121  : 	Chunk::crcCode = crc.crcCompute(crcBuff, dataLength + sizeof(DWORD));

	add	ecx, 4
	mov	DWORD PTR tv304[esp+1080], ecx
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	je	SHORT $LN7@doFigure
	mov	ebx, DWORD PTR _crc$[esp+2120]
	add	ebx, -8					; fffffff8H
	npad	2
$LL8@doFigure:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	edx, eax
	mov	ecx, ebx
	shr	edx, cl
	movzx	ecx, BYTE PTR [esi+edi]
	inc	esi
	movzx	edx, dl
	xor	edx, ecx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	eax, 8
	xor	eax, DWORD PTR _crc$[esp+edx*4+1096]
	cmp	esi, DWORD PTR tv304[esp+1080]
	jb	SHORT $LL8@doFigure
	mov	ebx, DWORD PTR _this$GSCopy$1$[esp+1080]
$LN7@doFigure:

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	ecx, DWORD PTR _crc$[esp+1088]
	xor	ecx, eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyCriticalChunk.cpp

; 122  : 	delete[]crcBuff;

	push	edi
	mov	DWORD PTR [ebx+12], ecx
	call	DWORD PTR __imp_??_V@YAXPAX@Z

; 123  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1084]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?doFigure@TDAT_Chunk@thatboy@@UAEXE@Z ENDP		; thatboy::TDAT_Chunk::doFigure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QBEPBEXZ
_TEXT	SEGMENT
?data@?$vector@EV?$allocator@E@std@@@std@@QBEPBEXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT
; _this$ = ecx

; 1407 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	eax, DWORD PTR [ecx]

; 1408 :     }

	ret	0
?data@?$vector@EV?$allocator@E@std@@@std@@QBEPBEXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ
_TEXT	SEGMENT
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT
; _this$ = ecx

; 1403 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	eax, DWORD PTR [ecx]

; 1404 :     }

	ret	0
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 673  :     ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 679  :     }

	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN25@vector:
	int	3
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightlast$1$ = -4					; size = 4
__Rightfirst$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 519  :     vector(const vector& _Right)

	push	ebp
	mov	ebp, esp
	push	ecx

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR __Right$[ebp]
	push	ebx
	mov	ebx, ecx
	push	esi

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Rightfirst$1$[ebp], esi
	mov	DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, eax
	je	SHORT $LN46@vector

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	push	edi
	mov	edi, eax
	sub	edi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN14@vector

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, edi
	jbe	SHORT $LN69@vector

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN23@vector

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN13@vector
$LN23@vector:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@vector:

; 179  :     if (_Bytes != 0) {

	test	edi, edi
	je	SHORT $LN15@vector

; 51   :         return ::operator new(_Bytes);

	push	edi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN13@vector
$LN15@vector:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN13@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR [ebx], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	mov	edi, DWORD PTR __Rightfirst$1$[ebp]
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	DWORD PTR [ebx+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	sub	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

	add	esi, DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], esi
	pop	edi
$LN46@vector:

; 535  :     }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN69@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN67@vector:
	int	3
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

	mov	eax, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 5110 :     ~_Tidy_guard() {

	push	esi

; 5111 :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@Tidy_guard

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy_guard

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN18@Tidy_guard

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN21@Tidy_guard:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 5114 :     }

	ret	0
$LN18@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN26@Tidy_guard:
	int	3
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1689 :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1690 :         auto& _My_data    = _Mypair._Myval2;
; 1691 :         pointer& _Myfirst = _My_data._Myfirst;
; 1692 :         pointer& _Mylast  = _My_data._Mylast;
; 1693 :         pointer& _Myend   = _My_data._Myend;
; 1694 : 
; 1695 :         _My_data._Orphan_all();
; 1696 : 
; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy

; 1698 :             _Destroy(_Myfirst, _Mylast);
; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN15@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN18@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1701 :             _Myfirst = pointer();

	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1702 :             _Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1703 :             _Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1705 :     }

	pop	esi
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Tidy:
	int	3
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1636 :     void _Buy_raw(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	esi, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1636 :     void _Buy_raw(const size_type _Newcapacity) {

	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN6@Buy_raw

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	SHORT $LN29@Buy_raw

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN15@Buy_raw

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1650 :     }

	pop	ebp
	ret	4
$LN15@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Buy_raw:

; 179  :     if (_Bytes != 0) {

	test	esi, esi
	je	SHORT $LN7@Buy_raw

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 51   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1650 :     }

	pop	ebp
	ret	4
$LN7@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 183  :     return nullptr;

	xor	eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1647 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1648 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1649 :         _Myend             = _Newvec + _Newcapacity;

	mov	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1650 :     }

	pop	ebp
	ret	4
$LN29@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN27@Buy_raw:
	int	3
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

	mov	eax, ecx

; 685  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
;	COMDAT ?crcCompute@?$CRC@I@thatboy@@QAEIPBEI@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
tv236 = 12						; size = 4
_nBytes$ = 12						; size = 4
?crcCompute@?$CRC@I@thatboy@@QAEIPBEI@Z PROC		; thatboy::CRC<unsigned int>::crcCompute, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 69   :     unsigned int offset;
; 70   :     unsigned char byte;
; 71   :     TYPE remainder = m_initial_remainder;
; 72   :     /* Divide the message by the polynomial, a byte at a time. */
; 73   :     for (offset = 0; offset < nBytes; offset++)

	mov	ebx, DWORD PTR _nBytes$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	xor	esi, esi
	mov	edx, DWORD PTR [edi+4]
	test	ebx, ebx
	je	SHORT $LN3@crcCompute
	mov	ecx, DWORD PTR [edi+1040]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR tv236[ebp], ecx
$LL4@crcCompute:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	eax, edx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	edx, 8
	shr	eax, cl
	movzx	ecx, al
	mov	eax, DWORD PTR _message$[ebp]
	movzx	eax, BYTE PTR [esi+eax]
	inc	esi
	xor	ecx, eax
	xor	edx, DWORD PTR [edi+ecx*4+16]
	mov	ecx, DWORD PTR tv236[ebp]
	cmp	esi, ebx
	jb	SHORT $LL4@crcCompute
$LN3@crcCompute:

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	eax, DWORD PTR [edi+8]
	pop	edi
	pop	esi
	xor	eax, edx
	pop	ebx

; 80   : }

	pop	ebp
	ret	8
?crcCompute@?$CRC@I@thatboy@@QAEIPBEI@Z ENDP		; thatboy::CRC<unsigned int>::crcCompute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT
; __Ptr$ = ecx

; 407  :     return _Ptr;

	mov	eax, ecx

; 408  : }

	ret	0
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@E@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>, COMDAT
; _this$dead$ = ecx

; 1590 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1590 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1590 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1591 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi

; 1592 :     }

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$allocator@E@std@@@std@@YA$$QAV?$allocator@E@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@E@std@@@std@@YA$$QAV?$allocator@E@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned char> >, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@V?$allocator@E@std@@@std@@YA$$QAV?$allocator@E@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy<unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

	lea	eax, DWORD PTR [edi+esi]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

	pop	edi
	pop	esi

; 1540 : }

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$dead$ = ecx

; 1063 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
END
