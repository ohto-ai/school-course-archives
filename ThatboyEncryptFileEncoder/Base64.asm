; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\base64.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	__TI3?AVbad_array_new_length@std@@
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp____std_terminate:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB
CONST	SEGMENT
?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB DB 041H ; `thatboy::Base64::encode'::`2'::EncodeMap
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02fH
	DB	00H
CONST	ENDS
;	COMDAT ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB
CONST	SEGMENT
?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB DB 0ffH ; `thatboy::Base64::decode'::`2'::DecodeMap
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03eH
	DB	0ffH
	DB	03fH
	DB	0ffH
	DB	0ffH
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Get_unwrapped@E@std@@YAPAEQAE@Z		; std::_Get_unwrapped<unsigned char>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Unfancy@E@std@@YAPAEPAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPAEPAEIABEAAV?$allocator@E@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
PUBLIC	?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIU_Value_init_tag@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<unsigned char>
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@4@_N@Z ; thatboy::Base64::decode
PUBLIC	?encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; thatboy::Base64::encode
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
;	COMDAT ?encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
_TEXT	SEGMENT
$T32 = -52						; size = 1
__Ch$ = -52						; size = 1
tv1579 = -52						; size = 4
__Ch$ = -52						; size = 1
$T23 = -52						; size = 1
__Ch$ = -52						; size = 1
$T30 = -48						; size = 1
$T27 = -48						; size = 1
$T21 = -48						; size = 1
$T18 = -48						; size = 1
$T15 = -48						; size = 1
$T12 = -44						; size = 1
$T8 = -40						; size = 1
$T4 = -36						; size = 1
_numOrig24BitValues$1$ = -32				; size = 4
__Ch$ = -32						; size = 1
__Ch$ = -28						; size = 1
__Ch$ = -24						; size = 1
__Ch$ = -20						; size = 1
__Ch$ = -16						; size = 1
tv1594 = -12						; size = 4
_nInLen$1$ = -8						; size = 4
_dataIn$1$ = -4						; size = 4
?encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z PROC ; thatboy::Base64::encode, COMDAT
; _dataIn$ = ecx
; _strOut$ = edx

; 7    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, ecx

; 10   : 	size_t numOrig24BitValues = nInLen / 3;	// <24Bit>

	mov	eax, -1431655765			; aaaaaaabH
	push	esi
	mov	esi, edx
	mov	DWORD PTR _dataIn$1$[ebp], ebx
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 10   : 	size_t numOrig24BitValues = nInLen / 3;	// <24Bit>

	mul	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _nInLen$1$[ebp], ecx
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 10   : 	size_t numOrig24BitValues = nInLen / 3;	// <24Bit>

	mov	edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 10   : 	size_t numOrig24BitValues = nInLen / 3;	// <24Bit>

	shr	edi, 1
	mov	DWORD PTR _numOrig24BitValues$1$[ebp], edi

; 11   : 	bool havePadding = (nInLen != numOrig24BitValues * 3);			// 3n+1..2

	lea	ecx, DWORD PTR [edi+edi*2]

; 12   : 	bool havePadding2 = (nInLen != numOrig24BitValues * 3 + 1);		// 3n+1

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv1594[ebp], ecx
	mov	DWORD PTR tv1579[ebp], eax

; 13   : 	size_t numResultBytes = 4 * (numOrig24BitValues + havePadding);

	xor	eax, eax
	cmp	DWORD PTR _nInLen$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ecx, esi
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 13   : 	size_t numResultBytes = 4 * (numOrig24BitValues + havePadding);

	setne	al
	add	eax, edi
	shl	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN156@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [esi]
$LN156@encode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 15   : 	strOut.reserve(numResultBytes + 1);

	inc	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	BYTE PTR [ecx], 0
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 15   : 	strOut.reserve(numResultBytes + 1);

	push	eax
	mov	ecx, esi
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 17   : 	for (size_t i = 0; i < numOrig24BitValues; ++i)

	test	edi, edi
	je	$LN3@encode
	xor	edi, edi
$LL4@encode:

; 19   : 		strOut.append(1, EncodeMap[(dataIn[3 * i] >> 2) & 0B00111111]);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 19   : 		strOut.append(1, EncodeMap[(dataIn[3 * i] >> 2) & 0B00111111]);

	movzx	eax, BYTE PTR [edi+eax]
	shr	eax, 2
	mov	al, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[eax]
	mov	BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 1
	jb	SHORT $LN23@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN159@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN159@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [ebx+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ebx+edx+1], 0

; 2797 :             return *this;

	mov	ebx, DWORD PTR _dataIn$1$[ebp]
	jmp	SHORT $LN22@encode
$LN23@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T4[ebp], 0
	push	ecx
	push	DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN22@encode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1515 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 20   : 		strOut.append(1, EncodeMap[((dataIn[3 * i] << 4) & 0B00110000) | ((dataIn[3 * i + 1] >> 4) & 0B00001111)]);

	movzx	ecx, BYTE PTR [edi+eax+1]
	movzx	eax, BYTE PTR [edi+eax]
	and	eax, 3
	shr	ecx, 4
	shl	eax, 4
	or	ecx, eax
	mov	al, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 20   : 		strOut.append(1, EncodeMap[((dataIn[3 * i] << 4) & 0B00110000) | ((dataIn[3 * i + 1] >> 4) & 0B00001111)]);

	mov	BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 1
	jb	SHORT $LN37@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN160@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN160@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [ebx+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ebx+edx+1], 0

; 2797 :             return *this;

	mov	ebx, DWORD PTR _dataIn$1$[ebp]
	jmp	SHORT $LN36@encode
$LN37@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T8[ebp], 0
	push	ecx
	push	DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN36@encode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1515 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 21   : 		strOut.append(1, EncodeMap[((dataIn[3 * i + 1] << 2) & 0B00111100) | ((dataIn[3 * i + 2] >> 6) & 0B00000011)]);

	movzx	ecx, BYTE PTR [edi+eax+1]
	movzx	eax, BYTE PTR [edi+eax+2]
	and	ecx, 15					; 0000000fH
	shr	eax, 6
	shl	ecx, 2
	or	ecx, eax
	mov	al, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 21   : 		strOut.append(1, EncodeMap[((dataIn[3 * i + 1] << 2) & 0B00111100) | ((dataIn[3 * i + 2] >> 6) & 0B00000011)]);

	mov	BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 1
	jb	SHORT $LN51@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN157@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN157@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [ebx+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ebx+edx+1], 0

; 2797 :             return *this;

	mov	ebx, DWORD PTR _dataIn$1$[ebp]
	jmp	SHORT $LN50@encode
$LN51@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T12[ebp], 0
	push	ecx
	push	DWORD PTR $T12[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN50@encode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 22   : 		strOut.append(1, EncodeMap[dataIn[3 * i + 2] & 0B00111111]);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 22   : 		strOut.append(1, EncodeMap[dataIn[3 * i + 2] & 0B00111111]);

	movzx	eax, BYTE PTR [edi+eax+2]
	and	eax, 63					; 0000003fH
	mov	al, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[eax]
	mov	BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 1
	jb	SHORT $LN63@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN158@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN158@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [ebx+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ebx+edx+1], 0

; 2797 :             return *this;

	mov	ebx, DWORD PTR _dataIn$1$[ebp]
	jmp	SHORT $LN2@encode
$LN63@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T15[ebp], 0
	push	ecx
	push	DWORD PTR $T15[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN2@encode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 17   : 	for (size_t i = 0; i < numOrig24BitValues; ++i)

	add	edi, 3
	sub	DWORD PTR _numOrig24BitValues$1$[ebp], 1
	jne	$LL4@encode
$LN3@encode:

; 23   : 	}
; 24   : 	// Â§ÑÁêÜÊúÄÂêé‰∏çÂÆåÊï¥ÁªÑ
; 25   : 	if (havePadding)

	mov	ecx, DWORD PTR tv1594[ebp]
	cmp	DWORD PTR _nInLen$1$[ebp], ecx
	je	$LN166@encode

; 27   : 		strOut.append(1, EncodeMap[(dataIn[3 * numOrig24BitValues] >> 2) & 0B00111111]);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 27   : 		strOut.append(1, EncodeMap[(dataIn[3 * numOrig24BitValues] >> 2) & 0B00111111]);

	movzx	eax, BYTE PTR [ecx+eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 27   : 		strOut.append(1, EncodeMap[(dataIn[3 * numOrig24BitValues] >> 2) & 0B00111111]);

	shr	eax, 2
	mov	al, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[eax]
	mov	BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 1
	jb	SHORT $LN75@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN161@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN161@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [edi+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+edx+1], 0

; 2797 :             return *this;

	jmp	SHORT $LN74@encode
$LN75@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T18[ebp], 0
	push	ecx
	push	DWORD PTR $T18[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN74@encode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 28   : 		if (!havePadding2)

	mov	eax, DWORD PTR [ebx]
	add	eax, DWORD PTR tv1594[ebp]
	mov	ecx, DWORD PTR tv1579[ebp]
	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR _nInLen$1$[ebp], ecx
	jne	$LN6@encode

; 30   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues] << 4) & 0B00110000)]);

	movzx	eax, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 30   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues] << 4) & 0B00110000)]);

	and	eax, 3
	shl	eax, 4
	mov	bl, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 30   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues] << 4) & 0B00110000)]);

	mov	BYTE PTR __Ch$[ebp], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN87@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN162@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN162@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, bl
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [edi+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+edx+1], 0

; 2797 :             return *this;

	jmp	SHORT $LN86@encode
$LN87@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T21[ebp], 0
	push	ecx
	push	DWORD PTR $T21[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN86@encode:

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	edx, DWORD PTR [esi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	cmp	eax, 1
	jb	SHORT $LN97@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+16], eax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN165@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN165@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	WORD PTR [eax+ecx], 61			; 0000003dH

; 2797 :             return *this;

	jmp	$LN122@encode
$LN97@encode:

; 2800 :         return _Reallocate_grow_by(

	push	61					; 0000003dH
	push	ecx
	mov	BYTE PTR $T23[ebp], 0
	push	DWORD PTR $T23[ebp]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 32   : 		}

	jmp	$LN167@encode
$LN6@encode:

; 35   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues] << 4) & 0B00110000) | ((dataIn[3 * numOrig24BitValues + 1] >> 4) & 0B00001111)]);

	movzx	ecx, BYTE PTR [eax]
	movzx	eax, BYTE PTR [eax+1]
	and	ecx, 3
	shr	eax, 4
	shl	ecx, 4
	or	ecx, eax
	mov	bl, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, ecx
	sub	eax, edx
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 35   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues] << 4) & 0B00110000) | ((dataIn[3 * numOrig24BitValues + 1] >> 4) & 0B00001111)]);

	mov	BYTE PTR __Ch$[ebp], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN111@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN163@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN163@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, bl
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [edi+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+edx+1], 0

; 2797 :             return *this;

	jmp	SHORT $LN110@encode
$LN111@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T27[ebp], 0
	push	ecx
	push	DWORD PTR $T27[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN110@encode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 36   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues + 1] << 2) & 0B00111100)]);

	mov	eax, DWORD PTR _dataIn$1$[ebp]
	mov	ecx, DWORD PTR tv1594[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR [esi+16]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 36   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues + 1] << 2) & 0B00111100)]);

	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [ecx+eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [esi+20]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 36   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues + 1] << 2) & 0B00111100)]);

	and	eax, 15					; 0000000fH
	mov	bl, BYTE PTR ?EncodeMap@?1??encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@4QBDB[eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, ecx
	sub	eax, edx
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 36   : 			strOut.append(1, EncodeMap[((dataIn[3 * numOrig24BitValues + 1] << 2) & 0B00111100)]);

	mov	BYTE PTR __Ch$[ebp], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN123@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+1]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN164@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN164@encode:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, bl
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [edi+edx], cl

; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+edx+1], 0

; 2797 :             return *this;

	jmp	SHORT $LN122@encode
$LN123@encode:

; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T30[ebp], 0
	push	ecx
	push	DWORD PTR $T30[ebp]
$LN167@encode:

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN122@encode:

; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	edx, DWORD PTR [esi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	cmp	eax, 1
	jb	SHORT $LN133@encode

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+16], eax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN136@encode

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [esi]
$LN136@encode:
	pop	edi

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	WORD PTR [esi+ecx], 61			; 0000003dH
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 42   : }

	mov	al, 1
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN133@encode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2800 :         return _Reallocate_grow_by(

	push	61					; 0000003dH
	push	ecx
	mov	BYTE PTR $T32[ebp], 0
	push	DWORD PTR $T32[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN166@encode:
	pop	edi
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 42   : }

	pop	esi
	mov	al, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?encode@Base64@thatboy@@YA_NABV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ENDP ; thatboy::Base64::encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
;	COMDAT ?decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@4@_N@Z
_TEXT	SEGMENT
_nInlen$1$ = -20					; size = 4
_nOutLen$1$ = -16					; size = 4
tv1232 = -12						; size = 4
tv1231 = -12						; size = 4
tv1230 = -12						; size = 4
_dataOut$1$ = -12					; size = 4
__Oldlast$1$ = -8					; size = 4
_nLoopLen$1$ = -8					; size = 4
$T1 = -1						; size = 1
_ifCheckInputValid$dead$ = 8				; size = 1
?decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@4@_N@Z PROC ; thatboy::Base64::decode, COMDAT
; _strIn$ = ecx
; _dataOut$ = edx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, edx
	mov	DWORD PTR _dataOut$1$[ebp], edi

; 46   : 	static constexpr unsigned char DecodeMap[256] = {
; 47   : 		0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 48   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 49   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 62, 0XFF, 63, 0XFF, 0XFF
; 50   : 		, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0XFF, 0XFF, 0XFF, 0, 0XFF, 0XFF
; 51   : 		, 0XFF, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14
; 52   : 		, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 53   : 		, 0XFF, 26, 27, 28,  29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
; 54   : 		, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 55   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 56   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 57   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 58   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 59   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 60   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 61   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 62   : 		, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF
; 63   : 	};
; 64   : 
; 65   : 	size_t nInlen = strIn.length();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _nInlen$1$[ebp], eax

; 66   : 	if (nInlen < 4 || nInlen % 4 != 0)

	cmp	eax, 4
	jb	$LN9@decode
	test	al, 3
	jne	$LN9@decode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR [edi]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 74   : 	size_t nOutLen = (nInlen * 3) / 4;

	push	ebx
	lea	ebx, DWORD PTR [eax+eax*2]

; 75   : 	dataOut.resize(nOutLen, 0XFF);

	mov	BYTE PTR $T1[ebp], 255			; 000000ffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, eax
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 74   : 	size_t nOutLen = (nInlen * 3) / 4;

	shr	ebx, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sub	ecx, edx
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 74   : 	size_t nOutLen = (nInlen * 3) / 4;

	mov	DWORD PTR _nOutLen$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	DWORD PTR __Oldlast$1$[ebp], eax

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, ecx
	jae	SHORT $LN32@decode

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+ebx]

; 1219 :             _Orphan_range(_Newlast, _Mylast);
; 1220 :             _Destroy(_Newlast, _Mylast);
; 1221 :             _Mylast = _Newlast;
; 1222 :             return;

	jmp	SHORT $LN140@decode
$LN32@decode:

; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN33@decode

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, eax
	jbe	SHORT $LN34@decode

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, edi
	push	eax
	push	ebx
	call	??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>

; 1229 :                 return;

	jmp	SHORT $LN33@decode
$LN34@decode:

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	edi, ebx
	sub	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	push	edi
	push	255					; 000000ffH
	push	DWORD PTR __Oldlast$1$[ebp]
	call	_memset

; 1718 :         return _First + _Count;

	mov	eax, DWORD PTR __Oldlast$1$[ebp]
	add	esp, 12					; 0000000cH
	add	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	edi, DWORD PTR _dataOut$1$[ebp]
$LN140@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 76   : 	size_t nLoopLen = nOutLen / 3;

	mov	DWORD PTR [edi+4], eax
$LN33@decode:
	mov	eax, -1431655765			; aaaaaaabH
	mul	ebx
	mov	eax, edx
	shr	eax, 1
	mov	DWORD PTR _nLoopLen$1$[ebp], eax

; 77   : 	for (size_t i = 0; i < nLoopLen; ++i)

	je	$LN6@decode
	xor	edx, edx
	xor	ebx, ebx
	npad	6
$LL7@decode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN138@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN138@decode:

; 3504 :         return _Mypair._Myval2._Myptr()[_Off];

	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR tv1232[ebp], eax

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN133@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN133@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 79   : 		dataOut[i * 3] = ((DecodeMap[strIn[i * 4]] << 2) & 0xFC) | ((DecodeMap[strIn[i * 4 + 1]] >> 4) & 0x03);

	movsx	eax, BYTE PTR [eax+ebx*4+1]
	mov	cl, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	mov	eax, DWORD PTR tv1232[ebp]
	shr	cl, 4
	and	cl, 3
	movsx	eax, BYTE PTR [eax]
	mov	al, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	shl	al, 2
	or	cl, al
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [edx+eax], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN134@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN134@decode:

; 3504 :         return _Mypair._Myval2._Myptr()[_Off];

	lea	eax, DWORD PTR [eax+ebx*4]
	inc	eax
	mov	DWORD PTR tv1231[ebp], eax

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN135@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN135@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 80   : 		dataOut[i * 3 + 1] = ((DecodeMap[strIn[i * 4 + 1]] << 4) & 0xF0) | ((DecodeMap[strIn[i * 4 + 2]] >> 2) & 0x0F);

	movsx	eax, BYTE PTR [eax+ebx*4+2]
	mov	cl, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	mov	eax, DWORD PTR tv1231[ebp]
	shr	cl, 2
	and	cl, 15					; 0000000fH
	movsx	eax, BYTE PTR [eax]
	mov	al, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	shl	al, 4
	or	cl, al
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax+edx+1], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN136@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN136@decode:

; 3504 :         return _Mypair._Myval2._Myptr()[_Off];

	lea	eax, DWORD PTR [eax+ebx*4]
	add	eax, 2
	mov	DWORD PTR tv1230[ebp], eax

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN137@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN137@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 81   : 		dataOut[i * 3 + 2] = ((DecodeMap[strIn[i * 4 + 2]] << 6) & 0xC0) | (DecodeMap[strIn[i * 4 + 3]] & 0x3F);

	movsx	eax, BYTE PTR [eax+ebx*4+3]
	inc	ebx
	mov	cl, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	mov	eax, DWORD PTR tv1230[ebp]
	and	cl, 63					; 0000003fH
	movsx	eax, BYTE PTR [eax]
	mov	al, BYTE PTR ?DecodeMap@?1??decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@5@_N@Z@4QBEB[eax]
	shl	al, 6
	or	cl, al
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax+edx+2], cl
	add	edx, 3
	cmp	ebx, DWORD PTR _nLoopLen$1$[ebp]
	jb	$LL7@decode
	mov	ebx, DWORD PTR _nOutLen$1$[ebp]
$LN6@decode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, esi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN139@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [esi]
$LN139@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 84   : 	if (strIn[nInlen - 1] == '=')

	mov	edx, DWORD PTR _nInlen$1$[ebp]
	cmp	BYTE PTR [eax+edx-1], 61		; 0000003dH
	jne	SHORT $LN13@decode

; 85   : 	{
; 86   : 		nOutLen--;

	dec	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN98@decode

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [esi]
$LN98@decode:
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 87   : 		if (strIn[nInlen - 2] == '=')

	cmp	BYTE PTR [esi+edx-2], 61		; 0000003dH
	jne	SHORT $LN13@decode

; 88   : 			nOutLen--;

	dec	ebx
$LN13@decode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, esi
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, ecx
	jae	SHORT $LN105@decode

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+ebx]
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 91   : 	return true;

	pop	ebx
	mov	DWORD PTR [edi+4], eax
	mov	al, 1
	pop	edi

; 92   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@decode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN106@decode

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, eax
	jbe	SHORT $LN107@decode

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	ebx
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 91   : 	return true;

	pop	ebx
	pop	edi
	mov	al, 1

; 92   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@decode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	ebx
	push	0
	push	esi
	call	_memset

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [ebx+esi]

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp

; 91   : 	return true;

	mov	DWORD PTR [edi+4], eax
$LN106@decode:
	pop	ebx
	pop	edi
	mov	al, 1

; 92   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@decode:
	pop	edi

; 67   : 		return false;

	xor	al, al

; 92   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?decode@Base64@thatboy@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@EV?$allocator@E@std@@@4@_N@Z ENDP ; thatboy::Base64::decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\Œƒº˛º”√‹À„∑®…Ëº∆\ThatboyEncryptFileEncoder\Base64.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1508 :     _NODISCARD const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 1509 :         auto& _My_data = _Mypair._Myval2;
; 1510 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1511 :         _STL_VERIFY(
; 1512 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1513 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1514 : 
; 1515 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR __Pos$[ebp]

; 1516 :     }

	pop	ebp
	ret	4
??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1498 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 1499 :         auto& _My_data = _Mypair._Myval2;
; 1500 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1501 :         _STL_VERIFY(
; 1502 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1503 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1504 : 
; 1505 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR __Pos$[ebp]

; 1506 :     }

	pop	ebp
	ret	4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIABE@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1246 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1217 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[ebp]

; 1246 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {

	push	edi
	mov	edi, ecx

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi]

; 1249 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN4@resize:

; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	DWORD PTR __Val$[ebp]
	mov	ecx, edi
	push	esi
	call	??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>
	pop	edi

; 1249 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN6@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	eax, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	push	esi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	ebx
	call	_memset

; 1718 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1249 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1241 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1217 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[ebp]

; 1241 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx

; 1217 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi]

; 1244 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN4@resize:

; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1244 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN6@resize:

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1244 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
$T9 = 8							; size = 4
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3619 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 3620 :         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore

	mov	edi, DWORD PTR __Newcap$[ebp]
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR __Old_size$1$[ebp], eax
	cmp	eax, edi
	ja	$LN5@reserve

; 3621 :             return; // nothing to do
; 3622 :         }
; 3623 : 
; 3624 :         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity

	push	ebx
	mov	ebx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ebx
	cmp	ebx, edi
	je	$LN94@reserve

; 3625 :             return; // nothing to do
; 3626 :         }
; 3627 : 
; 3628 :         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow

	jae	$LN4@reserve

; 3629 :             const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3630 :             _Reallocate_grow_by(

	mov	ecx, edi

; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH

; 3629 :             const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3630 :             _Reallocate_grow_by(

	sub	ecx, eax

; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	eax, edx
	sub	eax, DWORD PTR __Old_size$1$[ebp]
	cmp	eax, ecx
	jb	$LN98@reserve

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ecx, edi
	or	ecx, 15					; 0000000fH
	cmp	ecx, edx

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN15@reserve

; 4088 :             return _Max;

	mov	ecx, edx
	jmp	SHORT $LN96@reserve
$LN15@reserve:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ebx
	shr	eax, 1
	sub	edx, eax
	cmp	ebx, edx
	jbe	SHORT $LN16@reserve

; 4092 :             return _Max;

	mov	ecx, 2147483647				; 7fffffffH
	jmp	SHORT $LN96@reserve
$LN16@reserve:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	cmovb	ecx, eax
$LN96@reserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR $T9[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN23@reserve

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN99@reserve

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN87@reserve

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	ecx, DWORD PTR $T9[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@reserve
$LN23@reserve:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN24@reserve

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ecx, DWORD PTR $T9[ebp]

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ebx, eax
	jmp	SHORT $LN22@reserve
$LN24@reserve:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ebx, ebx
$LN22@reserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4146 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __Old_size$1$[ebp]
	inc	eax
	mov	DWORD PTR [esi+16], edi

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR [esi+20], ecx
	push	eax
	jb	SHORT $LN9@reserve

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	call	_memcpy

; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN62@reserve

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN87@reserve

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN62@reserve:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 3635 :             _Mypair._Myval2._Mysize = _Old_size;

	mov	eax, DWORD PTR __Old_size$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 3635 :             _Mypair._Myval2._Mysize = _Old_size;

	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	pop	edi

; 3646 :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@reserve:

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebx
	call	_memcpy

; 3635 :             _Mypair._Myval2._Mysize = _Old_size;

	mov	eax, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 3635 :             _Mypair._Myval2._Mysize = _Old_size;

	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	pop	edi

; 3646 :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@reserve:

; 3636 :             return;
; 3637 :         }
; 3638 : 
; 3639 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

	cmp	edi, 16					; 00000010H
	jae	SHORT $LN94@reserve

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ebx, 16					; 00000010H

; 3636 :             return;
; 3637 :         }
; 3638 : 
; 3639 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN94@reserve

; 4165 :         const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 4166 :         auto& _Al          = _Getal();
; 4167 :         _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4168 :         _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);

	inc	eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edi
	push	esi
	call	_memcpy

; 4169 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	mov	ecx, DWORD PTR [esi+20]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4169 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN90@reserve

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN87@reserve

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN90@reserve:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4170 :         _Mypair._Myval2._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
$LN94@reserve:
	pop	ebx
$LN5@reserve:
	pop	edi

; 3646 :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN87@reserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN98@reserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN99@reserve:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN95@reserve:
	int	3
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$dead$ = ecx

; 3631 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {

	push	ebp
	mov	ebp, esp

; 3632 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

	mov	eax, DWORD PTR __Old_size$[ebp]
	inc	eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR __Old_ptr$[ebp]
	push	DWORD PTR __New_ptr$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3633 :                 });

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	edx, ecx

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Unchecked_

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [ecx]
$LN4@Unchecked_:

; 3425 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx

; 3426 :     }

	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Unchecked_

; 3417 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3418 :     }

	ret	0
$LN8@Unchecked_:

; 3417 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3418 :     }

	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@clear

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ecx]

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	BYTE PTR [eax], 0

; 3154 :         _Eos(0);
; 3155 :     }

	ret	0
$LN10@clear:

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	BYTE PTR [ecx], 0

; 3154 :         _Eos(0);
; 3155 :     }

	ret	0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Resize@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<unsigned char>, COMDAT
; _this$ = ecx

; 1212 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1213 :         auto& _My_data      = _Mypair._Myval2;
; 1214 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1215 :         pointer& _Mylast    = _My_data._Mylast;
; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1217 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi]

; 1238 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN2@Resize:

; 1219 :             _Orphan_range(_Newlast, _Mylast);
; 1220 :             _Destroy(_Newlast, _Mylast);
; 1221 :             _Mylast = _Newlast;
; 1222 :             return;
; 1223 :         }
; 1224 : 
; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	DWORD PTR __Val$[ebp]
	mov	ecx, edi
	push	esi
	call	??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>
	pop	edi

; 1238 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN4@Resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	eax, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	push	esi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	ebx
	call	_memset

; 1718 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1238 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
??$_Resize@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1212 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1213 :         auto& _My_data      = _Mypair._Myval2;
; 1214 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1215 :         pointer& _Mylast    = _My_data._Mylast;
; 1216 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1217 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1218 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi]

; 1238 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN2@Resize:

; 1219 :             _Orphan_range(_Newlast, _Mylast);
; 1220 :             _Destroy(_Newlast, _Mylast);
; 1221 :             _Mylast = _Newlast;
; 1222 :             return;
; 1223 :         }
; 1224 : 
; 1225 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1226 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx

; 1227 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1228 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1238 :     }

	pop	esi
	pop	ebx
	pop	ebp
	ret	8
$LN4@Resize:

; 1229 :                 return;
; 1230 :             }
; 1231 : 
; 1232 :             const pointer _Oldlast = _Mylast;
; 1233 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1238 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Old_size$1$ = -8					; size = 4
__New_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 4129 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4130 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4131 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4132 :         auto& _My_data            = _Mypair._Myval2;
; 4133 :         const size_type _Old_size = _My_data._Mysize;
; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	ebx, DWORD PTR [edi+16]
	sub	eax, ebx
	mov	DWORD PTR __Old_size$1$[ebp], ebx
	cmp	eax, edx
	jb	$LN65@Reallocate

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [ebx+edx]

; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ebx, DWORD PTR [edi+20]

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH

; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], ebx

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	esi, ecx

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4088 :             return _Max;

	mov	esi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ebx
	shr	eax, 1
	sub	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN10@Reallocate

; 4092 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN66@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN53@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	ebx, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ebx, ebx
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4144 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [edi+16], eax

; 4145 :         _My_data._Myres       = _New_capacity;
; 4146 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __Old_size$1$[ebp]
	inc	eax
	mov	DWORD PTR [edi+20], esi

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	push	eax
	jb	SHORT $LN3@Reallocate

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebx
	call	_memcpy

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4157 :         return *this;

	mov	DWORD PTR [edi], ebx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4157 :         return *this;

	mov	DWORD PTR [edi], ebx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN65@Reallocate:

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN66@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN63@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1716 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1717 :         _Lockit _Lock(_LOCK_DEBUG);
; 1718 : 
; 1719 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1720 :         while (*_Pnext) {
; 1721 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1722 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1723 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1724 :             } else { // orphan the iterator
; 1725 :                 (*_Pnext)->_Myproxy = nullptr;
; 1726 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1727 :             }
; 1728 :         }
; 1729 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1730 :         (void) _First;
; 1731 :         (void) _Last;
; 1732 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1733 :     }

	ret	8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Getal());
; 1616 :     }

	ret	8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIU_Value_init_tag@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1584 :     pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	ebp
	mov	ebp, esp
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1584 :     pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	edi, DWORD PTR __Count$[ebp]
	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1586 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1587 :     }

	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIU_Value_init_tag@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIABE@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1579 :     pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	eax, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1579 :     pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	esi, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1579 :     pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	edi, DWORD PTR __Count$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1718 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1581 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

	pop	edi
	pop	esi

; 1582 :     }

	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1737 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

	mov	eax, ecx

; 1337 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>, COMDAT
; _this$ = ecx

; 1183 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1184 :         if (_Newsize > max_size()) {

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	ebx, ecx
	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN74@Resize_rea

; 1186 :         }
; 1187 : 
; 1188 :         auto& _My_data    = _Mypair._Myval2;
; 1189 :         pointer& _Myfirst = _My_data._Myfirst;
; 1190 :         pointer& _Mylast  = _My_data._Mylast;
; 1191 : 
; 1192 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ebx+4]

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 2147483647				; 7fffffffH

; 1186 :         }
; 1187 : 
; 1188 :         auto& _My_data    = _Mypair._Myval2;
; 1189 :         pointer& _Myfirst = _My_data._Myfirst;
; 1190 :         pointer& _Mylast  = _My_data._Mylast;
; 1191 : 
; 1192 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Oldsize$1$[ebp], ecx

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	esi, edi
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [edx+ecx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	esi, edi
	cmovb	esi, edi
$LN11@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN18@Resize_rea

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	$LN75@Resize_rea

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN65@Resize_rea

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN17@Resize_rea
$LN18@Resize_rea:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	esi, esi
	je	SHORT $LN19@Resize_rea

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN17@Resize_rea
$LN19@Resize_rea:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN17@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1200 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	push	eax
	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1196 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	eax, DWORD PTR [edi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	push	eax
	call	_memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3308 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

	mov	ecx, DWORD PTR [ebx]

; 3309 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3310 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	edi
	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN58@Resize_rea

; 1680 :             _Destroy(_Myfirst, _Mylast);
; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN68@Resize_rea

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN65@Resize_rea

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN68@Resize_rea:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN58@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1685 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ebx], edi
	add	eax, edi
	mov	DWORD PTR [ebx+4], eax

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+8], eax
	pop	ebx

; 1209 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN65@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1185 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN75@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN72@Resize_rea:
	int	3
??$_Resize_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEXIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1183 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1184 :         if (_Newsize > max_size()) {

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	ebx, ecx
	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN76@Resize_rea

; 1186 :         }
; 1187 : 
; 1188 :         auto& _My_data    = _Mypair._Myval2;
; 1189 :         pointer& _Myfirst = _My_data._Myfirst;
; 1190 :         pointer& _Mylast  = _My_data._Mylast;
; 1191 : 
; 1192 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ebx+4]

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 2147483647				; 7fffffffH

; 1186 :         }
; 1187 : 
; 1188 :         auto& _My_data    = _Mypair._Myval2;
; 1189 :         pointer& _Myfirst = _My_data._Myfirst;
; 1190 :         pointer& _Mylast  = _My_data._Mylast;
; 1191 : 
; 1192 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Oldsize$1$[ebp], ecx

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]

; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1623 :             return _Newsize; // geometric growth would overflow

	mov	esi, edi
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [edx+ecx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	esi, edi
	cmovb	esi, edi
$LN11@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN18@Resize_rea

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, esi
	jbe	$LN77@Resize_rea

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN67@Resize_rea

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN17@Resize_rea
$LN18@Resize_rea:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	esi, esi
	je	SHORT $LN19@Resize_rea

; 51   :         return ::operator new(_Bytes);

	push	esi
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN17@Resize_rea
$LN19@Resize_rea:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN17@Resize_rea:

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, ecx
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1196 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	eax, DWORD PTR [edi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	0
	push	eax
	call	_memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3308 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

	mov	ecx, DWORD PTR [ebx]

; 3309 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3310 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	edi
	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN60@Resize_rea

; 1680 :             _Destroy(_Myfirst, _Mylast);
; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN70@Resize_rea

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN67@Resize_rea

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN70@Resize_rea:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN60@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1685 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ebx], edi
	add	eax, edi
	mov	DWORD PTR [ebx+4], eax

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+8], eax
	pop	ebx

; 1209 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN67@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN76@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1185 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN77@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN74@Resize_rea:
	int	3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1825 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1826 :     // value-initialize _Count objects to raw _First, using _Al
; 1827 :     using _Ptrty = typename _Alloc::value_type*;
; 1828 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1829 :         (void) _Al;
; 1830 :         auto _PFirst = _Unfancy(_First);
; 1831 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1832 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1833 :     } else {
; 1834 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1835 :         for (; 0 < _Count; --_Count) {
; 1836 :             _Backout._Emplace_back();
; 1837 :         }
; 1838 : 
; 1839 :         return _Backout._Release();
; 1840 :     }
; 1841 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPAEPAEIABEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPAEPAEIABEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1712 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp

; 1713 :     // copy _Count copies of _Val to raw _First, using _Al
; 1714 :     using _Ty = typename _Alloc::value_type;
; 1715 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1716 :         (void) _Al;
; 1717 :         _CSTD memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));

	mov	eax, DWORD PTR __Val$[ebp]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx
	movzx	eax, BYTE PTR [eax]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1718 :         return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1719 :     } else {
; 1720 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1721 :         for (; 0 < _Count; --_Count) {
; 1722 :             _Backout._Emplace_back(_Val);
; 1723 :         }
; 1724 : 
; 1725 :         return _Backout._Release();
; 1726 :     }
; 1727 : }

	pop	ebp
	ret	0
??$_Uninitialized_fill_n@V?$allocator@E@std@@@std@@YAPAEPAEIABEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_fill_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1708 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 1670 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1671 :         // orphan all iterators, discard old array, acquire new array
; 1672 :         auto& _My_data    = _Mypair._Myval2;
; 1673 :         pointer& _Myfirst = _My_data._Myfirst;
; 1674 :         pointer& _Mylast  = _My_data._Mylast;
; 1675 :         pointer& _Myend   = _My_data._Myend;
; 1676 : 
; 1677 :         _My_data._Orphan_all();
; 1678 : 
; 1679 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@Change_arr

; 1680 :             _Destroy(_Myfirst, _Mylast);
; 1681 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN15@Change_arr

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN18@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1684 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1685 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	add	eax, ecx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], eax

; 1686 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1687 :     }

	pop	ebp
	ret	12					; 0000000cH
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Change_arr:
	int	3
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1618 :     size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]

; 1619 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1620 :         const size_type _Oldcapacity = capacity();
; 1621 : 
; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 2147483647				; 7fffffffH

; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	edx, DWORD PTR [ecx]

; 1619 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1620 :         const size_type _Oldcapacity = capacity();
; 1621 : 
; 1622 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 1623 :             return _Newsize; // geometric growth would overflow
; 1624 :         }
; 1625 : 
; 1626 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1627 : 
; 1628 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN1@Calculate_
$LN7@Calculate_:

; 1629 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1630 :         }
; 1631 : 
; 1632 :         return _Geometric; // geometric growth is sufficient
; 1633 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1608 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1612 :     }

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1489 :         return _Min_value(

	mov	eax, 2147483647				; 7fffffffH

; 1490 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1491 :     }

	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN4@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN26@allocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN13@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN13@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN5@allocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN5@allocate:

; 183  :     return nullptr;

	xor	eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN26@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN24@allocate:
	int	3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 781  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1740 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1741 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1598 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector

; 1601 :     }

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1494 :         auto& _My_data = _Mypair._Myval2;
; 1495 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1496 :     }

	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 681  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

	mov	eax, ecx

; 1341 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy@E@std@@YAPAEPAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

	mov	eax, ecx

; 290  : }

	ret	0
??$_Unfancy@E@std@@YAPAEPAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1815 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1816 :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 1817 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 1818 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1819 :     return _Last;

	mov	eax, esi
	pop	esi

; 1820 : }

	ret	0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility

; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 1655 :         return _Dest + (_ULast - _UFirst);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

	pop	ebp
	ret	0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Get_unwrapped@E@std@@YAPAEQAE@Z
_TEXT	SEGMENT
??$_Get_unwrapped@E@std@@YAPAEQAE@Z PROC		; std::_Get_unwrapped<unsigned char>, COMDAT
; __Ptr$ = ecx

; 1140 :     return _Ptr;

	mov	eax, ecx

; 1141 : }

	ret	0
??$_Get_unwrapped@E@std@@YAPAEQAE@Z ENDP		; std::_Get_unwrapped<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3307 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { // implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	push	esi

; 3308 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3309 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3310 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3311 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3312 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 3313 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 3314 : }

	pop	ebp
	ret	0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Eos

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ecx]

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	BYTE PTR [eax], 0

; 4175 :     }

	ret	4
$LN8@Eos:

; 4174 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

	mov	BYTE PTR [ecx], 0

; 4175 :     }

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 4160 :     void _Become_small() {

	push	esi
	push	edi
	mov	edi, ecx

; 4161 :         // release any held storage and return to small string mode
; 4162 :         // pre: *this is in large string mode
; 4163 :         // pre: this is small enough to return to small string mode
; 4164 :         _Mypair._Myval2._Orphan_all();
; 4165 :         const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4166 :         auto& _Al          = _Getal();
; 4167 :         _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4168 :         _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);

	mov	eax, DWORD PTR [edi+16]
	mov	esi, DWORD PTR [edi]
	inc	eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	esi
	push	edi
	call	_memcpy

; 4169 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	mov	ecx, DWORD PTR [edi+20]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 4169 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN19@Become_sma

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN16@Become_sma

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN19@Become_sma:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4170 :         _Mypair._Myval2._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH
	pop	edi
	pop	esi

; 4171 :     }

	ret	0
$LN16@Become_sma:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN23@Become_sma:
	int	3
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2152 :         const value_type* _Result = _Bx._Buf;
; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2154 :             _Result = _Unfancy(_Bx._Ptr);
; 2155 :         }
; 2156 : 
; 2157 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2158 :     }

	ret	0
$LN6@Myptr:

; 2154 :             _Result = _Unfancy(_Bx._Ptr);
; 2155 :         }
; 2156 : 
; 2157 :         return _Result;

	mov	eax, ecx

; 2158 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3500 :     _NODISCARD const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2153 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN8@operator

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN8@operator:

; 3501 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3502 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3503 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3504 :         return _Mypair._Myval2._Myptr()[_Off];
; 3505 :     }

	add	eax, ecx
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 3589 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3590 :     }

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 2162 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2143 :         value_type* _Result = _Bx._Buf;
; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2145 :             _Result = _Unfancy(_Bx._Ptr);
; 2146 :         }
; 2147 : 
; 2148 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2149 :     }

	ret	0
$LN6@Myptr:

; 2145 :             _Result = _Unfancy(_Bx._Ptr);
; 2146 :         }
; 2147 : 
; 2148 :         return _Result;

	mov	eax, ecx

; 2149 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4202 :         _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4085 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[ebp]
	or	ecx, 15					; 0000000fH
	cmp	ecx, edi

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4088 :             return _Max;
; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4096 :     }

	pop	esi
	pop	ebp
	ret	0
$LN7@Calculate_:

; 4092 :             return _Max;

	mov	eax, edi
	pop	edi

; 4096 :     }

	pop	esi
	pop	ebp
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 681  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

	mov	eax, ecx

; 1341 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4220 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4221 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 37   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 38   : }

	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	cmovb	ecx, edx
	mov	eax, ecx

; 31   : }

	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 558  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 559  :     }

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3597 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3598 :         const size_type _Storage_max = // can always store small string
; 3599 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3600 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3601 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3602 :         );
; 3603 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4098 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483647				; 7fffffffH
	or	edx, 15					; 0000000fH

; 4098 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4099 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4088 :             return _Max;
; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4099 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 4100 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4099 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4100 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

	mov	eax, ecx

; 1337 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4216 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4217 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :     {

	push	ebp
	mov	ebp, esp

; 64   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 65   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
__Message$dead$ = 8					; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 127  :     {

	xorps	xmm0, xmm0

; 128  :     }

	mov	eax, ecx

; 62   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 63   :     {
; 64   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 127  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 128  :     }

	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 138  :     {

	xorps	xmm0, xmm0

; 139  :     }

	mov	eax, ecx

; 62   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 63   :     {
; 64   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 138  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 139  :     }

	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 86   :     {

	push	esi
	mov	esi, ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 69   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 68   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 88   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 86   :     {

	push	esi
	mov	esi, ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 69   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 68   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 86   :     {

	push	esi
	mov	esi, ecx

; 87   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 93   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 71   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 322  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 323  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	mov	eax, ecx
	push	eax
	call	__CxxThrowException@8
$LN3@Throw_bad_:
	int	3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT
; __Bytes$ = ecx

; 88   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 91   :         _Throw_bad_array_new_length(); // add overflow
; 92   :     }
; 93   : 
; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 98   : 
; 99   : #ifdef _DEBUG
; 100  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 101  : #endif // _DEBUG
; 102  :     return _Ptr;
; 103  : }

	ret	0
$LN7@Allocate_m:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT
; __Bytes$ = ecx

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 52   :     }

	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT
; __Bytes$ = ecx

; 172  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 173  : #if defined(_M_IX86) || defined(_M_X64)
; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 184  : }

	ret	0
$LN11@Allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 184  : }

	ret	0
$LN3@Allocate:

; 180  :         return _Traits::_Allocate(_Bytes);
; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax

; 184  : }

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, ecx

; 40   : }

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN4@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN26@allocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN13@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN13@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN5@allocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN5@allocate:

; 183  :     return nullptr;

	xor	eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	pop	ebp
	ret	4
$LN26@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN24@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 1061 :     void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

	mov	eax, ecx

; 290  : }

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 107  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 108  :     _Bytes += _Non_user_size;

	add	DWORD PTR [edx], 35			; 00000023H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 127  : }

	ret	0
$LN7@Adjust_man:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 108  :     _Bytes += _Non_user_size;

	push	esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN10@Deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN13@Deallocate:

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 196  : }

	ret	0
$LN10@Deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@Deallocate:
	int	3
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 781  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 330  :         const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 331  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 333  :     }

	pop	ebp
	ret	0
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 371  :         const _Elem _Ch) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	edx, BYTE PTR __Ch$[ebp]
	movzx	eax, dl
	shl	dx, 8
	or	dx, ax
	mov	eax, ecx
	mov	BYTE PTR [ecx], dl

; 374  :     }

	pop	ebp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 377  :         _Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 378  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$dead$ = 20					; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$dead$ = ecx

; 2803 :                 const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 2803 :                 const _Elem _Ch) {

	push	edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi+edi], cl

; 2804 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2805 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2806 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+edi+1], 0
	pop	edi
	pop	esi

; 2807 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, edx

; 171  :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 276  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1428 : }

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
tv472 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
tv473 = 20						; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 4129 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 4130 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4131 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4132 :         auto& _My_data            = _Mypair._Myval2;
; 4133 :         const size_type _Old_size = _My_data._Mysize;
; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	push	edi
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	cmp	eax, 1
	jb	$LN69@Reallocate

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]
	lea	edi, DWORD PTR [edx+1]

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4088 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN10@Reallocate

; 4092 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN70@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN55@Reallocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 51   :         return ::operator new(_Bytes);

	add	esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	esi, esi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ebx+16], eax
	movsx	eax, BYTE PTR _<_Args_1>$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	edi, DWORD PTR [esi+edx]
	mov	DWORD PTR tv473[ebp], eax
	mov	DWORD PTR tv472[ebp], edi
	push	edx
	jb	SHORT $LN3@Reallocate

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	esi
	call	_memcpy

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv473[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	eax, DWORD PTR tv472[ebp]
	mov	BYTE PTR [eax], cl

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx

; 2806 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax+1], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN58@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN55@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN58@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 4157 :         return *this;

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN55@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	esi
	call	_memcpy

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv473[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 4157 :         return *this;

	mov	eax, ebx

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [edi], cl

; 2806 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+1], 0

; 4157 :         return *this;

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 4158 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN69@Reallocate:

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN67@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T2 = -4						; size = 1
__Count$dead$ = 8					; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2790 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	edx, ecx
	push	esi

; 2791 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2792 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [edx+20]
	mov	eax, ecx
	mov	esi, DWORD PTR [edx+16]
	sub	eax, esi
	cmp	eax, 1
	jb	SHORT $LN2@append

; 2793 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR [edx+16], eax
	push	edi

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	edi, edx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [edx]
$LN5@append:

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[ebp]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2797 :             return *this;

	mov	eax, edx

; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [edi+esi], cl

; 2794 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2795 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
; 2796 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+esi+1], 0

; 2797 :             return *this;

	pop	edi
	pop	esi

; 2801 :             _Count,
; 2802 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2803 :                 const _Elem _Ch) {
; 2804 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2805 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2806 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2807 :             },
; 2808 :             _Count, _Ch);
; 2809 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@append:

; 2798 :         }
; 2799 : 
; 2800 :         return _Reallocate_grow_by(

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T2[ebp], 0
	push	ecx
	push	DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, edx
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
	pop	esi

; 2801 :             _Count,
; 2802 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2803 :                 const _Elem _Ch) {
; 2804 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2805 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2806 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2807 :             },
; 2808 :             _Count, _Ch);
; 2809 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1484 :         auto& _My_data = _Mypair._Myval2;
; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]

; 1486 :     }

	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
END
